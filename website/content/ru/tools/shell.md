# Инструмент Shell (`run_shell_command`)

Этот документ описывает инструмент `run_shell_command` для Qwen Code.

## Описание

Используйте `run_shell_command` для взаимодействия с базовой системой, запуска скриптов или выполнения операций в командной строке. `run_shell_command` выполняет указанную shell-команду. В Windows команда будет выполнена с помощью `cmd.exe /c`. На других платформах команда будет выполнена с помощью `bash -c`.

### Аргументы

`run_shell_command` принимает следующие аргументы:

- `command` (string, обязательный): Точная shell-команда для выполнения.
- `description` (string, опциональный): Краткое описание цели команды, которое будет показано пользователю.
- `directory` (string, опциональный): Директория (относительно корня проекта), в которой нужно выполнить команду. Если не указана, команда выполняется в корне проекта.

## Как использовать `run_shell_command` с Qwen Code

При использовании `run_shell_command` команда выполняется как подпроцесс. `run_shell_command` может запускать фоновые процессы с помощью `&`. Инструмент возвращает подробную информацию о выполнении, включая:

- `Command`: Выполненная команда.
- `Directory`: Директория, в которой была запущена команда.
- `Stdout`: Вывод из стандартного потока вывода.
- `Stderr`: Вывод из стандартного потока ошибок.
- `Error`: Любое сообщение об ошибке, сообщенное подпроцессом.
- `Exit Code`: Код завершения команды.
- `Signal`: Номер сигнала, если команда была прервана сигналом.
- `Background PIDs`: Список PID для любых запущенных фоновых процессов.

Использование:

```
run_shell_command(command="Ваши команды.", description="Ваше описание команды.", directory="Ваша директория выполнения.")
```

## Примеры `run_shell_command`

Показать список файлов в текущей директории:

```
run_shell_command(command="ls -la")
```

Запустить скрипт из определенной директории:

```
run_shell_command(command="./my_script.sh", directory="scripts", description="Run my custom script")
```

Запустить сервер в фоновом режиме:

```
run_shell_command(command="npm run dev &", description="Start development server in background")
```

## Важные замечания

- **Безопасность:** Будьте осторожны при выполнении команд, особенно тех, что строятся на основе пользовательского ввода, чтобы избежать уязвимостей безопасности.
- **Интерактивные команды:** Избегайте команд, требующих интерактивного ввода от пользователя, так как это может привести к зависанию инструмента. По возможности используйте флаги для отключения интерактивности (например, `npm init -y`).
- **Обработка ошибок:** Проверяйте поля `Stderr`, `Error` и `Exit Code`, чтобы определить, успешно ли выполнилась команда.
- **Фоновые процессы:** Если команда запускается в фоне с помощью `&`, инструмент немедленно возвращает управление, а процесс продолжает выполняться в фоновом режиме. Поле `Background PIDs` будет содержать ID фонового процесса.

## Переменные окружения

Когда `run_shell_command` выполняет команду, она устанавливает переменную окружения `QWEN_CODE=1` в среде подпроцесса. Это позволяет скриптам или инструментам определить, запущены ли они из CLI.

## Ограничения команд

Вы можете ограничить команды, которые могут выполняться инструментом `run_shell_command`, используя настройки `coreTools` и `excludeTools` в вашем конфигурационном файле.

- `coreTools`: Чтобы ограничить `run_shell_command` определенным набором команд, добавьте записи в список `coreTools` в формате `run_shell_command(<command>)`. Например, `"coreTools": ["run_shell_command(git)"]` разрешит только команды `git`. Включение общего `run_shell_command` действует как wildcard, разрешая любую команду, не заблокированную явно.
- `excludeTools`: Чтобы заблокировать определенные команды, добавьте записи в список `excludeTools` в формате `run_shell_command(<command>)`. Например, `"excludeTools": ["run_shell_command(rm)"]` заблокирует команды `rm`.

Логика валидации разработана так, чтобы быть безопасной и гибкой:

1.  **Цепочки команд отключены**: Инструмент автоматически разделяет команды, объединенные с помощью `&&`, `||` или `;`, и проверяет каждую часть отдельно. Если какая-либо часть цепочки запрещена, вся команда блокируется.
2.  **Сопоставление по префиксу**: Инструмент использует сопоставление по префиксу. Например, если вы разрешаете `git`, вы можете выполнить `git status` или `git log`.
3.  **Приоритет черного списка**: Список `excludeTools` всегда проверяется первым. Если команда совпадает с заблокированным префиксом, она будет отклонена, даже если она также совпадает с разрешенным префиксом в `coreTools`.

### Примеры ограничений команд

**Разрешить только определённые префиксы команд**

Чтобы разрешить только команды `git` и `npm`, а все остальные блокировать:

```json
{
  "coreTools": ["run_shell_command(git)", "run_shell_command(npm)"]
}
```

- `git status`: Разрешено
- `npm install`: Разрешено
- `ls -l`: Заблокировано

**Блокировать определённые префиксы команд**

Чтобы заблокировать `rm` и разрешить все остальные команды:

```json
{
  "coreTools": ["run_shell_command"],
  "excludeTools": ["run_shell_command(rm)"]
}
```

- `rm -rf /`: Заблокировано
- `git status`: Разрешено
- `npm install`: Разрешено

**Блокировка имеет приоритет**

Если префикс команды указан и в `coreTools`, и в `excludeTools`, то он будет заблокирован.

```json
{
  "coreTools": ["run_shell_command(git)"],
  "excludeTools": ["run_shell_command(git push)"]
}
```

- `git push origin main`: Заблокировано
- `git status`: Разрешено

**Блокировать все shell-команды**

Чтобы заблокировать все shell-команды, добавьте wildcard `run_shell_command` в `excludeTools`:

```json
{
  "excludeTools": ["run_shell_command"]
}
```

- `ls -l`: Заблокировано
- `любая другая команда`: Заблокировано

## Заметка о безопасности для `excludeTools`

Ограничения, специфичные для команд, в `excludeTools` для `run_shell_command`, основаны на простом сравнении строк и могут быть легко обойдены. Эта функция **не является механизмом безопасности** и не должна использоваться для безопасного выполнения недоверенного кода. Рекомендуется использовать `coreTools` для явного выбора команд, которые могут быть выполнены.