# Настройка Qwen Code

Qwen Code предоставляет несколько способов настройки своего поведения, включая переменные окружения, аргументы командной строки и файлы настроек. В этом документе описаны различные методы конфигурации и доступные параметры.

## Уровни конфигурации

Конфигурация применяется в следующем порядке приоритета (параметры с меньшими номерами переопределяются параметрами с большими номерами):

1.  **Значения по умолчанию:** Жестко закодированные значения по умолчанию внутри приложения.
2.  **Файл системных настроек по умолчанию:** Общесистемные настройки по умолчанию, которые могут быть переопределены другими файлами настроек.
3.  **Файл пользовательских настроек:** Глобальные настройки для текущего пользователя.
4.  **Файл настроек проекта:** Настройки, специфичные для проекта.
5.  **Файл системных настроек:** Общесистемные настройки, которые переопределяют все остальные файлы настроек.
6.  **Переменные окружения:** Общесистемные или специфичные для сессии переменные, потенциально загружаемые из файлов `.env`.
7.  **Аргументы командной строки:** Значения, передаваемые при запуске CLI.

## Файлы настроек

Qwen Code использует JSON-файлы настроек для постоянного хранения конфигурации. Эти файлы могут находиться в четырех местах:

- **Файл системных значений по умолчанию:**
  - **Расположение:** `/etc/qwen-code/system-defaults.json` (Linux), `C:\ProgramData\qwen-code\system-defaults.json` (Windows) или `/Library/Application Support/QwenCode/system-defaults.json` (macOS). Путь можно переопределить с помощью переменной окружения `QWEN_CODE_SYSTEM_DEFAULTS_PATH`.
  - **Область применения:** Предоставляет базовый уровень системных настроек по умолчанию. Эти настройки имеют самый низкий приоритет и предназначены для переопределения пользовательскими, проектными или системными настройками.
- **Файл пользовательских настроек:**
  - **Расположение:** `~/.qwen/settings.json` (где `~` — ваша домашняя директория).
  - **Область применения:** Применяется ко всем сессиям Qwen Code текущего пользователя.
- **Файл настроек проекта:**
  - **Расположение:** `.qwen/settings.json` в корневой директории вашего проекта.
  - **Область применения:** Применяется только при запуске Qwen Code из этого конкретного проекта. Настройки проекта переопределяют пользовательские настройки.

- **Файл системных настроек:**
  - **Расположение:** `/etc/qwen-code/settings.json` (Linux), `C:\ProgramData\qwen-code\settings.json` (Windows) или `/Library/Application Support/QwenCode/settings.json` (macOS). Путь можно переопределить с помощью переменной окружения `QWEN_CODE_SYSTEM_SETTINGS_PATH`.
  - **Область применения:** Применяется ко всем сессиям Qwen Code в системе, для всех пользователей. Системные настройки переопределяют пользовательские и проектные настройки. Может быть полезно системным администраторам в корпоративной среде для управления установками Qwen Code у пользователей.

**Примечание о переменных окружения в настройках:** Строковые значения в ваших файлах `settings.json` могут ссылаться на переменные окружения, используя синтаксис `$VAR_NAME` или `${VAR_NAME}`. Эти переменные будут автоматически разрешены при загрузке настроек. Например, если у вас есть переменная окружения `MY_API_TOKEN`, вы можете использовать её в `settings.json` следующим образом: `"apiKey": "$MY_API_TOKEN"`.

### Каталог `.qwen` в вашем проекте

Помимо файла настроек проекта, каталог `.qwen` может содержать другие файлы, относящиеся к работе Qwen Code, например:

- [Пользовательские профили песочницы](#sandboxing) (например, `.qwen/sandbox-macos-custom.sb`, `.qwen/sandbox.Dockerfile`).

### Доступные настройки в `settings.json`:

- **`contextFileName`** (строка или массив строк):
  - **Описание:** Указывает имя файла для контекстных файлов (например, `QWEN.md`, `AGENTS.md`). Может быть как одно имя файла, так и список допустимых имен.
  - **По умолчанию:** `QWEN.md`
  - **Пример:** `"contextFileName": "AGENTS.md"`

- **`bugCommand`** (объект):
  - **Описание:** Переопределяет URL по умолчанию для команды `/bug`.
  - **По умолчанию:** `"urlTemplate": "https://github.com/QwenLM/qwen-code/issues/new?template=bug_report.yml&title={title}&info={info}"`
  - **Свойства:**
    - **`urlTemplate`** (строка): URL, который может содержать плейсхолдеры `{title}` и `{info}`.
  - **Пример:**
    ```json
    "bugCommand": {
      "urlTemplate": "https://bug.example.com/new?title={title}&info={info}"
    }
    ```

- **`fileFiltering`** (объект):
  - **Описание:** Управляет поведением фильтрации файлов с учетом Git при использовании команд @ и инструментов поиска файлов.
  - **По умолчанию:** `"respectGitIgnore": true, "enableRecursiveFileSearch": true`
  - **Свойства:**
    - **`respectGitIgnore`** (булево значение): Определяет, следует ли учитывать шаблоны из .gitignore при поиске файлов. Если установлено значение `true`, то файлы, игнорируемые Git (например, `node_modules/`, `dist/`, `.env`), автоматически исключаются из команд @ и операций отображения списка файлов.
    - **`enableRecursiveFileSearch`** (булево значение): Включает рекурсивный поиск файлов в текущем дереве каталогов при автодополнении префиксов @ в prompt'е.
    - **`disableFuzzySearch`** (булево значение): Если `true`, отключает нечеткий поиск файлов, что может повысить производительность в проектах с большим количеством файлов.
  - **Пример:**
    ```json
    "fileFiltering": {
      "respectGitIgnore": true,
      "enableRecursiveFileSearch": false,
      "disableFuzzySearch": true
    }
    ```

### Устранение проблем с производительностью поиска файлов

Если вы сталкиваетесь с проблемами производительности при поиске файлов (например, при использовании автодополнения через `@`), особенно в проектах с очень большим количеством файлов, попробуйте следующие решения в порядке рекомендации:

1. **Используйте `.qwenignore`:** Создайте файл `.qwenignore` в корне вашего проекта, чтобы исключить директории, содержащие большое количество ненужных файлов (например, сборочные артефакты, логи, `node_modules`). Снижение общего числа сканируемых файлов — это самый эффективный способ улучшить производительность.

2. **Отключите нечеткий поиск:** Если игнорирование файлов недостаточно, можно отключить нечеткий поиск, установив `disableFuzzySearch` в значение `true` в вашем файле `settings.json`. Это переключит систему на более простой алгоритм точного совпадения, который может работать быстрее.

3. **Отключите рекурсивный поиск файлов:** В крайнем случае можно полностью отключить рекурсивный поиск файлов, установив `enableRecursiveFileSearch` в значение `false`. Это будет самым быстрым вариантом, так как избежит рекурсивного обхода проекта. Однако вам придется указывать полные пути к файлам при использовании автодополнения через `@`.

---

- **`coreTools`** (массив строк):
  - **Описание:** Позволяет указать список имен основных инструментов, которые должны быть доступны модели. Это можно использовать для ограничения набора встроенных инструментов. Список доступных инструментов см. в разделе [Встроенные инструменты](../core/tools-api.md#built-in-tools). Также можно указать ограничения на конкретные команды для инструментов, поддерживающих это, например, для `ShellTool`. Например, `"coreTools": ["ShellTool(ls -l)"]` разрешит выполнение только команды `ls -l`.
  - **По умолчанию:** Все инструменты доступны для использования моделью.
  - **Пример:** `"coreTools": ["ReadFileTool", "GlobTool", "ShellTool(ls)"]`.

- **`allowedTools`** (массив строк):
  - **По умолчанию:** `undefined`
  - **Описание:** Список имен инструментов, для которых будет пропущено диалоговое окно подтверждения. Полезно для часто используемых и доверенных инструментов. Логика соответствия такая же, как у `coreTools`.
  - **Пример:** `"allowedTools": ["ShellTool(git status)"]`.

- **`excludeTools`** (массив строк):
  - **Описание:** Позволяет указать список имен инструментов, которые должны быть исключены из доступа модели. Инструмент, указанный и в `excludeTools`, и в `coreTools`, будет исключен. Также можно задавать ограничения на конкретные команды, например, для `ShellTool`. Например, `"excludeTools": ["ShellTool(rm -rf)"]` заблокирует команду `rm -rf`.
  - **По умолчанию:** Никакие инструменты не исключены.
  - **Пример:** `"excludeTools": ["run_shell_command", "findFiles"]`.
  - **Примечание по безопасности:** Ограничения на уровне команд в `excludeTools` для `run_shell_command` основаны на простом сравнении строк и могут быть легко обойдены. Эта функция **не является механизмом безопасности** и не должна использоваться для безопасного выполнения недоверенного кода. Рекомендуется использовать `coreTools` для явного выбора разрешенных команд.

- **`allowMCPServers`** (массив строк):
  - **Описание:** Позволяет указать список серверов MCP, которые будут доступны модели. Можно использовать для ограничения набора серверов, к которым модель может подключаться. Обратите внимание, что этот параметр будет проигнорирован, если установлен флаг `--allowed-mcp-server-names`.
  - **По умолчанию:** Все серверы MCP доступны.
  - **Пример:** `"allowMCPServers": ["myPythonServer"]`.
  - **Примечание по безопасности:** Используется простое сравнение строк по имени сервера, которое может быть изменено. Администраторам, желающим предотвратить обход этой настройки, следует настраивать `mcpServers` на уровне системы таким образом, чтобы пользователь не мог задавать свои собственные серверы. Не следует полагаться на это как на надежный механизм безопасности.

- **`excludeMCPServers`** (массив строк):
  - **Описание:** Позволяет указать список серверов MCP, которые должны быть исключены. Сервер, указанный и в `excludeMCPServers`, и в `allowMCPServers`, будет исключен. Этот параметр также игнорируется, если установлен флаг `--allowed-mcp-server-names`.
  - **По умолчанию:** Никакие серверы MCP не исключены.
  - **Пример:** `"excludeMCPServers": ["myNodeServer"]`.
  - **Примечание по безопасности:** Используется простое сравнение строк по имени сервера. Администраторам рекомендуется настраивать `mcpServers` на уровне системы. Не следует полагаться на это как на надежный механизм безопасности.

- **`autoAccept`** (boolean):
  - **Описание:** Определяет, будет ли CLI автоматически принимать и выполнять вызовы инструментов, считающихся безопасными (например, операции только для чтения), без явного подтверждения пользователя. Если установлено в `true`, CLI пропустит запрос подтверждения для таких инструментов.
  - **По умолчанию:** `false`
  - **Пример:** `"autoAccept": true`

- **`theme`** (строка):
  - **Описание:** Задает визуальную [тему](./themes.md) для Qwen Code.
  - **По умолчанию:** `"Default"`
  - **Пример:** `"theme": "GitHub"`

- **`vimMode`** (boolean):
  - **Описание:** Включает или отключает режим vim для редактирования ввода. При включении область ввода поддерживает команды навигации и редактирования в стиле vim с режимами NORMAL и INSERT. Статус режима отображается в нижнем колонтитуле и сохраняется между сессиями.
  - **По умолчанию:** `false`
  - **Пример:** `"vimMode": true`

- **`sandbox`** (boolean или строка):
  - **Описание:** Контролирует использование песочницы для выполнения инструментов. Если установлено в `true`, Qwen Code использует предварительно собраный Docker-образ `qwen-code-sandbox`. Подробнее см. в разделе [Песочница](#sandboxing).
  - **По умолчанию:** `false`
  - **Пример:** `"sandbox": "docker"`

- **`toolDiscoveryCommand`** (строка):
  - **Описание:** **Совместимость с Gemini CLI.** Определяет пользовательскую shell-команду для обнаружения инструментов в вашем проекте. Команда должна выводить в `stdout` JSON-массив [объявлений функций](https://ai.google.dev/gemini-api/docs/function-calling#function-declarations). Обертки инструментов не обязательны.
  - **По умолчанию:** Пусто
  - **Пример:** `"toolDiscoveryCommand": "bin/get_tools"`

- **`toolCallCommand`** (строка):
  - **Описание:** **Совместимость с Gemini CLI.** Определяет пользовательскую shell-команду для вызова конкретного инструмента, найденного через `toolDiscoveryCommand`. Команда должна соответствовать следующим требованиям:
    - Первым аргументом командной строки должно быть имя функции (точно как в [объявлении функции](https://ai.google.dev/gemini-api/docs/function-calling#function-declarations)).
    - Функция должна читать аргументы в формате JSON из `stdin`, аналогично [`functionCall.args`](https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/inference#functioncall).
    - Функция должна возвращать результат в формате JSON в `stdout`, аналогично [`functionResponse.response.content`](https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/inference#functionresponse).
  - **По умолчанию:** Пусто
  - **Пример:** `"toolCallCommand": "bin/call_tool"`

- **`mcpServers`** (объект):
  - **Описание:** Настраивает подключения к одному или нескольким серверам Model-Context Protocol (MCP) для обнаружения и использования пользовательских инструментов. Qwen Code пытается подключиться к каждому указанному серверу для получения списка доступных инструментов. Если несколько серверов предоставляют инструмент с одинаковым именем, имена инструментов будут дополнены псевдонимом сервера (например, `serverAlias__actualToolName`) во избежание конфликтов. Обратите внимание, что система может удалить некоторые свойства из определений инструментов MCP для обеспечения совместимости. Должно быть указано хотя бы одно из: `command`, `url` или `httpUrl`. Приоритет: `httpUrl`, затем `url`, затем `command`.
  - **По умолчанию:** Пусто
  - **Свойства:**
    - **`<SERVER_NAME>`** (объект): Параметры сервера с указанным именем.
      - `command` (строка, опционально): Команда для запуска MCP-сервера через стандартный ввод/вывод.
      - `args` (массив строк, опционально): Аргументы команды.
      - `env` (объект, опционально): Переменные окружения для процесса сервера.
      - `cwd` (строка, опционально): Рабочая директория для запуска сервера.
      - `url` (строка, опционально): URL сервера MCP, использующего Server-Sent Events (SSE).
      - `httpUrl` (строка, опционально): URL сервера MCP, использующего потоковый HTTP.
      - `headers` (объект, опционально): HTTP-заголовки для запросов к `url` или `httpUrl`.
      - `timeout` (число, опционально): Таймаут в миллисекундах для запросов к этому серверу.
      - `trust` (boolean, опционально): Доверять серверу и пропускать все подтверждения вызова инструментов.
      - `description` (строка, опционально): Краткое описание сервера, может использоваться для отображения.
      - `includeTools` (массив строк, опционально): Список инструментов, которые нужно включить с этого сервера. Если указан, то только эти инструменты будут доступны (whitelist). Если не указан — доступны все инструменты.
      - `excludeTools` (массив строк, опционально): Список инструментов, которые нужно исключить с этого сервера. Эти инструменты не будут доступны, даже если сервер их предоставляет. **Примечание:** `excludeTools` имеет приоритет над `includeTools` — если инструмент есть в обоих списках, он будет исключен.
  - **Пример:**
    ```json
    "mcpServers": {
      "myPythonServer": {
        "command": "python",
        "args": ["mcp_server.py", "--port", "8080"],
        "cwd": "./mcp_tools/python",
        "timeout": 5000,
        "includeTools": ["safe_tool", "file_reader"],
      },
      "myNodeServer": {
        "command": "node",
        "args": ["mcp_server.js"],
        "cwd": "./mcp_tools/node",
        "excludeTools": ["dangerous_tool", "file_deleter"]
      },
      "myDockerServer": {
        "command": "docker",
        "args": ["run", "-i", "--rm", "-e", "API_KEY", "ghcr.io/foo/bar"],
        "env": {
          "API_KEY": "$MY_API_TOKEN"
        }
      },
      "mySseServer": {
        "url": "http://localhost:8081/events",
        "headers": {
          "Authorization": "Bearer $MY_SSE_TOKEN"
        },
        "description": "Пример SSE-сервера MCP."
      },
      "myStreamableHttpServer": {
        "httpUrl": "http://localhost:8082/stream",
        "headers": {
          "X-API-Key": "$MY_HTTP_API_KEY"
        },
        "description": "Пример потокового HTTP-сервера MCP."
      }
    }
    ```

- **`checkpointing`** (объект):
  - **Описание:** Настраивает функцию контрольных точек, позволяющую сохранять и восстанавливать состояние беседы и файлов. Подробнее см. в [документации по контрольным точкам](../checkpointing.md).
  - **По умолчанию:** `{"enabled": false}`
  - **Свойства:**
    - **`enabled`** (boolean): Если `true`, команда `/restore` становится доступной.

- **`preferredEditor`** (строка):
  - **Описание:** Указывает предпочитаемый редактор для просмотра diff'ов.
  - **По умолчанию:** `vscode`
  - **Пример:** `"preferredEditor": "vscode"`

- **`telemetry`** (объект)
  - **Описание:** Настраивает сбор логов и метрик для Qwen Code. Подробнее см. в разделе [Телеметрия](../telemetry.md).
  - **По умолчанию:** `{"enabled": false, "target": "local", "otlpEndpoint": "http://localhost:4317", "logPrompts": true}`
  - **Свойства:**
    - **`enabled`** (boolean): Включена ли телеметрия.
    - **`target`** (строка): Назначение собранных данных. Поддерживаются значения `local` и `gcp`.
    - **`otlpEndpoint`** (строка): Endpoint для OTLP Exporter.
    - **`logPrompts`** (boolean): Включать ли содержимое пользовательских запросов в логи.
  - **Пример:**
    ```json
    "telemetry": {
      "enabled": true,
      "target": "local",
      "otlpEndpoint": "http://localhost:16686",
      "logPrompts": false
    }
    ```

- **`usageStatisticsEnabled`** (boolean):
  - **Описание:** Включает или отключает сбор статистики использования. Подробнее см. в разделе [Статистика использования](#usage-statistics).
  - **По умолчанию:** `true`
  - **Пример:**
    ```json
    "usageStatisticsEnabled": false
    ```

- **`hideTips`** (boolean):
  - **Описание:** Включает или отключает полезные подсказки в интерфейсе CLI.
  - **По умолчанию:** `false`
  - **Пример:**
    ```json
    "hideTips": true
    ```

- **`hideBanner`** (boolean):
  - **Описание:** Включает или отключает стартовый баннер (ASCII-арт логотип) в интерфейсе CLI.
  - **По умолчанию:** `false`
  - **Пример:**
    ```json
    "hideBanner": true
    ```

- **`maxSessionTurns`** (число):
  - **Описание:** Устанавливает максимальное количество шагов (turns) в сессии. Если лимит превышен, CLI прекращает обработку и начинает новый чат.
  - **По умолчанию:** `-1` (без ограничений)
  - **Пример:**
    ```json
    "maxSessionTurns": 10
    ```

- **`summarizeToolOutput`** (объект):
  - **Описание:** Включает или отключает суммаризацию вывода инструментов. Можно указать бюджет токенов для сум

### Пример `settings.json`:

```json
{
  "theme": "GitHub",
  "sandbox": "docker",
  "toolDiscoveryCommand": "bin/get_tools",
  "toolCallCommand": "bin/call_tool",
  "tavilyApiKey": "$TAVILY_API_KEY",
  "mcpServers": {
    "mainServer": {
      "command": "bin/mcp_server.py"
    },
    "anotherServer": {
      "command": "node",
      "args": ["mcp_server.js", "--verbose"]
    }
  },
  "telemetry": {
    "enabled": true,
    "target": "local",
    "otlpEndpoint": "http://localhost:4317",
    "logPrompts": true
  },
  "usageStatisticsEnabled": true,
  "hideTips": false,
  "hideBanner": false,
  "skipNextSpeakerCheck": false,
  "skipLoopDetection": false,
  "maxSessionTurns": 10,
  "summarizeToolOutput": {
    "run_shell_command": {
      "tokenBudget": 100
    }
  },
  "excludedProjectEnvVars": ["DEBUG", "DEBUG_MODE", "NODE_ENV"],
  "includeDirectories": ["path/to/dir1", "~/path/to/dir2", "../path/to/dir3"],
  "loadMemoryFromIncludeDirectories": true
}
```

## История команд Shell

CLI сохраняет историю выполненных вами shell-команд. Чтобы избежать конфликтов между разными проектами, эта история хранится в директории, специфичной для проекта, внутри домашней папки пользователя.

- **Расположение:** `~/.qwen/tmp/<project_hash>/shell_history`
  - `<project_hash>` — это уникальный идентификатор, сгенерированный на основе корневого пути вашего проекта.
  - История команд хранится в файле с именем `shell_history`.

## Переменные окружения и файлы `.env`

Переменные окружения — это распространённый способ конфигурации приложений, особенно для чувствительных данных, таких как API ключи, или для настроек, которые могут отличаться в зависимости от среды выполнения. Подробнее о настройке аутентификации можно прочитать в [документации по аутентификации](./authentication.md), где описаны все доступные методы.

CLI автоматически загружает переменные окружения из файла `.env`. Порядок загрузки следующий:

1. Файл `.env` в текущей рабочей директории.
2. Если файл не найден, поиск продолжается в родительских директориях до тех пор, пока не будет найден файл `.env`, либо достигнут корень проекта (определяется наличием папки `.git`) или домашняя директория пользователя.
3. Если файл всё ещё не найден, CLI попытается загрузить `~/.env` (в домашней директории пользователя).

**Исключение переменных окружения:** Некоторые переменные (например, `DEBUG` и `DEBUG_MODE`) по умолчанию исключаются из проектных `.env` файлов, чтобы не мешать работе CLI. Переменные из файлов `.qwen/.env` никогда не исключаются. Вы можете изменить это поведение с помощью параметра `excludedProjectEnvVars` в вашем файле `settings.json`.

- **`OPENAI_API_KEY`**:
  - Один из доступных [методов аутентификации](./authentication.md).
  - Установите его в вашем shell профиле (например, `~/.bashrc`, `~/.zshrc`) или в файле `.env`.
- **`OPENAI_BASE_URL`**:
  - Один из доступных [методов аутентификации](./authentication.md).
  - Установите его в вашем shell профиле (например, `~/.bashrc`, `~/.zshrc`) или в файле `.env`.
- **`OPENAI_MODEL`**:
  - Задаёт модель OPENAI по умолчанию.
  - Переопределяет значение по умолчанию, заданное в коде.
  - Пример: `export OPENAI_MODEL="qwen3-coder-plus"`
- **`GEMINI_SANDBOX`**:
  - Альтернатива настройке `sandbox` в `settings.json`.
  - Принимает значения: `true`, `false`, `docker`, `podman` или произвольную команду в виде строки.
- **`SEATBELT_PROFILE`** (только для macOS):
  - Переключает профиль Seatbelt (`sandbox-exec`) в macOS.
  - `permissive-open`: (по умолчанию) Ограничивает запись только внутри папки проекта (и некоторых других, см. `packages/cli/src/utils/sandbox-macos-permissive-open.sb`), но разрешает другие операции.
  - `strict`: Использует строгий профиль, который по умолчанию запрещает большинство операций.
  - `<profile_name>`: Использует кастомный профиль. Чтобы определить свой профиль, создайте файл с именем `sandbox-macos-<profile_name>.sb` в директории `.qwen/` вашего проекта (например, `my-project/.qwen/sandbox-macos-custom.sb`).
- **`DEBUG` или `DEBUG_MODE`** (часто используются библиотеками или самим CLI):
  - Установите значение `true` или `1`, чтобы включить подробный режим логирования. Полезно при отладке.
  - **Примечание:** Эти переменные по умолчанию исключаются из проектных `.env` файлов, чтобы не влиять на работу CLI. Если вам нужно установить их специально для Qwen Code, используйте файлы `.qwen/.env`.
- **`NO_COLOR`**:
  - Установите любое значение, чтобы отключить цветной вывод в CLI.
- **`CLI_TITLE`**:
  - Установите строку, чтобы изменить заголовок CLI.
- **`CODE_ASSIST_ENDPOINT`**:
  - Указывает endpoint сервера code assist.
  - Полезно при разработке и тестировании.
- **`TAVILY_API_KEY`**:
  - Ваш API ключ для сервиса веб-поиска Tavily.
  - Используется для включения функциональности инструмента `web_search`.
  - **Примечание:** Для пользователей Qwen OAuth провайдер DashScope доступен автоматически без дополнительной настройки. Для других типов аутентификации необходимо настроить провайдеры Tavily или Google, чтобы включить веб-поиск.
  - Пример: `export TAVILY_API_KEY="tvly-your-api-key-here"`

## Аргументы командной строки

Аргументы, переданные напрямую при запуске CLI, могут переопределять другие настройки для текущей сессии.

- **`--model <model_name>`** (**`-m <model_name>`**):
  - Указывает модель Qwen, которая будет использоваться в этой сессии.
  - Пример: `npm start -- --model qwen3-coder-plus`
- **`--prompt <your_prompt>`** (**`-p <your_prompt>`**):
  - Используется для передачи промпта напрямую в команду. Это запускает Qwen Code в неинтерактивном режиме.
- **`--prompt-interactive <your_prompt>`** (**`-i <your_prompt>`**):
  - Запускает интерактивную сессию с указанным промптом в качестве начального ввода.
  - Промпт обрабатывается внутри интерактивной сессии, а не до её начала.
  - Не может использоваться при передаче входных данных через stdin.
  - Пример: `qwen -i "explain this code"`
- **`--sandbox`** (**`-s`**):
  - Включает режим песочницы для этой сессии.
- **`--sandbox-image`**:
  - Устанавливает URI образа песочницы.
- **`--debug`** (**`-d`**):
  - Включает режим отладки для этой сессии, обеспечивая более подробный вывод.
- **`--all-files`** (**`-a`**):
  - Если установлен, рекурсивно включает все файлы в текущей директории как контекст для промпта.
- **`--help`** (или **`-h`**):
  - Отображает справочную информацию по аргументам командной строки.
- **`--show-memory-usage`**:
  - Отображает текущее использование памяти.
- **`--yolo`**:
  - Включает режим YOLO, который автоматически одобряет все вызовы инструментов.
- **`--approval-mode <mode>`**:
  - Устанавливает режим подтверждения для вызовов инструментов. Поддерживаемые режимы:
    - `plan`: Только анализ — не изменяет файлы и не выполняет команды.
    - `default`: Требует подтверждения для редактирования файлов или выполнения команд (поведение по умолчанию).
    - `auto-edit`: Автоматически одобряет инструменты редактирования (edit, write_file), запрашивая подтверждение для остальных.
    - `yolo`: Автоматически одобряет все вызовы инструментов (эквивалент `--yolo`).
  - Нельзя использовать вместе с `--yolo`. Используйте `--approval-mode=yolo` вместо `--yolo` для нового унифицированного подхода.
  - Пример: `qwen --approval-mode auto-edit`
- **`--allowed-tools <tool1,tool2,...>`**:
  - Список названий инструментов, разделённых запятыми, которые будут обходить диалог подтверждения.
  - Пример: `qwen --allowed-tools "ShellTool(git status)"`
- **`--telemetry`**:
  - Включает [телеметрию](../telemetry.md).
- **`--telemetry-target`**:
  - Устанавливает цель телеметрии. Подробнее см. в разделе [телеметрия](../telemetry.md).
- **`--telemetry-otlp-endpoint`**:
  - Устанавливает OTLP-эндпоинт для телеметрии. Подробнее см. в разделе [телеметрия](../telemetry.md).
- **`--telemetry-otlp-protocol`**:
  - Устанавливает OTLP-протокол для телеметрии (`grpc` или `http`). По умолчанию используется `grpc`. Подробнее см. в разделе [телеметрия](../telemetry.md).
- **`--telemetry-log-prompts`**:
  - Включает логирование промптов для телеметрии. Подробнее см. в разделе [телеметрия](../telemetry.md).
- **`--checkpointing`**:
  - Включает [чекпоинтинг](../checkpointing.md).
- **`--extensions <extension_name ...>`** (**`-e <extension_name ...>`**):
  - Указывает список расширений, используемых в сессии. Если не указано, используются все доступные расширения.
  - Используйте специальное значение `qwen -e none`, чтобы отключить все расширения.
  - Пример: `qwen -e my-extension -e my-other-extension`
- **`--list-extensions`** (**`-l`**):
  - Выводит список всех доступных расширений и завершает работу.
- **`--proxy`**:
  - Устанавливает прокси для CLI.
  - Пример: `--proxy http://localhost:7890`.
- **`--include-directories <dir1,dir2,...>`**:
  - Добавляет дополнительные директории в рабочее пространство для поддержки работы с несколькими директориями.
  - Можно указать несколько раз или в виде значений, разделённых запятыми.
  - Максимум можно добавить 5 директорий.
  - Пример: `--include-directories /path/to/project1,/path/to/project2` или `--include-directories /path/to/project1 --include-directories /path/to/project2`
- **`--screen-reader`**:
  - Включает режим чтения с экрана для обеспечения доступности.
- **`--version`**:
  - Отображает версию CLI.
- **`--openai-logging`**:
  - Включает логирование вызовов OpenAI API для отладки и анализа. Этот флаг переопределяет настройку `enableOpenAILogging` в `settings.json`.
- **`--openai-logging-dir <directory>`**:
  - Устанавливает пользовательский путь к директории для логов OpenAI API. Этот флаг переопределяет настройку `openAILoggingDir` в `settings.json`. Поддерживаются абсолютные пути, относительные пути и раскрытие `~`.
  - **Пример:** `qwen --openai-logging-dir "~/qwen-logs" --openai-logging`
- **`--tavily-api-key <api_key>`**:
  - Устанавливает API-ключ Tavily для функции веб-поиска в этой сессии.
  - Пример: `qwen --tavily-api-key tvly-your-api-key-here`

## Файлы контекста (иерархический инструкционный контекст)

Хотя файлы контекста не являются строгой конфигурацией _поведения_ CLI, они играют ключевую роль в настройке _инструкционного контекста_ (также называемого «памятью»). По умолчанию используется файл `QWEN.md`, но имя файла можно изменить с помощью параметра `contextFileName`. Эта мощная функция позволяет передавать ИИ проектные инструкции, руководства по стилю кода или любую другую важную информацию, благодаря чему ответы модели становятся более точными и соответствующими вашим ожиданиям. В CLI предусмотрены элементы интерфейса, например индикатор в нижнем колонтитуле, показывающий количество загруженных файлов контекста, чтобы вы всегда могли видеть текущий активный контекст.

- **Назначение:** Эти Markdown-файлы содержат инструкции, рекомендации или любой другой контекст, который вы хотите, чтобы модель Qwen учитывала во время взаимодействия. Система спроектирована так, чтобы управлять этим инструкционным контекстом иерархически.

### Пример содержимого контекстного файла (например, `QWEN.md`)

Вот концептуальный пример того, что может содержаться в контекстном файле в корне проекта на TypeScript:

```markdown

# Project: My Awesome TypeScript Library

## Общие инструкции:

- При генерации нового кода на TypeScript следуйте существующему стилю кодирования.
- Убедитесь, что все новые функции и классы сопровождаются комментариями JSDoc.
- По возможности отдавайте предпочтение парадигмам функционального программирования.
- Весь код должен быть совместим с TypeScript 5.0 и Node.js 20+.

## Стиль кодирования:

- Используйте 2 пробела для отступов.
- Названия интерфейсов должны начинаться с префикса `I` (например, `IUserService`).
- Приватные члены класса должны начинаться с символа подчеркивания (`_`).
- Всегда используйте строгое равенство (`===` и `!==`).

## Конкретный компонент: `src/api/client.ts`

- Этот файл обрабатывает все исходящие API-запросы.
- При добавлении новых функций вызова API убедитесь, что они включают надежную обработку ошибок и логирование.
- Используйте существующую утилиту `fetchWithRetry` для всех GET-запросов.

## О зависимостях:

- Избегайте добавления новых внешних зависимостей, если в этом нет абсолютной необходимости.
- Если новая зависимость необходима, пожалуйста, укажите причину.
```

Этот пример демонстрирует, как можно предоставить общий контекст проекта, конкретные соглашения о кодировании и даже заметки о конкретных файлах или компонентах. Чем более релевантными и точными будут ваши файлы контекста, тем лучше ИИ сможет вам помочь. Файлы контекста, специфичные для проекта, настоятельно рекомендуются для установления соглашений и контекста.

- **Иерархическая загрузка и приоритет:** CLI реализует сложную иерархическую систему памяти, загружая файлы контекста (например, `QWEN.md`) из нескольких мест. Содержимое файлов, расположенных ниже в этом списке (более специфичные), обычно переопределяет или дополняет содержимое файлов выше (более общие). Точный порядок объединения и финальный контекст можно проверить с помощью команды `/memory show`. Типичный порядок загрузки следующий:
  1.  **Глобальный файл контекста:**
      - Расположение: `~/.qwen/<contextFileName>` (например, `~/.qwen/QWEN.md` в вашей домашней директории пользователя).
      - Область применения: Предоставляет стандартные инструкции для всех ваших проектов.
  2.  **Файлы контекста корня проекта и его предков:**
      - Расположение: CLI ищет настроенный файл контекста в текущей рабочей директории, а затем в каждой родительской директории до корня проекта (определяется по наличию папки `.git`) или вашей домашней директории.
      - Область применения: Предоставляет контекст, относящийся ко всему проекту или значительной его части.
  3.  **Файлы контекста подкаталогов (контекстуальные/локальные):**
      - Расположение: CLI также сканирует наличие настроенного файла контекста в подкаталогах _ниже_ текущей рабочей директории (с учетом распространенных шаблонов игнорирования, таких как `node_modules`, `.git` и т.д.). По умолчанию глубина этого поиска ограничена 200 каталогами, но может быть изменена с помощью поля `memoryDiscoveryMaxDirs` в вашем файле `settings.json`.
      - Область применения: Позволяет задать очень специфичные инструкции, относящиеся к определенному компоненту, модулю или разделу вашего проекта.
- **Объединение и отображение в интерфейсе:** Содержимое всех найденных файлов контекста объединяется (с разделителями, указывающими их источник и путь) и передается как часть системного промпта. В нижнем колонтитуле CLI отображается количество загруженных файлов контекста, что дает вам быстрый визуальный сигнал об активном инструкционном контексте.
- **Импорт содержимого:** Вы можете модульно организовать свои файлы контекста, импортируя другие Markdown-файлы с помощью синтаксиса `@path/to/file.md`. Подробнее см. в [документации Memory Import Processor](../core/memport.md).
- **Команды управления памятью:**
  - Используйте `/memory refresh`, чтобы принудительно пересканировать и перезагрузить все файлы контекста из всех настроенных местоположений. Это обновит инструкционный контекст ИИ.
  - Используйте `/memory show`, чтобы отобразить текущий объединенный инструкционный контекст, позволяя вам проверить иерархию и содержание, используемое ИИ.
  - Полная информация о команде `/memory` и её подкомандах (`show` и `refresh`) доступна в [документации по командам](./commands.md#memory).

Понимая и используя эти уровни конфигурации и иерархическую природу файлов контекста, вы сможете эффективно управлять памятью ИИ и адаптировать ответы Qwen Code под ваши конкретные нужды и проекты.

## Sandboxing

Qwen Code может выполнять потенциально небезопасные операции (например, shell-команды и изменения файлов) в sandbox-окружении для защиты вашей системы.

По умолчанию sandboxing отключен, но вы можете включить его несколькими способами:

- Используя флаг `--sandbox` или `-s`.
- Установив переменную окружения `GEMFI_SANDBOX`.
- Sandbox включается по умолчанию при использовании `--yolo` или `--approval-mode=yolo`.

По умолчанию используется предварительно собранный Docker-образ `qwen-code-sandbox`.

Если вам нужно настроить sandbox под конкретный проект, вы можете создать собственный Dockerfile по пути `.qwen/sandbox.Dockerfile` в корневой директории вашего проекта. Этот Dockerfile может быть основан на базовом sandbox-образе:

```dockerfile
FROM qwen-code-sandbox

# Добавьте сюда свои зависимости или конфигурации

# Например:

# RUN apt-get update && apt-get install -y some-package
```

# COPY ./my-config /app/my-config
```

Когда файл `.qwen/sandbox.Dockerfile` существует, вы можете использовать переменную окружения `BUILD_SANDBOX` при запуске Qwen Code для автоматической сборки кастомного sandbox-образа:

```bash
BUILD_SANDBOX=1 qwen -s
```

## Статистика использования

Чтобы помочь нам улучшить Qwen Code, мы собираем анонимизированную статистику использования. Эти данные помогают нам понять, как используется CLI, выявить распространенные проблемы и определить приоритеты для новых функций.

**Что мы собираем:**

- **Вызовы инструментов:** Мы записываем названия вызванных инструментов, информацию об успешности выполнения и времени их работы. Мы не собираем аргументы, передаваемые инструментам, или любые данные, возвращаемые ими.
- **API запросы:** Мы записываем используемую модель для каждого запроса, продолжительность запроса и его успешность. Мы не собираем содержимое промптов или ответов.
- **Информация о сессии:** Мы собираем информацию о конфигурации CLI, например, какие инструменты включены и какой режим подтверждения используется.

**Что мы НЕ собираем:**

- **Персональные данные (PII):** Мы не собираем никакой персональной информации, такой как ваше имя, адрес электронной почты или API ключи.
- **Содержание промптов и ответов:** Мы не записываем содержание ваших промптов или ответов модели.
- **Содержимое файлов:** Мы не записываем содержимое файлов, которые читаются или записываются через CLI.

**Как отключить сбор статистики:**

Вы можете отказаться от сбора статистики использования в любое время, установив значение свойства `usageStatisticsEnabled` в `false` в вашем файле `settings.json`:

```json
{
  "usageStatisticsEnabled": false
}
```

Примечание: Когда статистика использования включена, события отправляются на точку сбора данных Alibaba Cloud RUM.

- **`enableWelcomeBack`** (boolean):
  - **Описание:** Показывать диалог приветствия при возвращении к проекту с историей разговора.
  - **По умолчанию:** `true`
  - **Категория:** UI
  - **Требуется перезапуск:** Нет
  - **Пример:** `"enableWelcomeBack": false`
  - **Подробности:** Если эта опция включена, Qwen Code автоматически определяет, что вы возвращаетесь к проекту с ранее созданным сводным файлом проекта (`/.qwen/PROJECT_SUMMARY.md`), и показывает диалоговое окно, позволяющее продолжить предыдущий разговор или начать заново. Эта функция интегрирована с командой `/chat summary` и диалогом подтверждения выхода. Подробнее см. в [документации Welcome Back](./welcome-back.md).