# Команды CLI

Qwen Code поддерживает несколько встроенных команд, которые помогут вам управлять сессией, настраивать интерфейс и контролировать его поведение. Эти команды начинаются с косой черты (`/`), символа @ (`@`) или восклицательного знака (`!`).

## Слэш-команды (`/`)

Слэш-команды предоставляют метауровневый контроль над самим CLI.

### Встроенные команды

- **`/bug`**
  - **Описание:** Создать issue о Qwen Code. По умолчанию issue создается в репозитории GitHub проекта Qwen Code. Строка, которую вы вводите после `/bug`, станет заголовком для создаваемого баг-репорта. Поведение по умолчанию можно изменить с помощью настройки `advanced.bugCommand` в файле `.qwen/settings.json`.

- **`/chat`**
  - **Описание:** Сохранять и возобновлять историю разговора для интерактивного управления состоянием диалога или восстановления предыдущего состояния из более поздней сессии.
  - **Подкоманды:**
    - **`save`**
      - **Описание:** Сохраняет текущую историю разговора. Необходимо добавить `<tag>`, чтобы идентифицировать состояние диалога.
      - **Использование:** `/chat save <tag>`
      - **Детали о местоположении чекпоинтов:** Местоположения по умолчанию для сохраненных чекпоинтов:
        - Linux/macOS: `~/.qwen/tmp/<project_hash>/`
        - Windows: `C:\Users\<YourUsername>\.qwen\tmp\<project_hash>\`
        - При выполнении `/chat list` CLI сканирует только эти конкретные директории для поиска доступных чекпоинтов.
        - **Примечание:** Эти чекпоинты предназначены для ручного сохранения и восстановления состояний диалога. Для автоматических чекпоинтов перед изменениями файлов см. [документацию по Checkpointing](../checkpointing.md).
    - **`resume`**
      - **Описание:** Возобновляет диалог из предыдущего сохранения.
      - **Использование:** `/chat resume <tag>`
    - **`list`**
      - **Описание:** Отображает список доступных тегов для восстановления состояния чата.
    - **`delete`**
      - **Описание:** Удаляет сохраненный чекпоинт диалога.
      - **Использование:** `/chat delete <tag>`
    - **`share`**
      - **Описание:** Записывает текущий диалог в указанный Markdown или JSON файл.
      - **Использование:** `/chat share file.md` или `/chat share file.json`. Если имя файла не указано, CLI сгенерирует его автоматически.

- **`/clear`**
  - **Описание:** Очистить экран терминала, включая видимую историю сессии и прокрутку внутри CLI. Базовые данные сессии (для воспроизведения истории) могут быть сохранены в зависимости от реализации, но визуальное отображение очищается.
  - **Горячая клавиша:** Нажмите **Ctrl+L** в любое время для выполнения операции очистки.

- **`/summary`**
  - **Описание:** Генерировать полный обзор проекта на основе текущей истории разговора и сохранять его в `.qwen/PROJECT_SUMMARY.md`. Этот обзор включает общую цель, ключевые знания, последние действия и текущий план, что идеально подходит для продолжения работы в будущих сессиях.
  - **Использование:** `/summary`
  - **Функции:**
    - Анализ всей истории разговора для извлечения важного контекста
    - Создание структурированного markdown-обзора с разделами целей, знаний, действий и планов
    - Автоматическое сохранение в `.qwen/PROJECT_SUMMARY.md` в корне проекта
    - Отображение индикаторов прогресса во время генерации и сохранения
    - Интеграция с функцией Welcome Back для бесшовного возобновления сессии
  - **Примечание:** Эта команда требует активного диалога как минимум с двумя сообщениями для создания осмысленного обзора.

- **`/compress`**
  - **Описание:** Заменить весь контекст чата кратким обзором. Это позволяет экономить токены при выполнении будущих задач, сохраняя высокоуровневый обзор произошедшего.

- **`/copy`**
  - **Описание:** Копирует последний вывод, созданный Qwen Code, в ваш буфер обмена для удобного использования или повторного применения.

- **`/directory`** (или **`/dir`**)
  - **Описание:** Управление рабочими каталогами для поддержки нескольких директорий.
  - **Подкоманды:**
    - **`add`**:
      - **Описание:** Добавить директорию в рабочее пространство. Путь может быть абсолютным или относительным к текущей рабочей директории. Также поддерживается ссылка относительно домашней директории.
      - **Использование:** `/directory add <path1>,<path2>`
      - **Примечание:** Отключено в ограниченных профилях песочницы. Если вы используете такой профиль, используйте `--include-directories` при запуске сессии.
    - **`show`**:
      - **Описание:** Отобразить все директории, добавленные через `/directory add` и `--include-directories`.
      - **Использование:** `/directory show`

- **`/editor`**
  - **Описание:** Открыть диалог выбора поддерживаемых редакторов.

- **`/extensions`**
  - **Описание:** Отображает список всех активных расширений в текущей сессии Qwen Code. См. [Расширения Qwen Code](../extension.md).

- **`/help`** (или **`/?`**)
  - **Описание:** Отображает справочную информацию о Qwen Code, включая доступные команды и их использование.

- **`/mcp`**
  - **Описание:** Отображает список настроенных серверов Model Context Protocol (MCP), их статус соединения, детали серверов и доступные инструменты.
  - **Подкоманды:**
    - **`desc`** или **`descriptions`**:
      - **Описание:** Показать подробные описания серверов и инструментов MCP.
    - **`nodesc`** или **`nodescriptions`**:
      - **Описание:** Скрыть описания инструментов, показывая только их названия.
    - **`schema`**:
      - **Описание:** Показать полную JSON-схему параметров инструмента.
  - **Горячая клавиша:** Нажмите **Ctrl+T** в любое время для переключения между отображением и скрытием описаний инструментов.

- **`/memory`**
  - **Описание:** Управление инструкционным контекстом ИИ (иерархическая память, загружаемая по умолчанию из файлов `QWEN.md`; настраивается через `contextFileName`).
  - **Подкоманды:**
    - **`add`**:
      - **Описание:** Добавляет следующий текст в память ИИ. Использование: `/memory add <текст для запоминания>`
    - **`show`**:
      - **Описание:** Отображает полное содержимое текущей иерархической памяти, загруженной из всех контекстных файлов (например, `QWEN.md`). Это позволяет проверить инструкционный контекст, предоставляемый модели.
    - **`refresh`**:
      - **Описание:** Перезагрузить иерархическую инструкционную память из всех контекстных файлов (по умолчанию: `QWEN.md`), найденных в настроенных местах (глобальные, проект/предки и подкаталоги). Обновляет модель с последним контекстом.
    - **Примечание:** За дополнительной информацией о том, как контекстные файлы формируют иерархическую память, см. [документацию по конфигурации CLI](./configuration.md#context-files-hierarchical-instructional-context).

- **`/model`**
  - **Описание:** Переключить модель для текущей сессии. Открывает диалог выбора из доступных моделей на основе вашего типа аутентификации.
  - **Использование:** `/model`
  - **Функции:**
    - Отображает диалог со всеми доступными моделями для текущего типа аутентификации
    - Показывает описания и возможности моделей (например, поддержку vision)
    - Изменяет модель только для текущей сессии
    - Поддерживает модели Qwen (через OAuth) и модели OpenAI (через API-ключ)
  - **Доступные модели:**
    - **Qwen Coder:** Последняя модель Qwen Coder от Alibaba Cloud ModelStudio (версия: qwen3-coder-plus-2025-09-23)
    - **Qwen Vision:** Последняя модель Qwen Vision от Alibaba Cloud ModelStudio (версия: qwen3-vl-plus-2025-09-23) — поддерживает анализ изображений
    - **Модели OpenAI:** Доступны при использовании аутентификации OpenAI (настраиваются через переменную окружения `OPENAI_MODEL`)
  - **Примечание:** Выбор модели применяется только к текущей сессии и не сохраняется между различными сессиями Qwen Code. Чтобы установить модель по умолчанию, используйте настройку `model.name` в конфигурации.

- **`/restore`**
  - **Описание:** Восстанавливает файлы проекта до состояния, которое было непосредственно перед выполнением инструмента. Особенно полезно для отмены правок файлов, сделанных инструментом. Если запущено без ID вызова инструмента, отображает список доступных чекпоинтов для восстановления.
  - **Использование:** `/restore [tool_call_id]`
  - **Примечание:** Доступно только если CLI запущен с опцией `--checkpointing` или настроен через [настройки](./configuration.md). См. [документацию по Checkpointing](../checkpointing.md) для подробностей.

- **`/settings`**
  - **Описание:** Открыть редактор настроек для просмотра и изменения параметров Qwen Code.
  - **Детали:** Эта команда предоставляет удобный интерфейс для изменения настроек, контролирующих поведение и внешний вид Qwen Code. Эквивалентно ручному редактированию файла `.qwen/settings.json`, но с валидацией и подсказками для предотвращения ошибок.
  - **Использование:** Просто выполните `/settings`, и откроется редактор. Вы можете просматривать или искать конкретные настройки, видеть их текущие значения и изменять их по желанию. Некоторые изменения применяются сразу, другие требуют перезапуска.

- **`/stats`**
  - **Описание:** Отображает подробную статистику текущей сессии Qwen Code, включая использование токенов, экономию за счет кэширования (если доступно) и продолжительность сессии. Примечание: информация о кэшированных токенах отображается только при их использовании, что происходит при аутентификации через API-ключ, но не через OAuth.

- [**`/theme`**](./themes.md)
  - **Описание:** Открыть диалог для изменения визуальной темы Qwen Code.

- **`/auth`**
  - **Описание:** Открыть диалог для изменения метода аутентификации.

- **`/approval-mode`**
  - **Описание:** Изменить режим одобрения использования инструментов.
  - **Использование:** `/approval-mode [mode] [--session|--project|--user]`
  - **Доступные режимы:**
    - **`plan`**: Только анализ; не изменяет файлы и не выполняет команды
    - **`default`**: Требовать одобрение для правок файлов или shell-команд
    - **`auto-edit`**: Автоматически одобрять правки файлов
    - **`yolo`**: Автоматически одобрять все инструменты
  - **Примеры:**
    - `/approval-mode plan --project` (сохранить режим plan для этого проекта)
    - `/approval-mode yolo --user` (сохранить режим YOLO для этого пользователя во всех проектах)

- **`/about`**
  - **Описание:** Показать информацию о версии. Пожалуйста, делитесь этой информацией при создании issue.

- **`/agents`**
  - **Описание:** Управление специализированными AI-агентами для выполнения конкретных задач. Агенты — это независимые ИИ-ассистенты с заданной экспертизой и доступом к инструментам.
  - **Подкоманды:**
    - **`create`**:
      - **Описание:** Запустить интерактивный мастер создания нового агента. Мастер поможет выбрать расположение, сгенерировать промпт с помощью ИИ, выбрать инструменты и настроить внешний вид.
      - **Использование:** `/agents create`
    - **`manage`**:
      - **Описание:** Открыть интерактивный диалог управления для просмотра, редактирования и удаления существующих агентов. Показывает агентов уровня проекта и уровня пользователя.
      - **Использование:** `/agents manage`
  - **Места хранения:**
    - **Уровень проекта:** `.qwen/agents/` (общие с командой, имеют приоритет)
    - **Уровень пользователя:** `~/.qwen/agents/` (личные агенты, доступны во всех проектах)
  - **Примечание:** За подробной информацией о создании и управлении агентами см. [документацию по Subagents](../subagents.md).

- [**`/tools`**](../tools/index.md)
  - **Описание:** Отображает список инструментов, доступных в текущей сессии Qwen Code.
  - **Использование:** `/tools [desc]`
  - **Подкоманды:**
    - **`desc`** или **`descriptions`**:
      - **Описание:** Показать подробные описания каждого инструмента, включая название и полное описание, предоставленное модели.
    - **`nodesc`** или **`nodescriptions`**:
      - **Описание:** Скрыть описания инструментов, показывая только их названия.

- **`/quit-confirm`**
  - **Описание:** Показать диалог подтверждения перед выходом из Qwen Code, позволяющий выбрать способ завершения текущей сессии.
  - **Использование:** `/quit-confirm`
  - **Функции:**
    - **Выйти немедленно:** Завершить работу без сохранения (эквивалентно `/quit`)
    - **Создать обзор и выйти:** Создать обзор проекта с помощью `/summary` перед выходом
    - **Сохранить диалог и выйти:** Сохранить текущий диалог с автоматически сгенерированным тегом перед выходом
  - **Горячая клавиша:** Нажмите **Ctrl+C** дважды для вызова диалога подтверждения выхода
  - **Примечание:** Эта команда автоматически вызывается при однократном нажатии Ctrl+C, обеспечивая защиту от случайного выхода.

- **`/quit`** (или **`/exit`**)
  - **Описание:** Немедленно выйти из Qwen Code без диалога подтверждения.

- **`/vim`**
  - **Описание:** Включить или отключить режим vim. Когда режим vim активен, область ввода поддерживает навигацию и команды редактирования в стиле vim в режимах NORMAL и INSERT.
  - **Функции:**
    - **Режим NORMAL:** Навигация с помощью `

### Пользовательские команды

Для быстрого начала работы ознакомьтесь с [примером](#example-a-pure-function-refactoring-command) ниже.

Пользовательские команды позволяют сохранять и повторно использовать ваши любимые или наиболее часто используемые prompts в виде персональных шорткатов внутри Qwen Code. Вы можете создавать команды, специфичные для одного проекта, или глобальные команды, доступные во всех ваших проектах, что упрощает рабочий процесс и обеспечивает согласованность.

#### Расположение файлов и приоритет

Qwen Code обнаруживает команды из двух мест, загружая их в определённом порядке:

1.  **Пользовательские команды (глобальные):** Расположены в `~/.qwen/commands/`. Эти команды доступны во всех проектах, над которыми вы работаете.
2.  **Команды проекта (локальные):** Расположены в `<корневая-директория-проекта>/.qwen/commands/`. Эти команды специфичны для текущего проекта и могут быть добавлены в систему контроля версий, чтобы быть доступными для вашей команды.

Если команда в директории проекта имеет то же имя, что и команда в пользовательской директории, **всегда будет использоваться команда проекта.** Это позволяет проектам переопределять глобальные команды своими локальными версиями.

#### Именование и пространства имён

Имя команды определяется путём к файлу относительно директории `commands`. Поддиректории используются для создания команд с пространствами имён, при этом разделитель пути (`/` или `\`) преобразуется в двоеточие (`:`).

- Файл по пути `~/.qwen/commands/test.toml` становится командой `/test`.
- Файл по пути `<project>/.qwen/commands/git/commit.toml` становится командой с пространством имён `/git:commit`.

#### Формат файла TOML (v1)

Файлы определения команд должны быть написаны в формате TOML и иметь расширение `.toml`.

##### Обязательные поля

- `prompt` (String): Prompt, который будет отправлен модели при выполнении команды. Может быть однострочной или многострочной строкой.

##### Необязательные поля

- `description` (String): Краткое однострочное описание того, что делает команда. Этот текст будет отображаться рядом с вашей командой в меню `/help`. **Если вы не укажете это поле, автоматически будет сгенерировано описание на основе имени файла.**

#### Работа с аргументами

Пользовательские команды поддерживают два мощных метода обработки аргументов. CLI автоматически выбирает правильный метод на основе содержимого `prompt` вашей команды.

##### 1. Контекстно-зависимая инъекция с `{{args}}`

Если ваш `prompt` содержит специальный плейсхолдер `{{args}}`, CLI заменит этот плейсхолдер на текст, который пользователь ввел после имени команды.

Поведение этой инъекции зависит от места использования:

**A. Прямая инъекция (вне shell-команд)**

Когда используется в основном теле prompt, аргументы инжектятся точно так, как их ввел пользователь.

**Пример (`git/fix.toml`):**

```toml

```markdown
# Вызывается через: /git:fix "Кнопка смещена"

description = "Генерирует исправление для указанной проблемы."
prompt = "Пожалуйста, предоставьте кодовое исправление для описанной здесь проблемы: {{args}}."
```

Модель получает: `Пожалуйста, предоставьте кодовое исправление для описанной здесь проблемы: "Кнопка смещена".`

**B. Использование аргументов в Shell-командах (внутри блоков `!{...}`)**

Когда вы используете `{{args}}` внутри блока инъекции shell (`!{...}`), аргументы автоматически **экранируются для shell** перед подстановкой. Это позволяет безопасно передавать аргументы в shell-команды, гарантируя корректный синтаксис и безопасность результирующей команды, предотвращая уязвимости инъекций команд.

**Пример (`/grep-code.toml`):**

```toml
prompt = """
Пожалуйста, суммируйте результаты поиска по шаблону `{{args}}`.

Результаты поиска:
!{grep -r {{args}} .}
"""
```

Когда вы запускаете `/grep-code It's complicated`:

1. CLI видит, что `{{args}}` используется как вне, так и внутри `!{...}`.
2. Вне: Первый `{{args}}` заменяется как есть на `It's complicated`.
3. Внутри: Второй `{{args}}` заменяется на экранированную версию (например, в Linux: `"It's complicated"`).
4. Выполняемая команда: `grep -r "It's complicated" .`.
5. CLI предлагает вам подтвердить именно эту безопасную команду перед выполнением.
6. Финальный prompt отправляется.
```

##### 2. Обработка аргументов по умолчанию

Если ваш `prompt` **не** содержит специальный placeholder `{{args}}`, CLI использует поведение по умолчанию для обработки аргументов.

Если вы передаёте аргументы команде (например, `/mycommand arg1`), CLI добавит полную команду, которую вы ввели, в конец prompt через два символа новой строки. Это позволяет модели видеть как оригинальные инструкции, так и конкретные аргументы, которые вы только что передали.

Если вы **не** передаёте никаких аргументов (например, `/mycommand`), prompt отправляется модели в точности как есть, без каких-либо дополнений.

**Пример (`changelog.toml`):**

Этот пример показывает, как создать надежную команду, определив роль для модели, объяснив, где искать пользовательский ввод, и указав ожидаемый формат и поведение.

```toml

# In: <project>/.qwen/commands/changelog.toml

```markdown
# Вызывается через: /changelog 1.2.0 added "Support for default argument parsing."

description = "Добавляет новую запись в файл CHANGELOG.md проекта."
prompt = """

# Задача: Обновление Changelog

Вы являетесь экспертом по поддержке этого программного проекта. Пользователь вызвал команду для добавления новой записи в changelog.

**Сырая команда пользователя приведена ниже ваших инструкций.**

Ваша задача — распарсить `<version>`, `<change_type>` и `<message>` из их ввода и использовать инструмент `write_file`, чтобы правильно обновить файл `CHANGELOG.md`.

## Ожидаемый формат
Команда имеет следующий формат: `/changelog <version> <type> <message>`
- `<type>` должен быть одним из: "added", "changed", "fixed", "removed".
```

## Поведение
1. Прочитать файл `CHANGELOG.md`.
2. Найти секцию для указанной `<version>`.
3. Добавить `<message>` под правильным заголовком `<type>`.
4. Если версия или секция типа не существует, создать её.
5. Строго придерживаться формата "Keep a Changelog".
"""
```

Когда вы запускаете `/changelog 1.2.0 added "New feature"`, финальный текст, отправляемый модели, будет оригинальным промптом, за которым следуют два символа новой строки и введённая вами команда.

##### 3. Выполнение Shell-команд с помощью `!{...}`

Вы можете сделать свои команды динамичными, выполняя shell-команды прямо внутри вашего `prompt` и подставляя их вывод. Это идеально подходит для сбора контекста из локального окружения, например, чтения содержимого файлов или проверки статуса Git.

Когда кастомная команда пытается выполнить shell-команду, Qwen Code теперь будет запрашивать у вас подтверждение перед выполнением. Это мера безопасности, чтобы гарантировать, что выполняются только намеренные команды.

**Как это работает:**

1.  **Подстановка команд:** Используйте синтаксис `!{...}`.
2.  **Подстановка аргументов:** Если внутри блока присутствует `{{args}}`, он автоматически экранируется в shell (см. [Context-Aware Injection](#1-context-aware-injection-with-args) выше).
3.  **Надежный парсинг:** Парсер корректно обрабатывает сложные shell-команды, включая вложенные фигурные скобки, такие как JSON-полезные нагрузки. **Примечание:** Содержимое внутри `!{...}` должно иметь сбалансированные фигурные скобки (`{` и `}`). Если вам нужно выполнить команду с несбалансированными скобками, рассмотрите возможность обернуть её во внешний скрипт и вызвать этот скрипт внутри блока `!{...}`.
4.  **Проверка безопасности и подтверждение:** CLI выполняет проверку безопасности финальной команды (после экранирования и подстановки аргументов). Появится диалоговое окно с точным списком команд, которые будут выполнены.
5.  **Выполнение и отчет об ошибках:** Команда выполняется. Если команда завершается с ошибкой, в prompt будет внедрен вывод, содержащий сообщения об ошибках (stderr), за которыми следует строка статуса, например, `[Shell command exited with code 1]`. Это помогает модели понять контекст ошибки.

**Пример (`git/commit.toml`):**

Эта команда получает staged diff из Git и использует его, чтобы попросить модель написать сообщение коммита.

````toml

```markdown
# In: <project>/.qwen/commands/git/commit.toml

# Invoked via: /git:commit

description = "Генерирует сообщение для Git commit на основе изменений, добавленных в staging area."

# В prompt используется !{...} для выполнения команды и подстановки её вывода.
prompt = """
Пожалуйста, сгенерируй сообщение в формате Conventional Commit на основе следующего git diff:

```diff
!{git diff --staged}
```

"""

```

Когда вы запускаете `/git:commit`, CLI сначала выполняет команду `git diff --staged`, затем заменяет `!{git diff --staged}` на результат выполнения этой команды, после чего отправляет окончательный prompt модели.
```

##### 4. Вставка содержимого файлов с помощью `@{...}`

Вы можете напрямую вставлять содержимое файла или список файлов в директории в ваш prompt, используя синтаксис `@{...}`. Это удобно для создания команд, работающих с конкретными файлами.

**Как это работает:**

- **Вставка файла**: `@{path/to/file.txt}` заменяется на содержимое `file.txt`.
- **Мультимодальная поддержка**: Если путь указывает на поддерживаемый формат изображения (например, PNG, JPEG), PDF, аудио или видео, файл будет корректно закодирован и вставлен как мультимодальный input. Другие бинарные файлы обрабатываются корректно и пропускаются.
- **Список файлов в директории**: `@{path/to/dir}` обрабатывается рекурсивно — все файлы в директории и её поддиректориях добавляются в prompt. При этом учитываются `.gitignore` и `.qwenignore`, если они включены.
- **Работа с рабочими директориями**: Поиск пути осуществляется в текущей директории и других директориях workspace. Абсолютные пути разрешены, если они находятся внутри workspace.
- **Порядок обработки**: Вставка содержимого файлов через `@{...}` происходит _до_ выполнения shell-команд (`!{...}`) и подстановки аргументов (`{{args}}`).
- **Парсинг**: Парсер требует, чтобы содержимое внутри `@{...}` (путь) имело сбалансированные фигурные скобки (`{` и `}`).

**Пример (`review.toml`):**

Эта команда вставляет содержимое _фиксированного_ файла с лучшими практиками (`docs/best-practices.md`) и использует аргументы пользователя для контекста ревью.

```toml

```toml
# In: <project>/.qwen/commands/review.toml

# Invoked via: /review FileCommandLoader.ts

description = "Проверяет предоставленный контекст с использованием руководства по лучшим практикам."
prompt = """
Вы — эксперт по код-ревью.

Ваша задача — провести ревью {{args}}.

Используйте следующие лучшие практики при составлении вашего обзора:

@{docs/best-practices.md}
```

Когда вы запускаете `/review FileCommandLoader.ts`, placeholder `@{docs/best-practices.md}` заменяется содержимым этого файла, а `{{args}}` заменяется текстом, который вы предоставили, перед тем как финальный prompt будет отправлен в модель.
```

#### Пример: Команда рефакторинга "Чистая функция"

Давайте создадим глобальную команду, которая будет запрашивать у модели рефакторинг фрагмента кода.

**1. Создайте файл и директории:**

Сначала убедитесь, что директория пользовательских команд существует, затем создайте поддиректорию `refactor` для организации и конечный TOML-файл.

```bash
mkdir -p ~/.qwen/commands/refactor
touch ~/.qwen/commands/refactor/pure.toml
```

**2. Добавьте содержимое в файл:**

Откройте `~/.qwen/commands/refactor/pure.toml` в вашем редакторе и добавьте следующее содержимое. Мы также включаем необязательное поле `description` для лучшей практики.

```toml

# In: ~/.qwen/commands/refactor/pure.toml

```markdown
# Эта команда будет вызываться через: /refactor:pure

description = "Просит модель рефакторить текущий контекст в чистую функцию (pure function)."

prompt = """
Пожалуйста, проанализируй код, который я предоставил в текущем контексте.
Рефактори его в чистую функцию (pure function).

Твой ответ должен включать:
1. Блок кода с рефакторинговой, чистой функцией.
2. Краткое объяснение ключевых изменений, которые ты сделал, и почему они способствуют чистоте функции.
"""
```

**3. Запусти команду:**

Вот и всё! Теперь ты можешь запустить свою команду в CLI. Сначала добавь файл в контекст, а затем вызови команду:

```
> @my-messy-function.js
> /refactor:pure
```

Qwen Code выполнит многострочный prompt, определённый в твоём TOML-файле.
```

## Шорткаты для работы с текстом

Эти шорткаты применяются непосредственно к полю ввода для манипуляций с текстом.

- **Отменить:**
  - **Горячая клавиша:** Нажмите **Ctrl+z**, чтобы отменить последнее действие в поле ввода.

- **Повторить:**
  - **Горячая клавиша:** Нажмите **Ctrl+Shift+Z**, чтобы повторить последнее отмененное действие в поле ввода.

## Команды с символом @

Команды с символом `@` используются для включения содержимого файлов или директорий в ваш запрос к модели. Эти команды поддерживают фильтрацию с учетом Git.

- **`@<путь_к_файлу_или_директории>`**
  - **Описание:** Вставляет содержимое указанного файла или файлов в текущий запрос. Это удобно, когда вы хотите задать вопрос о конкретном коде, тексте или наборе файлов.
  - **Примеры:**
    - `@path/to/your/file.txt Объясни этот текст.`
    - `@src/my_project/ Расскажи, что делает код в этой директории.`
    - `Что за файл? @README.md`
  - **Подробности:**
    - Если указан путь к одному файлу, будет прочитано его содержимое.
    - Если указан путь к директории, команда попытается прочитать содержимое всех файлов в этой директории и её поддиректориях.
    - Пробелы в путях нужно экранировать обратным слешем (например, `@My\ Documents/file.txt`).
    - Внутри команда использует инструмент `read_many_files`. Содержимое файлов загружается и вставляется в ваш запрос перед отправкой модели.
    - **Фильтрация с учетом Git:** По умолчанию файлы, игнорируемые Git (например, `node_modules/`, `dist/`, `.env`, `.git/`), исключаются. Это поведение можно изменить через настройку `context.fileFiltering`.
    - **Типы файлов:** Команда предназначена для работы с текстовыми файлами. Хотя она может попытаться прочитать любой файл, бинарные или очень большие файлы могут быть пропущены или обрезаны инструментом `read_many_files` ради производительности и релевантности. Инструмент сообщает, если какие-то файлы были пропущены.
  - **Вывод:** CLI покажет сообщение о вызове инструмента `read_many_files`, а также информацию о статусе и путях, которые были обработаны.

- **`@` (одиночный символ @)**
  - **Описание:** Если вы вводите только символ `@` без пути, запрос передаётся модели как есть. Это может быть полезно, если вы намеренно говорите _о_ символе `@` в своём запросе.

### Обработка ошибок для команд `@`

- Если путь, указанный после `@`, не найден или является недопустимым, будет отображено сообщение об ошибке, и запрос может не быть отправлен в модель, либо он будет отправлен без содержимого файла.
- Если инструмент `read_many_files` столкнется с ошибкой (например, проблемы с правами доступа), это также будет сообщено.

## Режим Shell и команды прямого доступа (`!`)

Префикс `!` позволяет напрямую взаимодействовать с shell вашей системы прямо из Qwen Code.

- **`!<shell_command>`**
  - **Описание:** Выполняет указанную `<shell_command>` с использованием `bash` в Linux/macOS или `cmd.exe` в Windows. Весь вывод и ошибки отображаются в терминале.
  - **Примеры:**
    - `!ls -la` (выполняет `ls -la` и возвращается в Qwen Code)
    - `!git status` (выполняет `git status` и возвращается в Qwen Code)

- **`!` (Переключение режима shell)**
  - **Описание:** Ввод только символа `!` переключает режим shell.
    - **Вход в режим shell:**
      - При активации режим shell использует другую цветовую схему и индикатор режима Shell.
      - В этом режиме весь ввод интерпретируется как команды shell.
    - **Выход из режима shell:**
      - После выхода интерфейс возвращается к стандартному виду, и работа Qwen Code продолжается в обычном режиме.

- **Предупреждение по поводу использования `!`:** Команды, выполняемые в режиме shell, имеют те же права и влияют на систему так же, как если бы вы запускали их напрямую в терминале.

- **Переменная окружения:** Когда команда выполняется через `!` или в режиме shell, в среде подпроцесса устанавливается переменная окружения `QWEN_CODE=1`. Это позволяет скриптам и инструментам определить, были ли они запущены из CLI.