# Команды CLI

Qwen Code поддерживает несколько встроенных команд, которые помогут вам управлять сессией, настраивать интерфейс и контролировать его поведение. Эти команды начинаются с косой черты (`/`), символа @ (`@`) или восклицательного знака (`!`).

## Слэш-команды (`/`)

Слэш-команды предоставляют метауровневый контроль над самим CLI.

### Встроенные команды

- **`/bug`**
  - **Описание:** Создать issue о Qwen Code. По умолчанию issue создается в репозитории GitHub для Qwen Code. Строка, которую вы вводите после `/bug`, становится заголовком создаваемого баг-репорта. Поведение по умолчанию можно изменить с помощью настройки `bugCommand` в файле `.qwen/settings.json`.

- **`/chat`**
  - **Описание:** Сохранить и возобновить историю разговора для интерактивного управления состоянием диалога или восстановления предыдущего состояния из более поздней сессии.
  - **Подкоманды:**
    - **`save`**
      - **Описание:** Сохраняет текущую историю разговора. Необходимо указать `<tag>` для идентификации состояния диалога.
      - **Использование:** `/chat save <tag>`
      - **Информация о местоположении чекпоинтов:** По умолчанию сохраненные чекпоинты чата находятся в следующих директориях:
        - Linux/macOS: `~/.config/google-generative-ai/checkpoints/`
        - Windows: `C:\Users\<YourUsername>\AppData\Roaming\google-generative-ai\checkpoints\`
        - При выполнении `/chat list` CLI сканирует только эти конкретные директории для поиска доступных чекпоинтов.
        - **Примечание:** Эти чекпоинты предназначены для ручного сохранения и восстановления состояний диалога. Для автоматических чекпоинтов, созданных перед изменениями файлов, см. [документацию по чекпоинтам](../checkpointing.md).
    - **`resume`**
      - **Описание:** Возобновляет диалог из предыдущего сохранения.
      - **Использование:** `/chat resume <tag>`
    - **`list`**
      - **Описание:** Выводит список доступных тегов для восстановления состояния чата.
    - **`delete`**
      - **Описание:** Удаляет сохраненный чекпоинт диалога.
      - **Использование:** `/chat delete <tag>`

- **`/clear`**
  - **Описание:** Очистить экран терминала, включая видимую историю сессии и прокрутку внутри CLI. Данные сессии (для восстановления истории) могут сохраняться в зависимости от реализации, но визуальное отображение будет очищено.
  - **Горячая клавиша:** Нажмите **Ctrl+L** в любое время для выполнения очистки.

- **`/compress`**
  - **Описание:** Заменить весь контекст чата кратким резюме. Это позволяет экономить токены при выполнении будущих задач, сохраняя при этом высокоуровневое резюме произошедшего.

- **`/copy`**
  - **Описание:** Копирует последний вывод, сгенерированный Qwen Code, в буфер обмена для удобного обмена или повторного использования.

- **`/directory`** (или **`/dir`**)
  - **Описание:** Управление рабочими директориями для поддержки нескольких директорий.
  - **Подкоманды:**
    - **`add`**:
      - **Описание:** Добавить директорию в рабочее пространство. Путь может быть абсолютным или относительным к текущей рабочей директории. Также поддерживается ссылка относительно домашней директории.
      - **Использование:** `/directory add <path1>,<path2>`
      - **Примечание:** Отключено в ограниченных профилях песочницы. Если вы используете такой профиль, используйте `--include-directories` при запуске сессии.
    - **`show`**:
      - **Описание:** Отобразить все директории, добавленные через `/directory add` и `--include-directories`.
      - **Использование:** `/directory show`

- **`/directory`** (или **`/dir`**)
  - **Описание:** Управление рабочими директориями для поддержки нескольких директорий.
  - **Подкоманды:**
    - **`add`**:
      - **Описание:** Добавить директорию в рабочее пространство. Путь может быть абсолютным или относительным к текущей рабочей директории. Также поддерживается ссылка относительно домашней директории.
      - **Использование:** `/directory add <path1>,<path2>`
      - **Примечание:** Отключено в ограниченных профилях песочницы. Если вы используете такой профиль, используйте `--include-directories` при запуске сессии.
    - **`show`**:
      - **Описание:** Отобразить все директории, добавленные через `/directory add` и `--include-directories`.
      - **Использование:** `/directory show`

- **`/editor`**
  - **Описание:** Открыть диалог выбора поддерживаемых редакторов.

- **`/extensions`**
  - **Описание:** Вывести список всех активных расширений в текущей сессии Qwen Code. См. [Расширения Qwen Code](../extension.md).

- **`/help`** (или **`/?`**)
  - **Описание:** Отобразить справочную информацию о Qwen Code, включая доступные команды и их использование.

- **`/mcp`**
  - **Описание:** Вывести список настроенных серверов Model Context Protocol (MCP), их статус подключения, информацию о серверах и доступные инструменты.
  - **Подкоманды:**
    - **`desc`** или **`descriptions`**:
      - **Описание:** Показать подробные описания серверов и инструментов MCP.
    - **`nodesc`** или **`nodescriptions`**:
      - **Описание:** Скрыть описания инструментов, отображая только их названия.
    - **`schema`**:
      - **Описание:** Показать полную JSON-схему параметров инструмента.
  - **Горячая клавиша:** Нажмите **Ctrl+T** в любое время для переключения между отображением и скрытием описаний инструментов.

- **`/memory`**
  - **Описание:** Управление инструкционным контекстом ИИ (иерархическая память, загружаемая по умолчанию из файлов `QWEN.md`; настраивается через `contextFileName`).
  - **Подкоманды:**
    - **`add`**:
      - **Описание:** Добавляет указанный текст в память ИИ. Использование: `/memory add <текст для запоминания>`
    - **`show`**:
      - **Описание:** Отобразить полное содержимое текущей иерархической памяти, загруженной из всех контекстных файлов (например, `QWEN.md`). Это позволяет проверить инструкционный контекст, передаваемый модели.
    - **`refresh`**:
      - **Описание:** Перезагрузить иерархическую инструкционную память из всех контекстных файлов (по умолчанию: `QWEN.md`), найденных в настроенных местоположениях (глобальные, проект/предки и поддиректории). Это обновляет модель с последними данными контекста.
    - **Примечание:** Подробнее о том, как контекстные файлы формируют иерархическую память, см. в [документации по конфигурации CLI](./configuration.md#context-files-hierarchical-instructional-context).

- **`/restore`**
  - **Описание:** Восстанавливает файлы проекта до состояния, в котором они находились непосредственно перед выполнением инструмента. Особенно полезно для отмены изменений файлов, сделанных инструментом. Если команда запущена без ID вызова инструмента, будет выведен список доступных чекпоинтов для восстановления.
  - **Использование:** `/restore [tool_call_id]`
  - **Примечание:** Доступно только при запуске CLI с опцией `--checkpointing` или при настройке через [settings](./configuration.md). Подробнее см. в [документации по чекпоинтам](../checkpointing.md).

- **`/settings`**
  - **Описание:** Открыть редактор настроек для просмотра и изменения параметров Qwen Code.
  - **Подробности:** Эта команда предоставляет удобный интерфейс для изменения настроек, управляющих поведением и внешним видом Qwen Code. Она эквивалентна ручному редактированию файла `.qwen/settings.json`, но с проверкой и подсказками для предотвращения ошибок.
  - **Использование:** Просто выполните `/settings`, и откроется редактор. Вы можете просматривать или искать конкретные настройки, видеть их текущие значения и изменять их по желанию. Некоторые настройки применяются сразу, другие требуют перезапуска.

- **`/stats`**
  - **Описание:** Отобразить подробную статистику текущей сессии Qwen Code, включая использование токенов, экономию за счет кэширования токенов (если доступно) и продолжительность сессии. Примечание: информация о кэшированных токенах отображается только при их использовании, что происходит при аутентификации по API-ключу, но не при OAuth-аутентификации.

- [**`/theme`**](./themes.md)
  - **Описание:** Открыть диалог для изменения визуальной темы Qwen Code.

- **`/auth`**
  - **Описание:** Открыть диалог для изменения метода аутентификации.

- **`/about`**
  - **Описание:** Показать информацию о версии. Пожалуйста, делитесь этой информацией при создании issue.

- [**`/tools`**](../tools/index.md)
  - **Описание:** Отобразить список инструментов, доступных в текущей сессии Qwen Code.
  - **Подкоманды:**
    - **`desc`** или **`descriptions`**:
      - **Описание:** Показать подробные описания каждого инструмента, включая его название и полное описание, переданное модели.
    - **`nodesc`** или **`nodescriptions`**:
      - **Описание:** Скрыть описания инструментов, отображая только их названия.

- **`/privacy`**
  - **Описание:** Отобразить Уведомление о конфиденциальности и позволить пользователям выбрать, согласны ли они на сбор их данных для улучшения сервиса.

- **`/quit`** (или **`/exit`**)
  - **Описание:** Выйти из Qwen Code.

- **`/vim`**
  - **Описание:** Включить или отключить режим vim. В режиме vim область ввода поддерживает команды навигации и редактирования в стиле vim в режимах NORMAL и INSERT.
  - **Функции:**
    - **Режим NORMAL:** Навигация с помощью `h`, `j`, `k`, `l`; переход по словам с `w`, `b`, `e`; переход к началу/концу строки с `0`, `$`, `^`; переход к конкретной строке с `G` (или `gg` для первой строки)
    - **Режим INSERT:** Стандартный ввод текста с возможностью выхода в режим NORMAL по Escape
    - **Команды редактирования:** Удаление с `x`, изменение с `c`, вставка с `i`, `a`, `o`, `O`; сложные операции, такие как `dd`, `cc`, `dw`, `cw`
    - **Поддержка счетчиков:** Префикс команд цифрами (например, `3h`, `5w`, `10G`)
    - **Повтор последней команды:** Используйте `.` для повтора последней операции редактирования
    - **Постоянное сохранение:** Предпочтение режима vim сохраняется в `~/.qwen/settings.json` и восстанавливается между сессиями
  - **Индикатор статуса:** При включении отображает `[NORMAL]` или `[INSERT]` в нижнем колонтитуле

- **`/init`**
  - **Описание:** Анализирует текущую директорию и создает файл контекста `QWEN.md` по умолчанию (или имя файла, указанное в `contextFileName`). Если файл уже существует и не пуст, изменения не вносятся. Команда создает пустой файл и запрашивает у модели заполнение его инструкциями, специфичными для проекта.

### Пользовательские команды

Для быстрого начала работы ознакомьтесь с [примером](#example-a-pure-function-refactoring-command) ниже.

Пользовательские команды позволяют сохранять и повторно использовать ваши любимые или наиболее часто используемые prompts в виде персональных shortcuts внутри Qwen Code. Вы можете создавать команды, специфичные для одного проекта, или команды, доступные глобально во всех ваших проектах, что упрощает ваш рабочий процесс и обеспечивает согласованность.

#### Расположение файлов и приоритет

Qwen Code обнаруживает команды из двух мест, загружая их в определённом порядке:

1.  **Пользовательские команды (глобальные):** Расположены в `~/.qwen/commands/`. Эти команды доступны в любом проекте, над которым вы работаете.
2.  **Команды проекта (локальные):** Расположены в `<your-project-root>/.qwen/commands/`. Эти команды специфичны для текущего проекта и могут быть добавлены в систему контроля версий, чтобы быть доступными для вашей команды.

Если команда в директории проекта имеет то же имя, что и команда в пользовательской директории, **всегда будет использоваться команда проекта.** Это позволяет проектам переопределять глобальные команды своими версиями, специфичными для проекта.

#### Именование и пространства имён

Имя команды определяется путем к файлу относительно директории `commands`. Подкаталоги используются для создания команд с пространствами имён, при этом разделитель пути (`/` или `\`) преобразуется в двоеточие (`:`).

- Файл `~/.qwen/commands/test.toml` становится командой `/test`.
- Файл `<project>/.qwen/commands/git/commit.toml` становится командой с пространством имён `/git:commit`.

#### Формат TOML (v1)

Файлы определения команд должны быть написаны в формате TOML и иметь расширение `.toml`.

##### Обязательные поля

- `prompt` (String): Prompt, который будет отправлен модели при выполнении команды. Может быть однострочной или многострочной строкой.

##### Необязательные поля

- `description` (String): Краткое описание в одну строку того, что делает команда. Этот текст будет отображаться рядом с вашей командой в меню `/help`. **Если вы опустите это поле, будет сгенерировано общее описание на основе имени файла.**

#### Работа с аргументами

Пользовательские команды поддерживают два мощных и удобных метода обработки аргументов. CLI автоматически выбирает правильный метод на основе содержимого `prompt` вашей команды.

##### 1. Быстрая вставка с помощью `{{args}}`

Если ваш `prompt` содержит специальный placeholder `{{args}}`, CLI заменит этот placeholder на весь текст, который пользователь ввел после имени команды. Это идеально подходит для простых, детерминированных команд, где нужно вставить пользовательский ввод в определенное место шаблона prompt.

**Пример (`git/fix.toml`):**

```toml

# В: ~/.qwen/commands/git/fix.toml

```markdown
# Вызывается через: /git:fix "Кнопка смещена на мобильных устройствах"

description = "Генерирует исправление для указанной проблемы на GitHub."
prompt = "Проанализируй подготовленные изменения в git и предоставь исправление кода для проблемы, описанной здесь: {{args}}."
```

Модель получит финальный prompt: `Проанализируй подготовленные изменения в git и предоставь исправление кода для проблемы, описанной здесь: "Кнопка смещена на мобильных устройствах".`

##### 2. Обработка аргументов по умолчанию

Если ваш `prompt` **не** содержит специальный placeholder `{{args}}`, CLI использует поведение по умолчанию для обработки аргументов.

Если вы передаёте аргументы команде (например, `/mycommand arg1`), CLI добавит полную команду, которую вы ввели, в конец prompt, отделив её двумя символами новой строки. Это позволяет модели видеть как оригинальные инструкции, так и конкретные аргументы, которые вы только что передали.

Если вы **не** передаёте никаких аргументов (например, `/mycommand`), prompt отправляется модели в точности как есть, без каких-либо дополнений.

**Пример (`changelog.toml`):**

Этот пример показывает, как создать надёжную команду, определив роль для модели, объяснив, где искать пользовательский ввод, и указав ожидаемый формат и поведение.

```toml

# In: <project>/.qwen/commands/changelog.toml

# Вызывается через: /changelog 1.2.0 added "Support for default argument parsing."

description = "Добавляет новую запись в файл CHANGELOG.md проекта."
prompt = """

# Задача: Обновление Changelog

Вы являетесь экспертом по сопровождению данного программного проекта. Пользователь вызвал команду для добавления новой записи в changelog.

**Необработанная команда пользователя приведена ниже ваших инструкций.**

Ваша задача — распарсить `<version>`, `<change_type>` и `<message>` из ввода пользователя и использовать инструмент `write_file`, чтобы правильно обновить файл `CHANGELOG.md`.

## Ожидаемый формат
Команда имеет следующий формат: `/changelog <version> <type> <message>`
- `<type>` должен быть одним из: "added", "changed", "fixed", "removed".

## Поведение
1. Прочитать файл `CHANGELOG.md`.
2. Найти секцию для указанной `<version>`.
3. Добавить `<message>` под соответствующий заголовок `<type>`.
4. Если секция версии или типа не существует, создать её.
5. Строго придерживаться формата "Keep a Changelog".
"""
```

Когда вы запускаете `/changelog 1.2.0 added "New feature"`, финальный текст, отправляемый модели, будет состоять из оригинального prompt, за которым следуют два символа новой строки и введённая вами команда.

##### 3. Выполнение Shell-команд с помощью `!{...}`

Вы можете сделать свои команды динамичными, выполняя shell-команды прямо внутри вашего `prompt` и подставляя их вывод. Это идеально подходит для сбора контекста из локального окружения, например, чтения содержимого файлов или проверки статуса Git.

Когда кастомная команда пытается выполнить shell-команду, Qwen Code теперь будет запрашивать подтверждение перед выполнением. Это мера безопасности, чтобы убедиться, что выполняются только намеренные команды.

**Как это работает:**

1.  **Внедрение команд:** Используйте синтаксис `!{...}` в вашем `prompt`, чтобы указать, где команда должна быть выполнена и куда внедрить её вывод.
2.  **Подтверждение выполнения:** При запуске команды появится диалоговое окно со списком shell-команд, которые prompt хочет выполнить.
3.  **Предоставление разрешения:** Вы можете выбрать:
    - **Разрешить один раз:** Команда(ы) выполнится(ются) только в этот раз.
    - **Разрешить всегда для этой сессии:** Команда(ы) будет(ут) добавлена(ы) во временный allowlist для текущей CLI-сессии и больше не потребует подтверждения.
    - **Нет:** Отменить выполнение shell-команд(ы).

CLI по-прежнему учитывает глобальные настройки `excludeTools` и `coreTools`. Команда будет заблокирована без запроса подтверждения, если она явно запрещена в вашей конфигурации.

**Пример (`git/commit.toml`):**

Эта команда получает staged git diff и использует его, чтобы попросить модель написать commit message.

````toml

# In: <project>/.qwen/commands/git/commit.toml

# Invoked via: /git:commit

description = "Генерирует сообщение Git commit на основе staged изменений."

# В prompt используется !{...} для выполнения команды и вставки её вывода.
prompt = """
Пожалуйста, сгенерируйте сообщение Conventional Commit на основе следующего git diff:

```diff
!{git diff --staged}
```

"""

```

Когда вы запускаете `/git:commit`, CLI сначала выполняет `git diff --staged`, затем заменяет `!{git diff --staged}` на вывод этой команды перед отправкой финального prompt в модель.

#### Пример: Команда рефакторинга "Чистая функция"

Давайте создадим глобальную команду, которая будет запрашивать у модели рефакторинг фрагмента кода.

**1. Создайте файл и директории:**

Сначала убедитесь, что директория пользовательских команд существует, затем создайте поддиректорию `refactor` для организации и конечный TOML-файл.

```bash
mkdir -p ~/.qwen/commands/refactor
touch ~/.qwen/commands/refactor/pure.toml
```

**2. Добавьте содержимое в файл:**

Откройте `~/.qwen/commands/refactor/pure.toml` в вашем редакторе и добавьте следующее содержимое. Мы включаем опциональное поле `description` для лучшей практики.

```toml

# In: ~/.qwen/commands/refactor/pure.toml

# Эта команда будет вызываться через: /refactor:pure

description = "Запрашивает у модели рефакторинг текущего контекста в чистую функцию."

prompt = """
Пожалуйста, проанализируйте код, который я предоставил в текущем контексте.
Выполните его рефакторинг в чистую функцию.

Ваш ответ должен включать:
1. Блок кода с рефакторингнутой чистой функцией.
2. Краткое объяснение ключевых изменений, которые вы внесли, и почему они способствуют чистоте.
"""
```

**3. Запустите команду:**

Вот и все! Теперь вы можете запустить свою команду в CLI. Сначала вы можете добавить файл в контекст, а затем вызвать команду:

```
> @my-messy-function.js
> /refactor:pure
```

Qwen Code затем выполнит многострочный prompt, определенный в вашем TOML-файле.

## Команды с @

Команды с `@` используются для включения содержимого файлов или директорий в ваш запрос к модели. Эти команды поддерживают фильтрацию с учетом Git.

- **`@<путь_к_файлу_или_директории>`**
  - **Описание:** Вставляет содержимое указанного файла или файлов в ваш текущий запрос. Это удобно, когда вы хотите задать вопрос о конкретном коде, тексте или наборе файлов.
  - **Примеры:**
    - `@path/to/your/file.txt Объясни этот текст.`
    - `@src/my_project/ Кратко опиши код в этой директории.`
    - `О чём этот файл? @README.md`
  - **Подробности:**
    - Если указан путь к одному файлу, будет прочитано его содержимое.
    - Если указан путь к директории, команда попытается прочитать содержимое файлов в этой директории и всех поддиректориях.
    - Пробелы в путях нужно экранировать обратным слешем (например, `@My\ Documents/file.txt`).
    - Внутри команда использует инструмент `read_many_files`. Содержимое считывается и вставляется в ваш запрос перед отправкой модели.
    - **Фильтрация с учетом Git:** По умолчанию файлы, игнорируемые Git (например, `node_modules/`, `dist/`, `.env`, `.git/`), исключаются. Это поведение можно изменить через настройку `fileFiltering`.
    - **Типы файлов:** Команда предназначена для текстовых файлов. Хотя она может попытаться прочитать любой файл, бинарные или очень большие файлы могут быть пропущены или обрезаны инструментом `read_many_files` ради производительности и релевантности. Инструмент укажет, если какие-то файлы были пропущены.
  - **Вывод:** CLI покажет сообщение о вызове инструмента `read_many_files`, с указанием статуса и обработанных путей.

- **`@` (одиночный символ @)**
  - **Описание:** Если вы вводите только символ `@` без пути, запрос передается модели как есть. Это может быть полезно, если вы специально говорите _о_ символе `@` в своем запросе.

### Обработка ошибок для команд `@`

- Если путь, указанный после `@`, не найден или является недопустимым, будет отображено сообщение об ошибке, и запрос может не быть отправлен в модель, либо он будет отправлен без содержимого файла.
- Если инструмент `read_many_files` столкнется с ошибкой (например, проблемы с правами доступа), это также будет сообщено.

## Режим Shell и команды прямого доступа (`!`)

Префикс `!` позволяет напрямую взаимодействовать с shell вашей системы прямо из Qwen Code.

- **`!<shell_command>`**
  - **Описание:** Выполняет указанную `<shell_command>` с использованием `bash` в Linux/macOS или `cmd.exe` в Windows. Весь вывод и ошибки команды отображаются в терминале.
  - **Примеры:**
    - `!ls -la` (выполняет `ls -la` и возвращается в Qwen Code)
    - `!git status` (выполняет `git status` и возвращается в Qwen Code)

- **`!` (Переключение режима shell)**
  - **Описание:** Ввод только символа `!` переключает режим shell.
    - **Вход в режим shell:**
      - При активации режим shell использует другую цветовую схему и "индикатор режима Shell".
      - В режиме shell весь вводимый текст интерпретируется непосредственно как команда shell.
    - **Выход из режима shell:**
      - При выходе интерфейс возвращается к стандартному виду, и возобновляется обычное поведение Qwen Code.

- **Предостережение при использовании `!`:** Команды, выполняемые в режиме shell, имеют те же права доступа и такой же эффект, как если бы вы запускали их напрямую в терминале.

- **Переменная окружения:** Когда команда выполняется через `!` или в режиме shell, в окружении подпроцесса устанавливается переменная `QWEN_CODE=1`. Это позволяет скриптам или инструментам определить, запущены ли они из CLI.