# Команды CLI

Qwen Code поддерживает несколько встроенных команд, которые помогут вам управлять сессией, настраивать интерфейс и контролировать его поведение. Эти команды начинаются с косой черты (`/`), символа @ (`@`) или восклицательного знака (`!`).

## Слэш-команды (`/`)

Слэш-команды предоставляют мета-уровень контроля над самим CLI.

### Встроенные команды

- **`/bug`**
  - **Описание:** Создать issue о Qwen Code. По умолчанию issue создается в GitHub-репозитории проекта Qwen Code. Строка, которую вы вводите после `/bug`, становится заголовком создаваемого баг-репорта. Поведение команды `/bug` по умолчанию можно изменить с помощью настройки `advanced.bugCommand` в файле `.qwen/settings.json`.

- **`/chat`**
  - **Описание:** Сохранить и возобновить историю разговора для интерактивной работы с ветвлением состояния разговора или восстановления предыдущего состояния из более поздней сессии.
  - **Подкоманды:**
    - **`save`**
      - **Описание:** Сохраняет текущую историю разговора. Необходимо указать `<tag>` для идентификации состояния разговора.
      - **Использование:** `/chat save <tag>`
      - **Детали о расположении чекпоинтов:** Стандартные пути для сохранения чекпоинтов чата:
        - Linux/macOS: `~/.qwen/tmp/<project_hash>/`
        - Windows: `C:\Users\<YourUsername>\.qwen\tmp\<project_hash>\`
        - При выполнении `/chat list` CLI сканирует только эти конкретные директории для поиска доступных чекпоинтов.
        - **Примечание:** Эти чекпоинты предназначены для ручного сохранения и восстановления состояний разговора. Для автоматических чекпоинтов, создаваемых перед изменениями файлов, см. [документацию по Checkpointing](../checkpointing.md).
    - **`resume`**
      - **Описание:** Возобновляет разговор из предыдущего сохранения.
      - **Использование:** `/chat resume <tag>`
    - **`list`**
      - **Описание:** Выводит список доступных тегов для восстановления состояния чата.
    - **`delete`**
      - **Описание:** Удаляет сохранённый чекпоинт разговора.
      - **Использование:** `/chat delete <tag>`
    - **`share`**
      - **Описание:** Записывает текущий разговор в указанный Markdown или JSON файл.
      - **Использование:** `/chat share file.md` или `/chat share file.json`. Если имя файла не указано, CLI сгенерирует его автоматически.

- **`/clear`**
  - **Описание:** Очистить экран терминала, включая видимую историю сессии и прокрутку внутри CLI. Базовые данные сессии (для восстановления истории) могут сохраняться в зависимости от реализации, но визуальное отображение будет очищено.
  - **Горячая клавиша:** Нажмите **Ctrl+L** в любое время для выполнения очистки.

- **`/summary`**
  - **Описание:** Генерирует полный обзор проекта на основе текущей истории разговора и сохраняет его в `.qwen/PROJECT_SUMMARY.md`. Этот обзор включает общую цель, ключевые знания, последние действия и текущий план, что идеально подходит для возобновления работы в будущих сессиях.
  - **Использование:** `/summary`
  - **Функции:**
    - Анализирует всю историю разговора для извлечения важного контекста
    - Создаёт структурированный markdown-обзор с разделами: цели, знания, действия, планы
    - Автоматически сохраняет в `.qwen/PROJECT_SUMMARY.md` в корне проекта
    - Показывает индикаторы прогресса во время генерации и сохранения
    - Интегрируется с функцией Welcome Back для бесшовного возобновления сессии
  - **Примечание:** Эта команда требует активного разговора с минимум 2 сообщениями для создания осмысленного обзора.

- **`/compress`**
  - **Описание:** Заменяет весь контекст чата кратким обзором. Это позволяет экономить токены для будущих задач, сохраняя высокоуровневое резюме произошедшего.

- **`/copy`**
  - **Описание:** Копирует последний вывод, сгенерированный Qwen Code, в буфер обмена для удобного использования или отправки.

- **`/directory`** (или **`/dir`**)
  - **Описание:** Управление рабочими директориями для поддержки нескольких директорий.
  - **Подкоманды:**
    - **`add`**:
      - **Описание:** Добавляет директорию в рабочее пространство. Путь может быть абсолютным или относительным к текущей рабочей директории. Также поддерживается ссылка относительно домашней директории.
      - **Использование:** `/directory add <path1>,<path2>`
      - **Примечание:** Отключено в ограничительных sandbox-профилях. Если вы используете такой профиль, используйте `--include-directories` при запуске сессии.
    - **`show`**:
      - **Описание:** Отображает все директории, добавленные через `/directory add` и `--include-directories`.
      - **Использование:** `/directory show`

- **`/editor`**
  - **Описание:** Открывает диалог выбора поддерживаемых редакторов.

- **`/extensions`**
  - **Описание:** Выводит список всех активных расширений в текущей сессии Qwen Code. См. [Qwen Code Extensions](../extension.md).

- **`/help`** (или **`/?`**)
  - **Описание:** Отображает справочную информацию о Qwen Code, включая доступные команды и их использование.

- **`/mcp`**
  - **Описание:** Выводит список настроенных серверов Model Context Protocol (MCP), их статус подключения, информацию о серверах и доступные инструменты.
  - **Подкоманды:**
    - **`desc`** или **`descriptions`**:
      - **Описание:** Показывает подробные описания серверов и инструментов MCP.
    - **`nodesc`** или **`nodescriptions`**:
      - **Описание:** Скрывает описания инструментов, отображая только их названия.
    - **`schema`**:
      - **Описание:** Показывает полную JSON-схему параметров инструмента.
  - **Горячая клавиша:** Нажмите **Ctrl+T** в любое время для переключения отображения описаний инструментов.

- **`/memory`**
  - **Описание:** Управление инструкционным контекстом ИИ (иерархическая память, загружаемая по умолчанию из файлов `QWEN.md`; настраивается через `contextFileName`).
  - **Подкоманды:**
    - **`add`**:
      - **Описание:** Добавляет указанный текст в память ИИ. Использование: `/memory add <text to remember>`
    - **`show`**:
      - **Описание:** Отображает полное содержимое текущей иерархической памяти, загруженной из всех контекстных файлов (например, `QWEN.md`). Это позволяет проверить инструкционный контекст, передаваемый модели.
    - **`refresh`**:
      - **Описание:** Перезагружает иерархическую инструкционную память из всех контекстных файлов (по умолчанию: `QWEN.md`), найденных в настроенных местах (глобальные, проект/предки, поддиректории). Обновляет модель с актуальным контекстом.
    - **Примечание:** Подробнее о том, как контекстные файлы формируют иерархическую память, см. в [документации по CLI Configuration](./configuration.md#context-files-hierarchical-instructional-context).

- **`/restore`**
  - **Описание:** Восстанавливает файлы проекта в состояние, в котором они находились до выполнения инструмента. Особенно полезно для отмены изменений файлов, сделанных инструментом. Если запущено без ID вызова инструмента, выводит список доступных чекпоинтов для восстановления.
  - **Использование:** `/restore [tool_call_id]`
  - **Примечание:** Доступно только при запуске CLI с опцией `--checkpointing` или настройке через [settings](./configuration.md). Подробнее см. в [документации по Checkpointing](../checkpointing.md).

- **`/settings`**
  - **Описание:** Открывает редактор настроек для просмотра и изменения параметров Qwen Code.
  - **Детали:** Эта команда предоставляет удобный интерфейс для изменения настроек, управляющих поведением и внешним видом Qwen Code. Эквивалентно ручному редактированию файла `.qwen/settings.json`, но с валидацией и подсказками для предотвращения ошибок.
  - **Использование:** Просто выполните `/settings`, и откроется редактор. Вы можете просматривать или искать конкретные настройки, видеть их текущие значения и изменять их. Некоторые изменения применяются сразу, другие требуют перезапуска.

- **`/stats`**
  - **Описание:** Отображает подробную статистику текущей сессии Qwen Code, включая использование токенов, экономию за счёт кэширования (если доступно) и продолжительность сессии. Примечание: информация о кэшированных токенах отображается только при их использовании, что происходит при аутентификации через API-ключ, но не через OAuth.

- [**`/theme`**](./themes.md)
  - **Описание:** Открывает диалог для изменения визуальной темы Qwen Code.

- **`/auth`**
  - **Описание:** Открывает диалог для изменения метода аутентификации.

- **`/approval-mode`**
  - **Описание:** Изменяет режим подтверждения использования инструментов.
  - **Использование:** `/approval-mode [mode] [--session|--project|--user]`
  - **Доступные режимы:**
    - **`plan`**: Только анализ; не изменяет файлы и не выполняет команды
    - **`default`**: Требует подтверждения для редактирования файлов или выполнения команд
    - **`auto-edit`**: Автоматически одобряет редактирование файлов
    - **`yolo`**: Автоматически одобряет все инструменты
  - **Примеры:**
    - `/approval-mode plan --project` (сохранить режим plan для этого проекта)
    - `/approval-mode yolo --user` (сохранить режим YOLO для этого пользователя во всех проектах)

- **`/about`**
  - **Описание:** Показывает информацию о версии. Пожалуйста, делитесь этой информацией при создании issue.

- **`/agents`**
  - **Описание:** Управление специализированными AI-агентами для выполнения конкретных задач. Агенты — это независимые ИИ-ассистенты с настроенной экспертизой и доступом к инструментам.
  - **Подкоманды:**
    - **`create`**:
      - **Описание:** Запускает интерактивный мастер создания нового агента. Мастер помогает выбрать расположение, сгенерировать промпт с помощью ИИ, выбрать инструменты и настроить внешний вид.
      - **Использование:** `/agents create`
    - **`manage`**:
      - **Описание:** Открывает интерактивный диалог управления для просмотра, редактирования и удаления существующих агентов. Показывает агентов уровня проекта и уровня пользователя.
      - **Использование:** `/agents manage`
  - **Места хранения:**
    - **Уровень проекта:** `.qwen/agents/` (общие с командой, имеют приоритет)
    - **Уровень пользователя:** `~/.qwen/agents/` (личные агенты, доступны во всех проектах)
  - **Примечание:** Подробнее о создании и управлении агентами см. в [документации по Subagents](../subagents.md).

- [**`/tools`**](../tools/index.md)
  - **Описание:** Отображает список инструментов, доступных в текущей сессии Qwen Code.
  - **Использование:** `/tools [desc]`
  - **Подкоманды:**
    - **`desc`** или **`descriptions`**:
      - **Описание:** Показывает подробные описания каждого инструмента, включая имя и полное описание, передаваемое модели.
    - **`nodesc`** или **`nodescriptions`**:
      - **Описание:** Скрывает описания инструментов, отображая только их названия.

- **`/quit-confirm`**
  - **Описание:** Показывает диалог подтверждения перед выходом из Qwen Code, позволяя выбрать, как обработать текущую сессию.
  - **Использование:** `/quit-confirm`
  - **Функции:**
    - **Выйти немедленно:** Закрыть без сохранения (эквивалентно `/quit`)
    - **Сгенерировать обзор и выйти:** Создать обзор проекта через `/summary` перед выходом
    - **Сохранить разговор и выйти:** Сохранить текущий разговор с автоматически сгенерированным тегом перед выходом
  - **Горячая клавиша:** Нажмите **Ctrl+C** дважды для вызова диалога подтверждения выхода
  - **Примечание:** Эта команда автоматически вызывается при однократном нажатии Ctrl+C, обеспечивая защиту от случайного выхода.

- **`/quit`** (или **`/exit`**)
  - **Описание:** Немедленно выйти из Qwen Code без диалога подтверждения.

- **`/vim`**
  - **Описание:** Включает или отключает режим vim. В режиме vim область ввода поддерживает навигацию и команды редактирования в стиле vim в режимах NORMAL и INSERT.
  - **Функции:**
    - **Режим NORMAL:** Навигация с помощью `h`, `j`, `k`, `l`; переход по словам с `w`, `b`, `e`; переход к началу/концу строки с `0`, `$`, `^`; переход к конкретной строке с `G` (или `gg` для первой строки)
    - **Режим INSERT:** Стандартный ввод текста с возможностью выхода в NORMAL через Esc
    - **Команды редактирования:** Удаление с `x`, изменение с `c`, вставка с `i`, `a`, `o`, `O`; сложные операции типа `dd`, `cc`, `dw`, `cw`
    - **Поддержка счетчиков:** Префикс команд цифрами (например, `3h`, `5w`, `10G`)
    - **Повтор последней команды:** Используйте `.` для повтора последней операции редактирования
    - **Постоянное сохранение:** Предпочтение режима vim сохраняется в `~/.qwen/settings.json` и восстанавливается между сессиями
  - **Индикатор статуса:** При включении показывает `[NORMAL]` или `[INSERT]` в нижнем колонтитуле

- **`/init`**
  - **Описание:** Анализирует текущую директорию и создаёт файл контекста `QWEN.md` по умолчанию (или имя файла, указанное в `contextFileName`). Если файл уже существует и не пуст, изменения не вносятся. Команда создаёт пустой файл и запрашивает у модели заполнение его проектными инструкциями.

### Пользовательские команды

Для быстрого начала работы ознакомьтесь с [примером](#example-a-pure-function-refactoring-command) ниже.

Пользовательские команды позволяют сохранять и повторно использовать ваши любимые или наиболее часто используемые prompts в виде персональных shortcuts внутри Qwen Code. Вы можете создавать команды, специфичные для одного проекта, или команды, доступные глобально во всех ваших проектах, оптимизируя свой workflow и обеспечивая консистентность.

#### Расположение файлов и приоритет

Qwen Code обнаруживает команды из двух мест, загружая их в определённом порядке:

1.  **Пользовательские команды (глобальные):** Расположены в `~/.qwen/commands/`. Эти команды доступны в любом проекте, над которым вы работаете.
2.  **Команды проекта (локальные):** Расположены в `<your-project-root>/.qwen/commands/`. Эти команды специфичны для текущего проекта и могут быть добавлены в систему контроля версий, чтобы быть доступными для вашей команды.

Если команда в директории проекта имеет то же имя, что и команда в пользовательской директории, **всегда будет использоваться команда проекта.** Это позволяет проектам переопределять глобальные команды своими локальными версиями.

#### Именование и пространства имён

Имя команды определяется путем к файлу относительно директории `commands`. Подкаталоги используются для создания команд с пространствами имён, при этом разделитель пути (`/` или `\`) преобразуется в двоеточие (`:`).

- Файл `~/.qwen/commands/test.toml` становится командой `/test`.
- Файл `<project>/.qwen/commands/git/commit.toml` становится командой с пространством имён `/git:commit`.

#### Формат файла TOML (v1)

Файлы определения команд должны быть написаны в формате TOML и иметь расширение `.toml`.

##### Обязательные поля

- `prompt` (String): Prompt, который будет отправлен модели при выполнении команды. Может быть однострочной или многострочной строкой.

##### Необязательные поля

- `description` (String): Краткое однострочное описание того, что делает команда. Этот текст будет отображаться рядом с вашей командой в меню `/help`. **Если вы опустите это поле, будет сгенерировано общее описание на основе имени файла.**

#### Работа с аргументами

Пользовательские команды поддерживают два мощных метода обработки аргументов. CLI автоматически выбирает правильный метод на основе содержимого `prompt` вашей команды.

##### 1. Контекстно-зависимая инъекция с помощью `{{args}}`

Если ваш `prompt` содержит специальный плейсхолдер `{{args}}`, CLI заменит этот плейсхолдер на текст, который пользователь ввел после имени команды.

Поведение этой инъекции зависит от места ее использования:

**A. Прямая инъекция (вне shell-команд)**

Когда используется в основном теле prompt, аргументы инжектируются точно так, как их ввел пользователь.

**Пример (`git/fix.toml`):**

```toml

```markdown
# Вызывается через: /git:fix "Кнопка смещена"

description = "Генерирует исправление для указанной проблемы."
prompt = "Пожалуйста, предоставьте кодовое исправление для описанной здесь проблемы: {{args}}."
```

Модель получает: `Пожалуйста, предоставьте кодовое исправление для описанной здесь проблемы: "Кнопка смещена".`

**B. Использование аргументов в Shell-командах (внутри блоков `!{...}`)**

Когда вы используете `{{args}}` внутри блока инъекции shell (`!{...}`), аргументы автоматически **экранируются для shell** перед подстановкой. Это позволяет безопасно передавать аргументы в shell-команды, гарантируя корректность синтаксиса и безопасность результирующей команды, предотвращая уязвимости инъекций команд.

**Пример (`/grep-code.toml`):**

```toml
prompt = """
Пожалуйста, суммируйте результаты поиска по шаблону `{{args}}`.

Результаты поиска:
!{grep -r {{args}} .}
"""
```

Когда вы запускаете `/grep-code It's complicated`:

1. CLI видит, что `{{args}}` используется как вне, так и внутри `!{...}`.
2. Вне: Первый `{{args}}` заменяется как есть на `It's complicated`.
3. Внутри: Второй `{{args}}` заменяется на экранированную версию (например, в Linux: `"It's complicated"`).
4. Выполняемая команда: `grep -r "It's complicated" .`.
5. CLI предлагает вам подтвердить именно эту безопасную команду перед выполнением.
6. Финальный prompt отправляется.
```

##### 2. Обработка аргументов по умолчанию

Если ваш `prompt` **не содержит** специальный placeholder `{{args}}`, CLI использует поведение по умолчанию для обработки аргументов.

Если вы передаёте аргументы команде (например, `/mycommand arg1`), CLI добавит полную команду, которую вы ввели, в конец prompt через два символа новой строки. Это позволяет модели видеть как оригинальные инструкции, так и конкретные аргументы, которые вы только что передали.

Если вы **не передаёте** никаких аргументов (например, `/mycommand`), prompt отправляется модели в точности как есть, без каких-либо дополнений.

**Пример (`changelog.toml`):**

Этот пример показывает, как создать надежную команду, определив роль для модели, объяснив, где искать пользовательский ввод, и указав ожидаемый формат и поведение.

```toml

# In: <project>/.qwen/commands/changelog.toml

# Вызывается через: /changelog 1.2.0 added "Support for default argument parsing."

description = "Добавляет новую запись в файл CHANGELOG.md проекта."
prompt = """

# Задача: Обновление Changelog

Вы являетесь экспертом по сопровождению данного программного проекта. Пользователь вызвал команду для добавления новой записи в changelog.

**Необработанная команда пользователя приведена ниже ваших инструкций.**

Ваша задача — распарсить `<version>`, `<change_type>` и `<message>` из их ввода и использовать инструмент `write_file`, чтобы правильно обновить файл `CHANGELOG.md`.

## Ожидаемый формат
Команда имеет следующий формат: `/changelog <version> <type> <message>`
- `<type>` должен быть одним из: "added", "changed", "fixed", "removed".

```markdown
## Поведение
1. Прочитать файл `CHANGELOG.md`.
2. Найти раздел для указанной `<version>`.
3. Добавить `<message>` под правильным заголовком `<type>`.
4. Если раздел версии или типа не существует, создать его.
5. Строго придерживаться формата "Keep a Changelog".
"""

При запуске `/changelog 1.2.0 added "New feature"` финальный текст, отправляемый модели, будет состоять из оригинального промпта, за которым следуют два символа новой строки и введенная команда.
```

##### 3. Выполнение Shell-команд с помощью `!{...}`

Вы можете сделать свои команды динамическими, выполняя shell-команды прямо внутри вашего `prompt` и подставляя их вывод. Это идеально подходит для сбора контекста из локального окружения, например, чтения содержимого файлов или проверки статуса Git.

Когда кастомная команда пытается выполнить shell-команду, Qwen Code теперь будет запрашивать подтверждение перед выполнением. Это мера безопасности, чтобы убедиться, что выполняются только намеренные команды.

**Как это работает:**

1.  **Инъекция команд:** Используйте синтаксис `!{...}`.
2.  **Подстановка аргументов:** Если внутри блока присутствует `{{args}}`, он автоматически экранируется для shell (см. [Context-Aware Injection](#1-context-aware-injection-with-args) выше).
3.  **Надежный парсинг:** Парсер корректно обрабатывает сложные shell-команды, включая вложенные фигурные скобки, например, JSON-полезные нагрузки. **Примечание:** Содержимое внутри `!{...}` должно иметь сбалансированные фигурные скобки (`{` и `}`). Если вам нужно выполнить команду с несбалансированными скобками, рассмотрите возможность обернуть её во внешний скрипт и вызвать этот скрипт внутри блока `!{...}`.
4.  **Проверка безопасности и подтверждение:** CLI выполняет проверку безопасности финальной команды (после экранирования и подстановки аргументов). Появится диалог с точной командой(ами), которая будет выполнена.
5.  **Выполнение и отчет об ошибках:** Команда выполняется. Если команда завершается с ошибкой, вывод, вставленный в prompt, будет содержать сообщения об ошибках (stderr), за которыми следует строка статуса, например, `[Shell command exited with code 1]`. Это помогает модели понять контекст ошибки.

**Пример (`git/commit.toml`):**

Эта команда получает staged git diff и использует его, чтобы попросить модель написать commit message.

````toml

# In: <project>/.qwen/commands/git/commit.toml

# Invoked via: /git:commit

description = "Генерирует сообщение Git commit на основе изменений, добавленных в staging area."

# В prompt используется !{...} для выполнения команды и подстановки её вывода.
prompt = """
Пожалуйста, сгенерируйте сообщение Conventional Commit на основе следующего git diff:

```diff
!{git diff --staged}
```

"""

````

Когда вы запускаете `/git:commit`, CLI сначала выполняет `git diff --staged`, затем заменяет `!{git diff --staged}` на вывод этой команды перед отправкой финального prompt'а модели.

##### 4. Внедрение содержимого файлов с помощью `@{...}`

Вы можете напрямую вставлять содержимое файла или список файлов в директории в ваш prompt, используя синтаксис `@{...}`. Это удобно для создания команд, работающих с конкретными файлами.

**Как это работает:**

- **Внедрение файла**: `@{path/to/file.txt}` заменяется содержимым `file.txt`.
- **Поддержка мультимодальных данных**: Если путь указывает на поддерживаемый формат изображения (например, PNG, JPEG), PDF, аудио или видео, файл будет корректно закодирован и внедрён как мультимодальный ввод. Другие бинарные файлы обрабатываются корректно и пропускаются.
- **Список файлов в директории**: `@{path/to/dir}` обрабатывается рекурсивно, и каждый файл в директории и всех поддиректориях добавляется в prompt. При этом учитываются `.gitignore` и `.qwenignore`, если они включены.
- **Работа с рабочими областями**: Поиск пути осуществляется в текущей директории и других директориях рабочей области. Допустимы абсолютные пути, если они находятся внутри рабочей области.
- **Порядок обработки**: Внедрение содержимого файлов через `@{...}` происходит _до_ выполнения shell-команд (`!{...}`) и подстановки аргументов (`{{args}}`).
- **Парсинг**: Парсер требует, чтобы содержимое внутри `@{...}` (путь) имело сбалансированные фигурные скобки (`{` и `}`).

**Пример (`review.toml`):**

Эта команда внедряет содержимое _фиксированного_ файла с лучшими практиками (`docs/best-practices.md`) и использует аргументы пользователя для предоставления контекста ревью.

```toml

```markdown
# В: <project>/.qwen/commands/review.toml

# Вызывается через: /review FileCommandLoader.ts

description = "Проверяет предоставленный контекст с использованием руководства по лучшим практикам."
prompt = """
Вы — эксперт по код-ревью.

Ваша задача — провести ревью {{args}}.

Используйте следующие лучшие практики при составлении отзыва:

@{docs/best-practices.md}
```

Когда вы запускаете `/review FileCommandLoader.ts`, плейсхолдер `@{docs/best-practices.md}` заменяется содержимым этого файла, а `{{args}}` — текстом, который вы указали, после чего финальный prompt отправляется модели.

---

#### Пример: Команда рефакторинга "Чистая функция"

Давайте создадим глобальную команду, которая будет запрашивать у модели рефакторинг фрагмента кода.

**1. Создайте файл и каталоги:**

Сначала убедитесь, что каталог пользовательских команд существует, затем создайте подкаталог `refactor` для организации и конечный TOML-файл.

```bash
mkdir -p ~/.qwen/commands/refactor
touch ~/.qwen/commands/refactor/pure.toml
```

**2. Добавьте содержимое в файл:**

Откройте `~/.qwen/commands/refactor/pure.toml` в вашем редакторе и добавьте следующее содержимое. Мы включаем необязательное поле `description` для лучшей практики.

```toml

# In: ~/.qwen/commands/refactor/pure.toml

```markdown
# Эта команда будет вызываться через: /refactor:pure

description = "Просит модель рефакторить текущий контекст в чистую функцию (pure function)."

prompt = """
Пожалуйста, проанализируй код, который я предоставил в текущем контексте.
Рефактори его в чистую функцию (pure function).

Твой ответ должен включать:
1. Блок кода с рефакторингом в чистую функцию.
2. Краткое объяснение ключевых изменений, которые ты сделал, и почему они способствуют чистоте функции.
"""
```

**3. Запусти команду:**

Вот и всё! Теперь ты можешь запустить свою команду в CLI. Сначала добавь файл в контекст, а затем вызови команду:

```
> @my-messy-function.js
> /refactor:pure
```

Qwen Code выполнит многострочный prompt, определённый в твоём TOML-файле.
```

## Шорткаты для работы с текстом

Эти шорткаты применяются непосредственно к полю ввода для манипуляций с текстом.

- **Отменить:**
  - **Горячая клавиша:** Нажмите **Ctrl+z**, чтобы отменить последнее действие в поле ввода.

- **Повторить:**
  - **Горячая клавиша:** Нажмите **Ctrl+Shift+Z**, чтобы повторить последнее отмененное действие в поле ввода.

## Команды с символом @

Команды с символом `@` используются для включения содержимого файлов или директорий в ваш запрос к модели. Эти команды поддерживают фильтрацию с учетом Git.

- **`@<путь_к_файлу_или_директории>`**
  - **Описание:** Вставляет содержимое указанного файла или файлов в текущий запрос. Это удобно, когда вы хотите задать вопрос о конкретном коде, тексте или наборе файлов.
  - **Примеры:**
    - `@path/to/your/file.txt Объясни этот текст.`
    - `@src/my_project/ Кратко опиши код в этой директории.`
    - `О чём этот файл? @README.md`
  - **Подробности:**
    - Если указан путь к одному файлу, будет прочитано его содержимое.
    - Если указан путь к директории, команда попытается прочитать содержимое всех файлов в этой директории и её поддиректориях.
    - Пробелы в путях нужно экранировать обратным слэшем (например, `@My\ Documents/file.txt`).
    - Внутри команда использует инструмент `read_many_files`. Содержимое считывается и вставляется в ваш запрос перед отправкой модели.
    - **Фильтрация с учётом Git:** По умолчанию файлы, игнорируемые Git (например, `node_modules/`, `dist/`, `.env`, `.git/`), исключаются. Это поведение можно изменить через настройку `context.fileFiltering`.
    - **Типы файлов:** Команда предназначена для работы с текстовыми файлами. Хотя она может попытаться прочитать любой файл, бинарные или очень большие файлы могут быть пропущены или обрезаны инструментом `read_many_files` ради производительности и релевантности. Инструмент сообщает, если какие-то файлы были пропущены.
  - **Вывод:** CLI покажет сообщение о вызове инструмента `read_many_files`, а также информацию о статусе и путях, которые были обработаны.

- **`@` (одиночный символ @)**
  - **Описание:** Если вы вводите только символ `@` без пути, запрос передаётся модели как есть. Это может быть полезно, если вы намеренно говорите _о самом символе_ `@` в своём запросе.

### Обработка ошибок для команд `@`

- Если путь, указанный после `@`, не найден или является недопустимым, будет отображено сообщение об ошибке, и запрос может не быть отправлен в модель, либо он будет отправлен без содержимого файла.
- Если инструмент `read_many_files` столкнется с ошибкой (например, проблемы с правами доступа), это также будет сообщено.

## Режим Shell и команды прямого выполнения (`!`)

Префикс `!` позволяет напрямую взаимодействовать с shell вашей системы прямо из Qwen Code.

- **`!<shell_command>`**
  - **Описание:** Выполняет указанную `<shell_command>` с использованием `bash` в Linux/macOS или `cmd.exe` в Windows. Весь вывод и ошибки команды отображаются в терминале.
  - **Примеры:**
    - `!ls -la` (выполняет `ls -la` и возвращается в Qwen Code)
    - `!git status` (выполняет `git status` и возвращается в Qwen Code)

- **`!` (Переключение режима shell)**
  - **Описание:** Ввод только символа `!` переключает режим shell.
    - **Вход в режим shell:**
      - При активации режима shell используется другая цветовая схема и отображается "индикатор режима Shell".
      - В режиме shell весь ввод интерпретируется как команды shell.
    - **Выход из режима shell:**
      - При выходе интерфейс возвращается к стандартному виду, и работа Qwen Code продолжается в обычном режиме.

- **Предупреждение по использованию `!`:** Команды, выполняемые в режиме shell, имеют те же права и влияют на систему так же, как если бы вы запускали их напрямую в терминале.

- **Переменная окружения:** При выполнении команды через `!` или в режиме shell в окружении подпроцесса устанавливается переменная `QWEN_CODE=1`. Это позволяет скриптам и инструментам определять, запущены ли они из CLI.