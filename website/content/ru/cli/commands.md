# Команды CLI

Qwen Code поддерживает несколько встроенных команд, которые помогут вам управлять сессией, настраивать интерфейс и контролировать его поведение. Эти команды начинаются с косой черты (`/`), символа @ (`@`) или восклицательного знака (`!`).

## Слэш-команды (`/`)

Слэш-команды предоставляют мета-уровень управления самим CLI.

### Встроенные команды

- **`/bug`**
  - **Описание:** Создать issue о Qwen Code. По умолчанию issue создается в репозитории GitHub проекта Qwen Code. Строка, которую вы вводите после `/bug`, становится заголовком создаваемого баг-репорта. Поведение команды `/bug` можно изменить с помощью настройки `bugCommand` в файле `.qwen/settings.json`.

- **`/chat`**
  - **Описание:** Сохранить и возобновить историю разговора для интерактивного управления состоянием диалога или восстановления предыдущего состояния в следующей сессии.
  - **Подкоманды:**
    - **`save`**
      - **Описание:** Сохраняет текущую историю разговора. Необходимо указать `<tag>` для идентификации состояния диалога.
      - **Использование:** `/chat save <tag>`
      - **Детали о местоположении чекпоинтов:** По умолчанию сохраненные чекпоинты чата находятся в следующих директориях:
        - Linux/macOS: `~/.config/qwen-code/checkpoints/`
        - Windows: `C:\Users\<YourUsername>\AppData\Roaming\qwen-code\checkpoints\`
        - При выполнении `/chat list` CLI сканирует только эти конкретные директории для поиска доступных чекпоинтов.
        - **Примечание:** Эти чекпоинты предназначены для ручного сохранения и восстановления состояний диалога. Для автоматических чекпоинтов, создаваемых перед изменениями файлов, см. [документацию по Checkpointing](../checkpointing.md).
    - **`resume`**
      - **Описание:** Возобновляет диалог из предыдущего сохранения.
      - **Использование:** `/chat resume <tag>`
    - **`list`**
      - **Описание:** Выводит список доступных тегов для восстановления состояния чата.
    - **`delete`**
      - **Описание:** Удаляет сохраненный чекпоинт диалога.
      - **Использование:** `/chat delete <tag>`

- **`/clear`**
  - **Описание:** Очистить экран терминала, включая видимую историю сессии и прокрутку внутри CLI. Данные сессии (для восстановления истории) могут сохраняться в зависимости от реализации, но визуальное отображение будет очищено.
  - **Горячая клавиша:** Нажмите **Ctrl+L** в любое время для очистки экрана.

- **`/summary`**
  - **Описание:** Генерирует полный обзор проекта на основе текущей истории разговора и сохраняет его в файл `.qwen/PROJECT_SUMMARY.md`. Этот обзор включает общую цель, ключевые знания, последние действия и текущий план, что идеально подходит для возобновления работы в будущих сессиях.
  - **Использование:** `/summary`
  - **Функции:**
    - Анализирует всю историю разговора для извлечения важного контекста
    - Создает структурированный markdown-обзор с разделами по целям, знаниям, действиям и планам
    - Автоматически сохраняет в `.qwen/PROJECT_SUMMARY.md` в корне проекта
    - Показывает индикаторы прогресса во время генерации и сохранения
    - Интегрируется с функцией Welcome Back для бесшовного возобновления сессии
  - **Примечание:** Эта команда требует активного диалога как минимум с 2 сообщениями для создания содержательного обзора.

- **`/compress`**
  - **Описание:** Заменяет весь контекст чата кратким обзором. Это позволяет экономить токены при выполнении будущих задач, сохраняя при этом высокоуровневое резюме произошедшего.

- **`/copy`**
  - **Описание:** Копирует последний вывод, сгенерированный Qwen Code, в буфер обмена для удобного обмена или повторного использования.

- **`/directory`** (или **`/dir`**)
  - **Описание:** Управление рабочими директориями для поддержки нескольких директорий.
  - **Подкоманды:**
    - **`add`**:
      - **Описание:** Добавляет директорию в рабочее пространство. Путь может быть абсолютным или относительным к текущей рабочей директории. Также поддерживается ссылка относительно домашней директории.
      - **Использование:** `/directory add <path1>,<path2>`
      - **Примечание:** Отключено в ограниченных профилях песочницы. Если вы используете такой профиль, используйте `--include-directories` при запуске сессии.
    - **`show`**:
      - **Описание:** Отображает все директории, добавленные через `/directory add` и `--include-directories`.
      - **Использование:** `/directory show`

- **`/directory`** (или **`/dir`**)
  - **Описание:** Управление рабочими директориями для поддержки нескольких директорий.
  - **Подкоманды:**
    - **`add`**:
      - **Описание:** Добавляет директорию в рабочее пространство. Путь может быть абсолютным или относительным к текущей рабочей директории. Также поддерживается ссылка относительно домашней директории.
      - **Использование:** `/directory add <path1>,<path2>`
      - **Примечание:** Отключено в ограниченных профилях песочницы. Если вы используете такой профиль, используйте `--include-directories` при запуске сессии.
    - **`show`**:
      - **Описание:** Отображает все директории, добавленные через `/directory add` и `--include-directories`.
      - **Использование:** `/directory show`

- **`/editor`**
  - **Описание:** Открывает диалог выбора поддерживаемых редакторов.

- **`/extensions`**
  - **Описание:** Выводит список всех активных расширений в текущей сессии Qwen Code. См. [Qwen Code Extensions](../extension.md).

- **`/help`** (или **`/?`**)
  - **Описание:** Отображает справочную информацию о Qwen Code, включая доступные команды и их использование.

- **`/mcp`**
  - **Описание:** Выводит список настроенных серверов Model Context Protocol (MCP), их статус подключения, информацию о серверах и доступные инструменты.
  - **Подкоманды:**
    - **`desc`** или **`descriptions`**:
      - **Описание:** Показывает подробные описания серверов и инструментов MCP.
    - **`nodesc`** или **`nodescriptions`**:
      - **Описание:** Скрывает описания инструментов, отображая только их названия.
    - **`schema`**:
      - **Описание:** Показывает полную JSON-схему параметров инструмента.
  - **Горячая клавиша:** Нажмите **Ctrl+T** в любое время для переключения отображения описаний инструментов.

- **`/memory`**
  - **Описание:** Управление инструкционным контекстом ИИ (иерархическая память, загружаемая по умолчанию из файлов `QWEN.md`; настраивается через `contextFileName`).
  - **Подкоманды:**
    - **`add`**:
      - **Описание:** Добавляет следующий текст в память ИИ. Использование: `/memory add <text to remember>`
    - **`show`**:
      - **Описание:** Отображает полное содержимое текущей иерархической памяти, загруженной из всех контекстных файлов (например, `QWEN.md`). Это позволяет проверить инструкционный контекст, передаваемый модели.
    - **`refresh`**:
      - **Описание:** Перезагружает иерархическую инструкционную память из всех контекстных файлов (по умолчанию: `QWEN.md`), найденных в настроенных местоположениях (глобальные, проект/предки и поддиректории). Это обновляет модель с последним контекстом.
    - **Примечание:** За дополнительной информацией о том, как контекстные файлы формируют иерархическую память, см. [документацию по CLI Configuration](./configuration.md#context-files-hierarchical-instructional-context).

- **`/restore`**
  - **Описание:** Восстанавливает файлы проекта в состояние, в котором они находились до выполнения инструмента. Особенно полезно для отмены изменений файлов, сделанных инструментом. Если запущено без ID вызова инструмента, выводит список доступных чекпоинтов для восстановления.
  - **Использование:** `/restore [tool_call_id]`
  - **Примечание:** Доступно только при запуске CLI с опцией `--checkpointing` или настройке через [settings](./configuration.md). См. [документацию по Checkpointing](../checkpointing.md) для подробностей.

- **`/settings`**
  - **Описание:** Открывает редактор настроек для просмотра и изменения параметров Qwen Code.
  - **Детали:** Эта команда предоставляет удобный интерфейс для изменения настроек, управляющих поведением и внешним видом Qwen Code. Эквивалентно ручному редактированию файла `.qwen/settings.json`, но с валидацией и подсказками для предотвращения ошибок.
  - **Использование:** Просто выполните `/settings`, и откроется редактор. Вы можете просматривать или искать конкретные настройки, видеть их текущие значения и изменять их. Некоторые изменения применяются сразу, другие требуют перезапуска.

- **`/stats`**
  - **Описание:** Отображает подробную статистику текущей сессии Qwen Code, включая использование токенов, экономию за счет кэширования (если доступно) и продолжительность сессии. Примечание: Информация о кэшированных токенах отображается только при их использовании, что происходит при аутентификации по API-ключу, но не при OAuth-аутентификации.

- [**`/theme`**](./themes.md)
  - **Описание:** Открывает диалог для изменения визуальной темы Qwen Code.

- **`/auth`**
  - **Описание:** Открывает диалог для изменения метода аутентификации.

- **`/about`**
  - **Описание:** Показывает информацию о версии. Пожалуйста, делитесь этой информацией при создании issue.

- **`/agents`**
  - **Описание:** Управление специализированными AI-подагентами для выполнения конкретных задач. Подагенты — это независимые AI-ассистенты с конкретной экспертизой и доступом к инструментам.
  - **Подкоманды:**
    - **`create`**:
      - **Описание:** Запускает интерактивный мастер создания нового подагента. Мастер помогает выбрать местоположение, сгенерировать промпт с помощью ИИ, выбрать инструменты и настроить внешний вид.
      - **Использование:** `/agents create`
    - **`manage`**:
      - **Описание:** Открывает интерактивный диалог управления для просмотра, редактирования и удаления существующих подагентов. Показывает агентов на уровне проекта и пользователя.
      - **Использование:** `/agents manage`
  - **Места хранения:**
    - **На уровне проекта:** `.qwen/agents/` (общие с командой, имеют приоритет)
    - **На уровне пользователя:** `~/.qwen/agents/` (личные агенты, доступны во всех проектах)
  - **Примечание:** За подробной информацией о создании и управлении подагентами см. [документацию по Subagents](../subagents.md).

- [**`/tools`**](../tools/index.md)
  - **Описание:** Отображает список инструментов, доступных в текущей сессии Qwen Code.
  - **Подкоманды:**
    - **`desc`** или **`descriptions`**:
      - **Описание:** Показывает подробные описания каждого инструмента, включая его название и полное описание, передаваемое модели.
    - **`nodesc`** или **`nodescriptions`**:
      - **Описание:** Скрывает описания инструментов, отображая только их названия.

- **`/privacy`**
  - **Описание:** Отображает Уведомление о конфиденциальности и позволяет пользователям выбрать, согласны ли они на сбор их данных для улучшения сервиса.

- **`/quit-confirm`**
  - **Описание:** Показывает диалог подтверждения перед выходом из Qwen Code, позволяя выбрать, как обработать текущую сессию.
  - **Использование:** `/quit-confirm`
  - **Функции:**
    - **Выйти немедленно:** Завершить работу без сохранения (эквивалентно `/quit`)
    - **Создать обзор и выйти:** Сгенерировать обзор проекта с помощью `/summary` перед выходом
    - **Сохранить диалог и выйти:** Сохранить текущий диалог с автоматически сгенерированным тегом перед выходом
  - **Горячая клавиша:** Нажмите **Ctrl+C** дважды для вызова диалога подтверждения выхода
  - **Примечание:** Эта команда автоматически вызывается при однократном нажатии Ctrl+C, обеспечивая защиту от случайного выхода.

- **`/quit`** (или **`/exit`**)
  - **Описание:** Немедленно завершает работу Qwen Code без диалога подтверждения.

- **`/vim`**
  - **Описание:** Включает или выключает режим vim. В режиме vim область ввода поддерживает команды навигации и редактирования в стиле vim в режимах NORMAL и INSERT.
  - **Функции:**
    - **Режим NORMAL:** Навигация с помощью `h`, `j`, `k`, `l`; переход по словам с `w`, `b`, `e`; переход к началу/концу строки с `0`, `$`, `^`; переход к конкретным строкам с `G` (или `gg` для первой строки)
    - **Режим INSERT:** Стандартный ввод текста с возможностью выхода в NORMAL по Escape
    - **Команды редактирования:** Удаление с `x`, изменение с `c`, вставка с `i`, `a`, `o`, `O`; сложные операции типа `dd`, `cc`, `dw`, `cw`
    - **Поддержка счетчиков:** Префикс команд цифрами (например, `3h`, `5w`, `10G`)
    - **Повтор последней команды:** Используйте `.` для повтора последней операции редактирования
    - **Постоянное сохранение:** Предпочтение режима vim сохраняется в `~/.qwen/settings.json` и восстанавливается между сессиями
  - **Индикатор статуса:** При включении показывает `[NORMAL]` или `[INSERT]` в нижнем колонтитуле

- **`/init`**
  - **Описание:** Анализирует текущую директорию и создает файл контекста `QWEN.md` по умолчанию (или имя файла, указанное в `contextFileName`). Если файл уже существует и не пуст, изменения не вносятся. Команда созд

### Пользовательские команды

Для быстрого начала работы ознакомьтесь с [примером](#example-a-pure-function-refactoring-command) ниже.

Пользовательские команды позволяют сохранять и повторно использовать ваши любимые или наиболее часто используемые prompts в виде персональных shortcuts внутри Qwen Code. Вы можете создавать команды, специфичные для одного проекта, или команды, доступные глобально во всех ваших проектах, что упрощает рабочий процесс и обеспечивает согласованность.

#### Расположение файлов и приоритет

Qwen Code обнаруживает команды из двух мест, загружая их в определённом порядке:

1.  **Пользовательские команды (глобальные):** Расположены в `~/.qwen/commands/`. Эти команды доступны во всех проектах, над которыми вы работаете.
2.  **Команды проекта (локальные):** Расположены в `<your-project-root>/.qwen/commands/`. Эти команды специфичны для текущего проекта и могут быть добавлены в систему контроля версий, чтобы быть доступными для вашей команды.

Если команда в директории проекта имеет то же имя, что и команда в пользовательской директории, **всегда будет использоваться команда проекта.** Это позволяет проектам переопределять глобальные команды своими локальными версиями.

#### Именование и пространства имён

Имя команды определяется путем к файлу относительно директории `commands`. Подкаталоги используются для создания команд с пространствами имён, при этом разделитель пути (`/` или `\`) преобразуется в двоеточие (`:`).

- Файл `~/.qwen/commands/test.toml` становится командой `/test`.
- Файл `<project>/.qwen/commands/git/commit.toml` становится командой с пространством имён `/git:commit`.

#### Формат файла TOML (v1)

Файлы определения команд должны быть написаны в формате TOML и иметь расширение `.toml`.

##### Обязательные поля

- `prompt` (String): Подсказка, которая будет отправлена модели при выполнении команды. Может быть однострочной или многострочной строкой.

##### Необязательные поля

- `description` (String): Краткое однострочное описание того, что делает команда. Этот текст будет отображаться рядом с вашей командой в меню `/help`. **Если вы опустите это поле, будет сгенерировано общее описание на основе имени файла.**

#### Работа с аргументами

Пользовательские команды поддерживают два мощных метода обработки аргументов. CLI автоматически выбирает правильный метод на основе содержимого `prompt` вашей команды.

##### 1. Контекстно-зависимая инъекция с `{{args}}`

Если ваш `prompt` содержит специальный placeholder `{{args}}`, CLI заменит этот placeholder на текст, который пользователь ввел после имени команды.

Поведение этой инъекции зависит от места использования:

**A. Прямая инъекция (вне shell-команд)**

Когда используется в основном теле prompt, аргументы инжектируются точно так, как их ввел пользователь.

**Пример (`git/fix.toml`):**

```toml

```markdown
# Вызывается через: /git:fix "Button is misaligned"

description = "Генерирует фикс для указанной проблемы."
prompt = "Пожалуйста, предоставьте код фикса для проблемы, описанной здесь: {{args}}."
```

Модель получает: `Пожалуйста, предоставьте код фикса для проблемы, описанной здесь: "Button is misaligned".`

**B. Использование аргументов в Shell командах (внутри блоков `!{...}`)**

Когда вы используете `{{args}}` внутри блока инъекции shell (`!{...}`), аргументы автоматически **экранируются для shell** перед подстановкой. Это позволяет безопасно передавать аргументы в shell команды, гарантируя, что результирующая команда будет синтаксически корректной и безопасной, предотвращая уязвимости инъекции команд.

**Пример (`/grep-code.toml`):**

```toml
prompt = """
Пожалуйста, подведите итоги поиска для паттерна `{{args}}`.

Результаты поиска:
!{grep -r {{args}} .}
"""
```

Когда вы запускаете `/grep-code It's complicated`:

1. CLI видит, что `{{args}}` используется как вне, так и внутри `!{...}`.
2. Вне: Первый `{{args}}` заменяется как есть на `It's complicated`.
3. Внутри: Второй `{{args}}` заменяется на экранированную версию (например, в Linux: `"It's complicated"`).
4. Выполняемая команда: `grep -r "It's complicated" .`.
5. CLI запрашивает у вас подтверждение этой точной и безопасной команды перед выполнением.
6. Финальный prompt отправляется.
```

##### 2. Обработка аргументов по умолчанию

Если ваш `prompt` **не** содержит специальный placeholder `{{args}}`, CLI использует поведение по умолчанию для обработки аргументов.

Если вы передаёте аргументы команде (например, `/mycommand arg1`), CLI добавит полную команду, которую вы ввели, в конец prompt, отделив её двумя символами новой строки. Это позволяет модели видеть как оригинальные инструкции, так и конкретные аргументы, которые вы только что передали.

Если вы **не** передаёте аргументы (например, `/mycommand`), prompt отправляется модели в точности как есть, без каких-либо дополнений.

**Пример (`changelog.toml`):**

Этот пример показывает, как создать надёжную команду, определив роль для модели, объяснив, где искать пользовательский ввод, и указав ожидаемый формат и поведение.

```toml

# In: <project>/.qwen/commands/changelog.toml

# Вызывается через: /changelog 1.2.0 added "Support for default argument parsing."

description = "Добавляет новую запись в файл CHANGELOG.md проекта."
prompt = """

# Задача: Обновление Changelog

Вы являетесь экспертом по поддержке этого программного проекта. Пользователь вызвал команду для добавления новой записи в changelog.

**Необработанная команда пользователя приведена ниже ваших инструкций.**

Ваша задача — распарсить `<version>`, `<change_type>` и `<message>` из ввода пользователя и использовать инструмент `write_file`, чтобы правильно обновить файл `CHANGELOG.md`.

## Ожидаемый формат
Команда имеет следующий формат: `/changelog <version> <type> <message>`
- `<type>` должен быть одним из: "added", "changed", "fixed", "removed".

```markdown
## Поведение
1. Прочитать файл `CHANGELOG.md`.
2. Найти секцию для указанной `<version>`.
3. Добавить `<message>` под правильным заголовком `<type>`.
4. Если секция версии или типа не существует, создать её.
5. Строго придерживаться формата "Keep a Changelog".
"""
```

Когда вы запускаете `/changelog 1.2.0 added "New feature"`, финальный текст, отправляемый модели, будет состоять из оригинального prompt, за которым следуют два символа новой строки и введённая вами команда.

##### 3. Выполнение Shell-команд с помощью `!{...}`

Вы можете сделать свои команды динамичными, выполняя shell-команды прямо внутри вашего `prompt` и подставляя их вывод. Это идеально подходит для сбора контекста из локального окружения, например, чтения содержимого файлов или проверки статуса Git.

Когда кастомная команда пытается выполнить shell-команду, Qwen Code теперь будет запрашивать подтверждение перед выполнением. Это мера безопасности, чтобы убедиться, что выполняются только намеренные команды.

**Как это работает:**

1.  **Инъекция команд:** Используйте синтаксис `!{...}`.
2.  **Подстановка аргументов:** Если внутри блока присутствует `{{args}}`, он автоматически экранируется для shell (см. [Context-Aware Injection](#1-context-aware-injection-with-args) выше).
3.  **Надежный парсинг:** Парсер корректно обрабатывает сложные shell-команды, включая вложенные фигурные скобки, например, JSON-полезные нагрузки.
4.  **Проверка безопасности и подтверждение:** CLI выполняет проверку безопасности финальной команды (после экранирования и подстановки аргументов). Появится диалог с точной командой(ами), которая будет выполнена.
5.  **Выполнение и отчет об ошибках:** Команда выполняется. Если команда завершается с ошибкой, вывод, вставленный в prompt, будет содержать сообщения об ошибках (stderr), за которыми следует строка статуса, например, `[Shell command exited with code 1]`. Это помогает модели понять контекст ошибки.

**Пример (`git/commit.toml`):**

Эта команда получает staged git diff и использует его, чтобы попросить модель написать commit message.

````toml

# In: <project>/.qwen/commands/git/commit.toml

# Invoked via: /git:commit

description = "Генерирует сообщение Git commit на основе staged изменений."

# В prompt используется !{...} для выполнения команды и вставки её вывода.
prompt = """
Пожалуйста, сгенерируйте сообщение Conventional Commit на основе следующего git diff:

```diff
!{git diff --staged}
```

"""

````

Когда вы запускаете `/git:commit`, CLI сначала выполняет `git diff --staged`, затем заменяет `!{git diff --staged}` на вывод этой команды перед отправкой финального prompt в модель.

#### Пример: Команда рефакторинга "Чистая функция"

Давайте создадим глобальную команду, которая будет запрашивать у модели рефакторинг фрагмента кода.

**1. Создайте файл и каталоги:**

Сначала убедитесь, что каталог пользовательских команд существует, затем создайте подкаталог `refactor` для организации и конечный TOML-файл.

```bash
mkdir -p ~/.qwen/commands/refactor
touch ~/.qwen/commands/refactor/pure.toml
```

**2. Добавьте содержимое в файл:**

Откройте `~/.qwen/commands/refactor/pure.toml` в вашем редакторе и добавьте следующее содержимое. Мы включаем необязательное поле `description` для лучшей практики.

```toml

# In: ~/.qwen/commands/refactor/pure.toml

```markdown
# Эта команда будет вызываться через: /refactor:pure

description = "Просит модель рефакторить текущий контекст в чистую функцию (pure function)."

prompt = """
Пожалуйста, проанализируй код, который я предоставил в текущем контексте.
Рефактори его в чистую функцию (pure function).

Твой ответ должен включать:
1. Блок кода с рефакторинговой, чистой функцией.
2. Краткое объяснение ключевых изменений, которые ты сделал, и почему они способствуют чистоте функции.
"""
```

**3. Запусти команду:**

Вот и всё! Теперь ты можешь запустить свою команду в CLI. Сначала можно добавить файл в контекст, а затем вызвать команду:

```
> @my-messy-function.js
> /refactor:pure
```

Qwen Code выполнит многострочный prompt, определённый в твоем TOML-файле.

## Команды с @

Команды с `@` используются для включения содержимого файлов или директорий в ваш запрос к модели. Эти команды поддерживают фильтрацию с учетом Git.

- **`@<путь_к_файлу_или_директории>`**
  - **Описание:** Вставляет содержимое указанного файла или файлов в ваш текущий запрос. Это удобно, когда вы хотите задать вопрос о конкретном коде, тексте или наборе файлов.
  - **Примеры:**
    - `@path/to/your/file.txt Объясни этот текст.`
    - `@src/my_project/ Расскажи, что за код лежит в этой директории.`
    - `Что это за файл? @README.md`
  - **Подробности:**
    - Если указан путь к одному файлу, будет прочитано его содержимое.
    - Если указан путь к директории, команда попытается прочитать содержимое всех файлов в этой директории и её поддиректориях.
    - Пробелы в путях нужно экранировать обратным слешем (например, `@My\ Documents/file.txt`).
    - Внутри команда использует инструмент `read_many_files`. Содержимое файлов подгружается и вставляется в ваш запрос перед отправкой модели.
    - **Фильтрация с учетом Git:** По умолчанию файлы, игнорируемые Git (например, `node_modules/`, `dist/`, `.env`, `.git/`), исключаются. Это поведение можно изменить через настройку `fileFiltering`.
    - **Типы файлов:** Команда предназначена для работы с текстовыми файлами. Хотя она может попытаться прочитать любой файл, бинарные или очень большие файлы могут быть пропущены или обрезаны инструментом `read_many_files` ради производительности и релевантности. Инструмент укажет, если какие-то файлы были пропущены.
  - **Вывод:** CLI покажет сообщение о вызове инструмента `read_many_files`, с указанием статуса и путей, которые были обработаны.

- **`@` (одиночный символ @)**
  - **Описание:** Если вы вводите одиночный символ `@` без пути, запрос передаётся модели как есть. Это может быть полезно, если вы специально говорите _о_ символе `@` в своём запросе.

### Обработка ошибок для команд `@`

- Если путь, указанный после `@`, не найден или является недопустимым, будет отображено сообщение об ошибке, и запрос может не быть отправлен в модель, либо будет отправлен без содержимого файла.
- Если инструмент `read_many_files` столкнется с ошибкой (например, проблемы с правами доступа), это также будет сообщено.

## Режим Shell и команды прямого выполнения (`!`)

Префикс `!` позволяет напрямую взаимодействовать с shell вашей системы прямо из Qwen Code.

- **`!<shell_command>`**
  - **Описание:** Выполняет указанную `<shell_command>` с использованием `bash` в Linux/macOS или `cmd.exe` в Windows. Весь вывод и ошибки команды отображаются в терминале.
  - **Примеры:**
    - `!ls -la` (выполняет `ls -la` и возвращается в Qwen Code)
    - `!git status` (выполняет `git status` и возвращается в Qwen Code)

- **`!` (Переключение в режим shell)**
  - **Описание:** Ввод только символа `!` переключает режим shell.
    - **Вход в режим shell:**
      - При активации режима shell используется другая цветовая схема и отображается "индикатор режима Shell".
      - В режиме shell весь ввод интерпретируется как команды shell.
    - **Выход из режима shell:**
      - При выходе интерфейс возвращается к стандартному виду, и работа Qwen Code продолжается в обычном режиме.

- **Предупреждение по использованию `!`:** Команды, выполняемые в режиме shell, имеют те же права и влияют на систему так же, как если бы вы запускали их напрямую в терминале.

- **Переменная окружения:** При выполнении команды через `!` или в режиме shell в окружении подпроцесса устанавливается переменная `QWEN_CODE=1`. Это позволяет скриптам и инструментам определять, запущены ли они из CLI.