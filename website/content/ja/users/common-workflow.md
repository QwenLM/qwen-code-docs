# 一般的なワークフロー

> Qwen Code を使った一般的なワークフローについて学びましょう。

このドキュメントの各タスクには、明確な手順、コマンド例、およびベストプラクティスが含まれており、Qwen Code を最大限に活用するのに役立ちます。

## 新しいコードベースを理解する

### コードベースの概要をすばやく把握する

新しいプロジェクトに参加したばかりで、その構造をすばやく理解する必要があるとします。

**1. プロジェクトのルートディレクトリに移動します**

```bash
cd /path/to/project
```

**2. Qwen Code を起動します**

```bash
qwen
```

**3. 高レベルの概要を求めます**

```
give me an overview of this codebase
```

**4. 特定のコンポーネントについて詳しく調べます**

```
explain the main architecture patterns used here
```

```
what are the key data models?
```

```
how is authentication handled?
```

> [!tip]
>
> - 広範囲な質問から始め、次第に特定の領域に絞り込みましょう
> - プロジェクトで使用されているコーディング規約やパターンについて尋ねましょう
> - プロジェクト固有の用語集を要求しましょう

### 関連コードの検索

特定の機能やロジックに関連するコードを探す必要があるとします。

**1. Qwen Code に関連ファイルの検索を依頼**

```
ユーザー認証を処理するファイルを探す
```

**2. コンポーネント間の相互作用に関するコンテキストを取得**

```
これらの認証ファイルはどのように連携しているのか？
```

**3. 実行フローを理解**

```
フロントエンドからデータベースまでのログインプロセスを追跡
```

> [!tip]
>
> - 探しているものを具体的に説明しましょう
> - プロジェクト内のドメイン言語を使用しましょう

## 効率的にバグを修正する

エラーメッセージに遭遇して、その原因を見つけて修正する必要があるとします。

**1. Qwen Code にエラーを共有する**

```
npm test を実行するとエラーが表示されます
```

**2. 修正方法の提案を求める**

```
user.ts の @ts-ignore を修正する方法をいくつか提案してください
```

**3. 修正を適用する**

```
user.ts を更新して、提案された null チェックを追加してください
```

> [!tip]
>
> - Qwen Code に問題を再現するコマンドとスタックトレースを教えてください
> - エラーを再現する手順があれば言及してください
> - エラーが断続的か一貫しているかを Qwen Code に知らせてください

## コードのリファクタリング

古いコードを現代的なパターンとプラクティスを使用するように更新する必要があると仮定します。

**1. リファクタリング対象のレガシーコードを特定する**

```
コードベース内で非推奨のAPI使用箇所を探す
```

**2. リファクタリングの推奨事項を取得する**

```
utils.jsを現代的なJavaScript機能を使用してリファクタリングする方法を提案する
```

**3. 変更を安全に適用する**

```
utils.jsをES2024の機能を使用してリファクタリングし、同じ動作を維持する
```

**4. リファクタリングを検証する**

```
リファクタリングされたコードのテストを実行する
```

> [!tip]
>
> - Qwen Codeに現代的アプローチの利点を説明させる
> - 必要に応じて変更が下位互換性を維持するよう要求する
> - 小さなテスト可能な単位でリファクタリングを行う

## 専門的なサブエージェントを使用する

特定のタスクをより効果的に処理するために、専門的なAIサブエージェントを使用したいとします。

**1. 利用可能なサブエージェントを表示する**

```
/agents
```

これにより、利用可能なすべてのサブエージェントが表示され、新しいサブエージェントを作成できます。

**2. サブエージェントを自動的に使用する**

Qwen Codeは自動的に適切なタスクを専門的なサブエージェントに委譲します：

```
最近のコード変更でセキュリティ問題がないかレビューしてください
```

```
すべてのテストを実行し、失敗があれば修正してください
```

**3. 特定のサブエージェントを明示的に要求する**

```
code-reviewerサブエージェントを使用してauthモジュールをチェックしてください
```

```
debuggerサブエージェントにユーザーがログインできない理由を調査させてください
```

**4. ワークフロー用のカスタムサブエージェントを作成する**

```
/agents
```

次に「作成」を選択し、プロンプトに従って以下を定義します：

- サブエージェントの目的を説明する一意の識別子（例：`code-reviewer`、`api-designer`）
- Qwen Codeがこのエージェントを使用すべきタイミング
- アクセスできるツール
- エージェントの役割と行動を説明するシステムプロンプト

> [!tip]
>
> - チーム共有のためにプロジェクト固有のサブエージェントを`.qwen/agents/`に作成する
> - 自動委譲を可能にするために記述的な`description`フィールドを使用する
> - 各サブエージェントが実際に必要とするツールアクセスのみに制限する
> - [サブエージェント](/users/features/sub-agents)について詳しく知る
> - [承認モード](/users/features/approval-mode)について詳しく知る

## テストの作業

未テストのコードにテストを追加する必要があるとします。

**1. 未テストのコードを特定する**

```
NotificationsService.swift 内でテストでカバーされていない関数を探す
```

**2. テストのスキャフォールディングを生成する**

```
通知サービスのテストを追加する
```

**3. 意味のあるテストケースを追加する**

```
通知サービスのエッジ条件に対するテストケースを追加する
```

**4. テストを実行して検証する**

```
新しいテストを実行し、失敗があれば修正する
```

Qwen Code はプロジェクトの既存のパターンや規則に従ったテストを生成できます。テストを依頼する際には、どのような動作を検証したいかを具体的に示してください。Qwen Code は既存のテストファイルを調べて、使用されているスタイル、フレームワーク、アサーションパターンに合わせます。

包括的なカバレッジのために、見逃しがちなエッジケースの特定を Qwen Code に依頼してください。Qwen Code はコードパスを分析し、エラー状態、境界値、予期しない入力など、見落とされがちなテストを提案できます。

## プルリクエストの作成

変更内容について、十分なドキュメントが整備されたプルリクエストを作成する必要があるとします。

**1. 変更内容の要約**

```
認証モジュールに加えた変更を要約してください
```

**2. Qwen Code でプルリクエストを生成**

```
PR を作成してください
```

**3. 確認と改善**

```
セキュリティの改善点に関する詳細なコンテキストを追加して、PR の説明を強化してください
```

**4. テスト詳細の追加**

```
これらの変更がどのようにテストされたかについての情報を追加してください
```

> [!tip]
>
> - Qwen Code に直接 PR の作成を依頼できます
> - 提出前に Qwen Code が生成した PR を確認してください
> - Qwen Code に潜在的なリスクや注意点を強調するよう依頼できます

## ドキュメントの取り扱い

コードのドキュメントを追加または更新する必要があるとします。

**1. ドキュメントが不足しているコードの特定**

```
authモジュール内で適切なJSDocコメントがない関数を探す
```

**2. ドキュメントの生成**

```
auth.js内のドキュメントが不足している関数にJSDocコメントを追加する
```

**3. レビューと改善**

```
生成されたドキュメントにより多くのコンテキストと例を追加して改善する
```

**4. ドキュメントの検証**

```
ドキュメントがプロジェクト標準に従っているか確認する
```

> [!tip]
>
> - 希望するドキュメントスタイル（JSDoc、docstringsなど）を指定する
> - ドキュメントに例を含めるように要求する
> - 公開API、インターフェース、複雑なロジックのドキュメントを要求する

## ファイルとディレクトリの参照

`@` を使用して、Qwen Code が読み込むのを待たずに迅速にファイルやディレクトリを含めることができます。

**1. 単一ファイルの参照**

```
@src/utils/auth.js のロジックを説明してください
```

これにより、ファイルの全内容が会話に含まれます。

**2. ディレクトリの参照**

```
@src/components の構造は何ですか？
```

これにより、ファイル情報付きのディレクトリリストが提供されます。

**3. MCP リソースの参照**

```
@github: repos/owner/repo/issues からデータを表示してください
```

これは、`@server: resource` の形式を使用して接続された MCP サーバーからデータを取得します。詳細については [MCP](/users/features/mcp) を参照してください。

> [!tip]
>
> - ファイルパスは相対パスでも絶対パスでもかまいません
> - @ ファイル参照は、ファイルのディレクトリおよび親ディレクトリに `QWEN.md` を追加してコンテキストに含めます
> - ディレクトリ参照はファイルリストを表示し、内容は表示しません
> - 1つのメッセージで複数のファイルを参照できます（例: "`@file 1.js` と `@file 2.js`"）

## 以前の会話を再開する

Qwen Code でタスクに取り組んでいて、後続のセッションで中断したところから作業を続けたい場合があります。

Qwen Code には、以前の会話を再開するためのオプションが 2 つあります。

- `--continue`：直近の会話を自動的に継続します。
- `--resume`：会話選択画面を表示します。

**1. 直近の会話を継続する**

```bash
qwen --continue
```

これにより、プロンプトなしで直近の会話を即座に再開できます。

**2. 非対話モードで継続する**

```bash
qwen --continue --p "Continue with my task"
```

`--continue` と一緒に `--print` を使用すると、非対話モードで直近の会話を再開できます。スクリプトや自動化に最適です。

**3. 会話選択画面を表示する**

```bash
qwen --resume
```

これにより、以下の情報を含むインタラクティブな会話選択画面が表示されます。

- セッションの概要（または最初のプロンプト）
- メタデータ：経過時間、メッセージ数、Git ブランチ

矢印キーで移動し、Enter キーで会話を選択します。Esc キーで終了します。

> [!tip]
>
> - 会話履歴はローカルマシンに保存されます
> - 直近の会話に素早くアクセスしたい場合は `--continue` を使用してください
> - 特定の過去の会話を選択したい場合は `--resume` を使用してください
> - 再開時には、継続前に会話の全履歴が表示されます
> - 再開された会話は、元の会話と同じモデルと設定で開始されます
>
> **仕組み**:
>
> 1. **会話の保存**: 全ての会話は、完全なメッセージ履歴とともにローカルに自動保存されます
> 2. **メッセージの復元**: 再開時にコンテキストを維持するために、すべてのメッセージ履歴が復元されます
> 3. **ツールの状態**: 前回の会話でのツールの使用状況と結果が保持されます
> 4. **コンテキストの復元**: 以前のすべてのコンテキストを維持したまま会話が再開されます
>
> **例**:
>
> ```bash
> # 直近の会話を継続
> qwen --continue
>
> # 特定のプロンプトで直近の会話を継続
> qwen --continue --p "Show me our progress"
>
> # 会話選択画面を表示
> qwen --resume
>
> # 非対話モードで直近の会話を継続
> qwen --continue --p "Run the tests again"
> ```

## Git worktrees を使用して並列で Qwen Code セッションを実行する

複数のタスクを同時に処理し、Qwen Code インスタンス間でコードを完全に分離する必要があるとします。

**1. Git worktrees の理解**

Git worktrees を使用すると、同じリポジトリから複数のブランチを別々のディレクトリにチェックアウトできます。各 worktree は独立したファイルを持つ作業ディレクトリを持ちながら、同じ Git 履歴を共有します。詳細については、[公式 Git worktree ドキュメント](https://git-scm.com/docs/git-worktree)をご確認ください。

**2. 新しい worktree の作成**

```bash

# 新しいブランチで新しい worktree を作成
git worktree add ../project-feature-a -b feature-a

# または既存のブランチで worktree を作成
git worktree add ../project-bugfix bugfix-123
```

これにより、リポジトリの別の作業コピーを持つ新しいディレクトリが作成されます。

**3. 各 worktree で Qwen Code を実行する**

```bash

# worktree に移動
cd ../project-feature-a

# この隔離された環境で Qwen コードを実行する
qwen
```

**4. 別のワークツリーで Qwen コードを実行する**

```bash
cd ../project-bugfix
qwen
```

**5. ワークツリーを管理する**

```bash

# すべてのワークツリーをリスト表示
git worktree list

# 作業が終わったらワークツリーを削除する
git worktree remove ../project-feature-a
```

> [!tip]
>
> - 各ワークツリーは独立したファイル状態を持っているため、並列で Qwen Code セッションを行うのに最適です
> - あるワークツリーで行った変更は他のワークツリーに影響を与えないため、Qwen Code インスタンス同士の干渉を防ぐことができます
> - すべてのワークツリーは同じ Git 履歴とリモート接続を共有します
> - 長期間実行されるタスクでは、あるワークツリーで Qwen Code を動作させながら、別のワークツリーで開発を続けることができます
> - 各ワークツリーがどのタスク用であるかを簡単に識別できるように、わかりやすいディレクトリ名を使用してください
> - 新しいワークツリーを作成する際には、プロジェクトの設定に従って開発環境を初期化することを忘れないでください。スタックによって異なりますが、以下のような処理が必要になる場合があります：
>   - JavaScript プロジェクト：依存関係のインストール（`npm install`、`yarn`）
>   - Python プロジェクト：仮想環境のセットアップまたはパッケージマネージャーでのインストール
>   - その他の言語：プロジェクトの標準的なセットアッププロセスに従う

## Qwen Code を Unix スタイルのユーティリティとして使用する

### 検証プロセスに Qwen Code を追加する

Qwen Code をリンターやコードレビュアーとして使用したいとします。

**ビルドスクリプトに Qwen Code を追加:**

```json
// package.json
{
    ...
    "scripts": {
        ...
        "lint:Qwen Code": "qwen -p 'you are a linter. please look at the changes vs. main and report any issues related to typos. report the filename and line number on one line, and a description of the issue on the second line. do not return any other text.'"
    }
}
```

> [!tip]
>
> - CI/CD パイプラインで自動コードレビューに Qwen Code を使用する
> - プロジェクトに関連する特定の問題をチェックするためにプロンプトをカスタマイズする
> - 異なる種類の検証用に複数のスクリプトを作成することを検討する

### Pipe in, pipe out

Qwen Code にデータをパイプで入力し、構造化された形式でデータを取得したい場合を想定します。

**Qwen Code を通じてデータをパイプする:**

```bash
cat build-error.txt | qwen -p 'concisely explain the root cause of this build error' > output.txt
```

> [!tip]
>
> - パイプを使用して Qwen-Code を既存のシェルスクリプトに統合する
> - 他の Unix ツールと組み合わせて強力なワークフローを実現する
> - 構造化出力のために --output-format の使用を検討する

### 出力形式の制御

Qwen Code の出力を特定の形式で取得する必要がある場合、特にスクリプトや他のツールに Qwen Code を組み込む際には以下のようにします。

**1. テキスト形式を使用（デフォルト）**

```bash
cat data.txt | qwen -p 'summarize this data' --output-format text > summary.txt
```

これは Qwen Code のプレーンテキスト応答のみを出力します（デフォルト動作）。

**2. JSON 形式を使用**

```bash
cat code.py | qwen -p 'analyze this code for bugs' --output-format json > analysis.json
```

これにより、コストや処理時間などのメタデータを含むメッセージの JSON 配列が出力されます。

**3. ストリーミング JSON 形式を使用**

```bash
cat log.txt | qwen -p 'parse this log file for errors' --output-format stream-json
```

これにより、Qwen Code がリクエストを処理する際にリアルタイムで一連の JSON オブジェクトが出力されます。各メッセージは有効な JSON オブジェクトですが、全体を連結したものは有効な JSON ではありません。

> [!tip]
>
> - Qwen Code の応答だけが必要なシンプルな統合には `--output-format text` を使用
> - 完全な会話ログが必要な場合は `--output-format json` を使用
> - 各会話のターンをリアルタイムで出力するには `--output-format stream-json` を使用

## Qwen Codeの機能について質問する

Qwen Codeはドキュメントに組み込まれたアクセス権を持っており、自身の機能や制限についての質問に答えることができます。

### 質問例

```
Qwen Codeはプルリクエストを作成できますか？
```

```
Qwen Codeはどのようにパーミッションを処理しますか？
```

```
利用可能なスラッシュコマンドは何ですか？
```

```
MCPをQwen Codeで使用するにはどうすればよいですか？
```

```
Amazon Bedrock用にQwen Codeを設定するにはどうすればよいですか？
```

```
Qwen Codeの制限は何ですか？
```

> [!note]
>
> Qwen Codeはこれらの質問に対してドキュメントに基づいた回答を提供します。実行可能な例やハンズオンデモンストレーションについては、上記の特定のワークフローセクションを参照してください。

> [!tip]
>
> - Qwen Codeは使用しているバージョンに関係なく、常に最新のQwen Codeドキュメントにアクセスできます
> - 詳細な回答を得るには具体的な質問をしてください
> - Qwen CodeはMCP統合、エンタープライズ構成、高度なワークフローなどの複雑な機能を説明できます