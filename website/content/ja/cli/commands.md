# CLI コマンド

Qwen Code は、セッションの管理、インターフェースのカスタマイズ、およびその動作を制御するためのいくつかの組み込みコマンドをサポートしています。これらのコマンドには、スラッシュ (`/`)、アットマーク (`@`)、または感嘆符 (`!`) のプレフィックスが付きます。

## スラッシュコマンド (`/`)

スラッシュコマンドは、CLI 自体に対するメタレベルの制御を提供します。

```markdown
### 組み込みコマンド

- **`/bug`**
  - **説明:** Qwen Codeに関するissueを提出します。デフォルトでは、GitHubのQwen Codeリポジトリ内にissueが作成されます。`/bug`の後に記述した文字列は、そのバグレポートのタイトルになります。このデフォルトの動作は、`.qwen/settings.json`ファイル内の`advanced.bugCommand`設定で変更できます。

- **`/chat`**
  - **説明:** 対話的に会話履歴を保存・再開し、分岐した会話状態を管理したり、以前のセッションから再開できます。
  - **サブコマンド:**
    - **`save`**
      - **説明:** 現在の会話履歴を保存します。会話状態を識別するために`<tag>`を指定する必要があります。
      - **使用方法:** `/chat save <tag>`
      - **チェックポイントの保存場所詳細:** チャットチェックポイントのデフォルト保存場所は以下の通りです：
        - Linux/macOS: `~/.qwen/tmp/<project_hash>/`
        - Windows: `C:\Users\<YourUsername>\.qwen\tmp\<project_hash>\`
        - `/chat list`を実行すると、CLIはこれらのディレクトリのみをスキャンして利用可能なチェックポイントを探します。
        - **注意:** これらのチェックポイントは手動での保存・再開用です。ファイル変更前に自動生成されるチェックポイントについては、[Checkpointing documentation](../checkpointing.md)をご参照ください。
    - **`resume`**
      - **説明:** 前回保存された会話を再開します。
      - **使用方法:** `/chat resume <tag>`
    - **`list`**
      - **説明:** 再開可能なチャット状態のタグ一覧を表示します。
    - **`delete`**
      - **説明:** 保存された会話チェックポイントを削除します。
      - **使用方法:** `/chat delete <tag>`
    - **`share`**
      - **説明:** 現在の会話を指定されたMarkdownまたはJSONファイルに書き出します。
      - **使用方法:** `/chat share file.md` または `/chat share file.json`。ファイル名が指定されない場合、CLIが自動生成します。

- **`/clear`**
  - **説明:** ターミナル画面をクリアし、CLI上の表示履歴とスクロールバックを消去します。実装によっては履歴データ自体は保持される場合がありますが、画面上からは消えます。
  - **キーボードショートカット:** いつでも**Ctrl+L**を押すことで画面をクリアできます。

- **`/summary`**
  - **説明:** 現在の会話履歴から包括的なプロジェクトサマリーを生成し、`.qwen/PROJECT_SUMMARY.md`に保存します。このサマリーには全体の目標、重要な知識、最近のアクション、現在の計画が含まれており、将来のセッションで作業を再開するのに最適です。
  - **使用方法:** `/summary`
  - **機能:**
    - 全会話履歴を解析して重要なコンテキストを抽出
    - 目標、知識、アクション、計画のセクションを持つ構造化されたMarkdownサマリーを作成
    - 自動的にプロジェクトルートの`.qwen/PROJECT_SUMMARY.md`に保存
    - 生成および保存中に進行状況インジケーターを表示
    - Welcome Back機能と統合してシームレスなセッション再開を実現
  - **注意:** このコマンドを使用するには、最低でも2件以上のメッセージを含む有効な会話が必要です。

- **`/compress`**
  - **説明:** チャットコンテキスト全体をサマリーに置き換えます。これにより、今後のタスクで使用するトークン数を節約しつつ、これまでの内容の高レベルな要約を維持できます。

- **`/copy`**
  - **説明:** Qwen Codeが最後に出力した内容をクリップボードにコピーし、共有や再利用を容易にします。

- **`/directory`**（または**`/dir`**）
  - **説明:** 複数ディレクトリ対応のワークスペースディレクトリを管理します。
  - **サブコマンド:**
    - **`add`**:
      - **説明:** ワークスペースにディレクトリを追加します。パスは絶対パスまたは現在の作業ディレクトリからの相対パスを指定できます。ホームディレクトリからの相対指定も可能です。
      - **使用方法:** `/directory add <path1>,<path2>`
      - **注意:** 制限付きサンドボックスプロファイルでは無効です。その場合は、セッション開始時に`--include-directories`オプションを使用してください。
    - **`show`**:
      - **説明:** `/directory add`および`--include-directories`で追加されたすべてのディレクトリを表示します。
      - **使用方法:** `/directory show`

- **`/editor`**
  - **説明:** サポートされているエディタを選択するダイアログを開きます。

- **`/extensions`**
  - **説明:** 現在のQwen Codeセッションで有効になっている拡張機能の一覧を表示します。詳しくは[Qwen Code Extensions](../extension.md)をご参照ください。

- **`/help`**（または**`/?`**）
  - **説明:** 利用可能なコマンドとその使用方法を含む、Qwen Codeに関するヘルプ情報を表示します。

- **`/mcp`**
  - **説明:** 設定済みのModel Context Protocol (MCP)サーバー、接続状態、サーバー詳細、利用可能なツールを一覧表示します。
  - **サブコマンド:**
    - **`desc`** または **`descriptions`**:
      - **説明:** MCPサーバーおよびツールの詳細な説明を表示します。
    - **`nodesc`** または **`nodescriptions`**:
      - **説明:** ツールの説明を非表示にして、ツール名のみを表示します。
    - **`schema`**:
      - **説明:** ツールの設定パラメータに関する完全なJSONスキーマを表示します。
  - **キーボードショートカット:** いつでも**Ctrl+T**を押すことで、ツールの説明表示/非表示を切り替えられます。

- **`/memory`**
  - **説明:** AIの指示コンテキスト（デフォルトでは`QWEN.md`ファイルから読み込まれる階層型メモリ；`contextFileName`で設定可能）を管理します。
  - **サブコマンド:**
    - **`add`**:
      - **説明:** 指定したテキストをAIのメモリに追加します。使用方法：`/memory add <記憶させたいテキスト>`
    - **`show`**:
      - **説明:** すべてのコンテキストファイル（例：`QWEN.md`）から読み込まれた現在の階層型メモリの内容を表示します。モデルに提供されている指示コンテキストを確認できます。
    - **`refresh`**:
      - **説明:** 設定された場所（グローバル、プロジェクト/祖先、サブディレクトリ）にあるすべてのコンテキストファイル（デフォルト：`QWEN.md`）から階層型指示メモリを再読み込みします。これにより、モデルに最新のコンテキスト内容が反映されます。
    - **注意:** コンテキストファイルが階層型メモリにどのように寄与するかの詳細については、[CLI Configuration documentation](./configuration.md#context-files-hierarchical-instructional-context)をご参照ください。

- **`/model`**
  - **説明:** 現在のセッションで使用するモデルを切り替えます。認証タイプに基づいて選択可能なモデルの一覧を表示するダイアログを開きます。
  - **使用方法:** `/model`
  - **機能:**
    - 現在の認証タイプに対応するすべてのモデルを表示
    - モデルの説明と能力（例：visionサポート）を表示
    - 現在のセッションのみでモデルを変更
    - Qwenモデル（OAuth経由）とOpenAIモデル（APIキー経由）の両方をサポート
  - **利用可能なモデル:**
    - **Qwen Coder:** Alibaba Cloud ModelStudioの最新Qwen Coderモデル（バージョン：qwen3-coder-plus-2025-09-23）
    - **Qwen Vision:** Alibaba Cloud ModelStudioの最新Qwen Visionモデル（バージョン：qwen3-vl-plus-2025-09-23）- 画像分析をサポート
    - **OpenAI Models:** OpenAI認証を使用している場合に利用可能（`OPENAI_MODEL`環境変数で設定）
  - **注意:** モデル選択はセッション固有であり、異なるQwen Codeセッション間では保持されません。デフォルトモデルを設定するには、設定ファイルの`model.name`を使用してください。

- **`/restore`**
  - **説明:** ツール実行直前のプロジェクトファイルの状態に復元します。これは、ツールによるファイル編集を元に戻す際に特に便利です。ツール呼び出しIDなしで実行すると、復元可能なチェックポイントの一覧が表示されます。
  - **使用方法:** `/restore [tool_call_id]`
  - **注意:** CLIが`--checkpointing`オプションで起動された場合、または[settings](./configuration.md)で設定されている場合にのみ使用可能です。詳細は[Checkpointing documentation](../checkpointing.md)をご参照ください。

- **`/settings`**
  - **説明:** Qwen Codeの設定を表示・変更するための設定エディタを開きます。
  - **詳細:** このコマンドは、Qwen Codeの動作と外観を制御する設定を変更するためのユーザーフレンドリーなインターフェースを提供します。`.qwen/settings.json`ファイルを手動で編集するのと同等ですが、エラー防止のためにバリデーションとガイダンスが組み込まれています。
  - **使用方法:** 単純に`/settings`を実行するとエディタが開きます。そこから特定の設定を検索・閲覧し、現在の値を確認して必要に応じて変更できます。一部の設定は即時適用されますが、他の設定は再起動が必要です。

- **`/stats`**
  - **説明:** 現在のQwen Codeセッションの詳細な統計情報を表示します。これにはトークン使用量、キャッシュされたトークンの節約量（利用可能な場合）、セッション時間などが含まれます。注意：キャッシュされたトークン情報は、APIキー認証では表示されますが、OAuth認証では現時点では表示されません。

- [**`/theme`**](./themes.md)
  - **説明:** Qwen Codeの視覚テーマを変更できるダイアログを開きます。

- **`/auth`**
  - **説明:** 認証方法を変更できるダイアログを開きます。

- **`/approval-mode`**
  - **説明:** ツール使用時の承認モードを変更します。
  - **使用方法:** `/approval-mode [mode] [--session|--project|--user]`
  - **利用可能なモード:**
    - **`plan`**: 解析のみ；ファイル変更やコマンド実行はしない
    - **`default`**: ファイル編集やシェルコマンドには承認が必要
    - **`auto-edit`**: ファイル編集を自動承認
    - **`yolo`**: すべてのツールを自動承認
  - **例:**
    - `/approval-mode plan --project`（このプロジェクトでplanモードを永続化）
    - `/approval-mode yolo --user`（ユーザー全体でYOLOモードを永続化）

- **`/about`**
  - **説明:** バージョン情報を表示します。issueを提出する際はこの情報を共有してください。

- **`/agents`**
  - **説明:** 特定のタスクに特化したAIサブエージェントを管理します。サブエージェントは特定の専門知識とツールアクセス権を持つ独立したAIアシスタントです。
  - **サブコマンド:**
    - **`create`**:
      - **説明:** 新しいサブエージェントを作成するためのインタラクティブウィザードを起動します。ウィザードでは場所選択、AIによるプロンプト生成、ツール選択、ビジュアルカスタマイズをガイドします。
      - **使用方法:** `/agents create`
    - **`manage`**:
      - **説明:** 既存のサブエージェントを表示・編集・削除するためのインタラクティブ管理ダイアログを開きます。プロジェクトレベルとユーザーレベルのエージェントの両方を表示します。
      - **使用方法:** `/agents manage`
  - **保存場所:**
    - **プロジェクトレベル:** `.qwen/agents/`（チームで共有、優先度高）
    - **ユーザーレベル:** `~/.qwen/agents/`（個人用エージェント、プロジェクト間で利用可能）
  - **注意:** サブエージェントの作成・管理の詳細については、[Subagents documentation](../subagents.md)をご参照ください。

- [**`/tools`**](../tools/index.md)
  - **説明:** Qwen Code内で現在利用可能なツールの一覧を表示します。
  - **使用方法:** `/tools [desc]`
  - **サブコマンド:**
    - **`desc`** または **`descriptions`**:
      - **説明:** 各ツールの詳細な説明を表示します。各ツールの名前とモデルに提供される完全な説明を含みます。
    - **`nodesc`** または **`nodescriptions`**:
      - **説明:** ツールの説明を非表示にして、ツール名のみを表示します。

- **`/quit-confirm`**
  - **説明:** Qwen Codeを終了する前に確認ダイアログを表示し、現在のセッションをどう扱うか選択できるようにします。
  - **使用方法:** `/quit-confirm`
  - **機能:**
    - **すぐに終了:** 何も保存せずに終了（`/quit`と同等）
    - **サマリー生成後終了:** 終了前に`/summary`を使用してプロジェクトサマリーを作成
    - **会話保存後終了:** 現在の会話を自動生成されたタグで保存してから終了
  - **キーボードショートカット:** **Ctrl+C**を2回押すことで終了確認ダイアログを起動
  - **注意:** Ctrl+Cを1回押すと自動的にこのコマンドが起動され、誤って終了することを防ぐ安全機構として機能します。

- **`/quit`**（または**`/exit`**）
  - **説明:** 確認ダイアログなしでQwen Codeを即座に終了します。

- **`/vim`**
  - **説明:** vimモードのオン/オフを切り替えます。vimモードが有効になると、入力エリアでNORMALモードとINSERTモードの両方でvimスタイルのナビゲーションと編集コマンドがサポートされます。
  - **機能:**
    - **NORMALモード:** `h`, `j`, `k`, `l`で移動；`w`, `b`, `e`で単語単位移動；`0`, `$`, `^`で行頭/行末/最初の非空白文字へ移動；`G`（または`gg`で先頭行）で指定行へ移動
    - **INSERTモード:** 標準的なテキスト入力で、EscでNORMALモードに戻る
    - **編集コマンド:** `x`で削除、`c`で変更、`i`, `a`, `o`, `O`で挿入；`dd`, `cc`, `dw`, `cw`などの複雑な操作
    - **カウントサポート:** コマンドの前に数字を付ける（例：`3h`, `5w`, `10G`）
    - **最後の

### カスタムコマンド

すぐに始めるには、以下の[例](#example-a-pure-function-refactoring-command)を参照してください。

カスタムコマンドを使用すると、お気に入りや最もよく使うプロンプトをQwen Code内でパーソナルなショートカットとして保存・再利用できます。単一のプロジェクトに特化したコマンドや、すべてのプロジェクトでグローバルに利用可能なコマンドを作成でき、ワークフローを効率化し、一貫性を保つことができます。

#### ファイルの場所と優先順位

Qwen Code は以下の2つの場所からコマンドを読み込み、特定の順序でロードします：

1.  **ユーザーコマンド（グローバル）：** `~/.qwen/commands/` に配置されます。これらのコマンドは、作業中のすべてのプロジェクトで利用可能です。
2.  **プロジェクトコマンド（ローカル）：** `<your-project-root>/.qwen/commands/` に配置されます。これらのコマンドは現在のプロジェクト専用であり、バージョン管理に含めてチームと共有することができます。

プロジェクトディレクトリ内のコマンドが、ユーザーディレクトリ内のコマンドと同じ名前を持っている場合、**プロジェクトコマンドが常に使用されます。** これにより、プロジェクト固有のバージョンでグローバルコマンドを上書きできます。

#### コマンド名とネームスペース

コマンドの名前は、そのファイルが存在する `commands` ディレクトリからの相対パスに基づいて決定されます。サブディレクトリを使用することで、ネームスペースを持ったコマンドを作成でき、パス区切り文字（`/` または `\`）はコロン（`:`）に変換されます。

- `~/.qwen/commands/test.toml` にあるファイルは、コマンド `/test` になります。
- `<project>/.qwen/commands/git/commit.toml` にあるファイルは、ネームスペース付きコマンド `/git:commit` になります。

#### TOML ファイル形式 (v1)

コマンド定義ファイルは TOML 形式で記述し、拡張子は `.toml` を使用してください。

##### 必須フィールド

- `prompt` (String): コマンド実行時にモデルに送信されるプロンプト。単一行または複数行の文字列を指定できます。

##### オプションフィールド

- `description` (String): コマンドの機能を示す短い説明文（1行）。このテキストは `/help` メニューでコマンドの横に表示されます。**このフィールドを省略した場合、ファイル名から汎用的な説明が自動生成されます。**

#### 引数の処理

カスタムコマンドでは、引数を処理するための2つの強力な方法がサポートされています。CLIは、コマンドの`prompt`の内容に基づいて、自動的に正しい方法を選択します。

##### 1. `{{args}}`によるコンテキスト対応型注入

`prompt`に特殊プレースホルダー`{{args}}`が含まれている場合、CLIはそのプレースホルダーをユーザーがコマンド名の後にタイプしたテキストに置き換えます。

この注入の動作は、使用場所によって異なります：

**A. 生の注入（Shellコマンド外）**

プロンプトの本文で使用される場合、引数はユーザーがタイプした通りに正確に注入されます。

**例（`git/fix.toml`）：**

```toml

```markdown
# 実行方法: /git:fix "ボタンの位置がずれている"

description = "指定された問題に対する修正を生成します。"
prompt = "こちらで説明されている問題に対するコード修正を提供してください: {{args}}."
```

モデルへの入力: `こちらで説明されている問題に対するコード修正を提供してください: "ボタンの位置がずれている"`

**B. シェルコマンド内での引数の使用（`!{...}` ブロック内）**

シェルインジェクションブロック（`!{...}`）内で `{{args}}` を使う場合、引数は置換前に自動的に**シェルエスケープ**されます。これにより、シェルコマンドに安全に引数を渡すことができ、結果として生成されるコマンドが構文的に正しく、かつセキュアであることを保証しつつ、コマンドインジェクションの脆弱性を防ぎます。

**例（`/grep-code.toml`）:**

```toml
prompt = """
パターン `{{args}}` に関する調査結果を要約してください。

検索結果:
!{grep -r {{args}} .}
"""
```

`/grep-code It's complicated` を実行したとき:

1. CLIは `{{args}}` が `!{...}` の外と中で使われていることを検出します。
2. 外側: 最初の `{{args}}` はそのまま `It's complicated` に置換されます。
3. 内側: 2番目の `{{args}}` はエスケープされたバージョン（例：Linuxでは `"It's complicated"`）に置換されます。
4. 実行されるコマンドは `grep -r "It's complicated" .` になります。
5. CLIはこの正確で安全なコマンドを実行前に確認を求めます。
6. 最終的なプロンプトが送信されます。
```

##### 2. デフォルトの引数処理

あなたの `prompt` に特別なプレースホルダー `{{args}}` が含まれて**いない**場合、CLI は引数を処理するためのデフォルトの動作を使用します。

コマンドに引数を指定した場合（例：`/mycommand arg1`）、CLI はあなたが入力したコマンド全体をプロンプトの末尾に2つの改行で区切って追加します。これにより、モデルは元の指示とあなたが提供した具体的な引数の両方を見ることができます。

引数を指定**しなかった**場合（例：`/mycommand`）、プロンプトはそのまま何も追加されずにモデルに送信されます。

**例（`changelog.toml`）：**

この例では、モデルの役割を定義し、ユーザーの入力を見つける場所を説明し、期待される形式と動作を指定することで、堅牢なコマンドを作成する方法を示しています。

```toml

# In: <project>/.qwen/commands/changelog.toml

```markdown
# 実行方法: /changelog 1.2.0 added "デフォルト引数解析のサポート"

description = "プロジェクトの CHANGELOG.md ファイルに新しいエントリを追加します。"
prompt = """

# タスク: Changelog の更新

あなたはこのソフトウェアプロジェクトのエキスパートメンテナーです。ユーザーが changelog に新しいエントリを追加するコマンドを実行しました。

**ユーザーの生のコマンドが以下の指示の後に添付されています。**

あなたのタスクは、入力から `<version>`、`<change_type>`、`<message>` を解析し、`write_file` ツールを使用して `CHANGELOG.md` ファイルを正しく更新することです。

## 期待されるフォーマット
コマンドは以下のフォーマットに従います: `/changelog <version> <type> <message>`
- `<type>` は以下のいずれかでなければなりません: "added", "changed", "fixed", "removed"
```

```markdown
## 挙動
1. `CHANGELOG.md` ファイルを読み込む。
2. 指定された `<version>` のセクションを探す。
3. 正しい `<type>` 見出しの下に `<message>` を追加する。
4. バージョンまたはタイプのセクションが存在しない場合は、新たに作成する。
5. "Keep a Changelog" 形式に厳密に従う。

/changelog 1.2.0 added "New feature" を実行すると、モデルに送信される最終的なテキストは、元のプロンプトに続けて2つの改行と入力したコマンドとなる。
```

##### 3. `!{...}` を使用したシェルコマンドの実行

`prompt` 内で直接シェルコマンドを実行し、その出力を注入することで、コマンドを動的にすることができます。これは、ファイルの内容を読み込んだり、Git のステータスを確認したりといったローカル環境からのコンテキスト収集に最適です。

カスタムコマンドがシェルコマンドの実行を試みると、Qwen Code は処理を進める前に確認ダイアログを表示するようになりました。これは意図しないコマンドが実行されないようにするためのセキュリティ対策です。

**仕組み:**

1.  **コマンドの注入:** `!{...}` 構文を使用します。
2.  **引数の置換:** ブロック内で `{{args}}` が存在する場合、自動的にシェルエスケープされます（上記の [Context-Aware Injection](#1-context-aware-injection-with-args) を参照）。
3.  **堅牢なパース:** パーサーは、JSON ペイロードなどの中括弧がネストされた複雑なシェルコマンドも正しく処理できます。**注意:** `!{...}` 内のコンテンツには、開き中括弧（`{`）と閉じ中括弧（`}`）の数が一致している必要があります。一致しない中括弧を含むコマンドを実行したい場合は、外部スクリプトファイルにラップして、そのスクリプトを `!{...}` ブロック内で呼び出すことを検討してください。
4.  **セキュリティチェックと確認:** CLI は、引数がエスケープおよび置換された後の最終的なコマンドに対してセキュリティチェックを実行します。ダイアログには、実行されるコマンドが正確に表示されます。
5.  **実行とエラー報告:** コマンドが実行されます。コマンドが失敗した場合、プロンプトに注入される出力には、エラーメッセージ（stderr）とその後に続くステータス行（例: `[Shell command exited with code 1]`）が含まれます。これにより、モデルは失敗のコンテキストを理解できます。

**例 (`git/commit.toml`):**

このコマンドは、ステージングされた git diff を取得し、それを使用してモデルにコミットメッセージを作成させます。

````toml

# In: <project>/.qwen/commands/git/commit.toml

# Invoked via: /git:commit

description = "ステージされた変更に基づいて Git のコミットメッセージを生成します。"

# プロンプトでは !{...} を使用してコマンドを実行し、その出力を挿入しています。
prompt = """
以下の git diff に基づいた Conventional Commit メッセージを生成してください：

```diff
!{git diff --staged}
```

"""

````

`/git:commit` を実行すると、CLI はまず `git diff --staged` を実行し、次に `!{git diff --staged}` をそのコマンドの出力で置換して、最終的な完全なプロンプトをモデルに送信します。

##### 4. `@{...}` を使用したファイル内容の注入

`@{...}` 構文を使用して、ファイルの内容やディレクトリ内のファイル一覧を直接プロンプトに埋め込むことができます。これは特定のファイルを操作するコマンドを作成する際に便利です。

**動作方法:**

- **ファイルの注入**: `@{path/to/file.txt}` は `file.txt` の内容に置き換えられます。
- **マルチモーダル対応**: パスがサポートされている画像（例：PNG、JPEG）、PDF、音声、動画ファイルを指している場合、それらは適切にエンコードされ、マルチモーダル入力として注入されます。その他のバイナリファイルは適切に処理され、スキップされます。
- **ディレクトリ一覧**: `@{path/to/dir}` は再帰的に探索され、そのディレクトリおよびすべてのサブディレクトリ内にある各ファイルがプロンプトに挿入されます。`.gitignore` と `.qwenignore` が有効な場合はこれらも尊重されます。
- **ワークスペース対応**: コマンドは現在のディレクトリおよびその他のワークスペースディレクトリ内でパスを検索します。ワークスペース内であれば絶対パスも使用可能です。
- **処理順序**: `@{...}` によるファイル内容の注入は、シェルコマンド（`!{...}`）や引数の置換（`{{args}}`）より**前**に処理されます。
- **パース処理**: パーサーは `@{...}` 内の内容（パス）について、波括弧（`{` と `}`）が正しく対応していることを要求します。

**例（`review.toml`）:**

このコマンドでは、固定されたベストプラクティスファイル（`docs/best-practices.md`）の内容を注入し、ユーザーの引数を使ってレビューのコンテキストを提供しています。

```toml

```toml
# パス: <project>/.qwen/commands/review.toml

# 実行方法: /review FileCommandLoader.ts

description = "提供されたコンテキストをベストプラクティスガイドを使ってレビューします。"
prompt = """
あなたはエキスパートコードレビュアーです。

あなたのタスクは {{args}} をレビューすることです。

レビューを行う際には、以下のベストプラクティスを参照してください：

@{docs/best-practices.md}
"""
```

`/review FileCommandLoader.ts` を実行すると、`@{docs/best-practices.md}` の部分にはそのファイルの内容が、`{{args}}` の部分にはあなたが入力したテキストがそれぞれ置き換えられ、最終的なプロンプトがモデルに送信されます。

---

#### 例: 「純粋関数」リファクタリングコマンド

コードの一部をリファクタリングするようモデルに指示するグローバルコマンドを作成してみましょう。

**1. ファイルとディレクトリの作成:**

まず、ユーザーのコマンドディレクトリが存在することを確認し、次に整理のために `refactor` サブディレクトリと最終的な TOML ファイルを作成します。

```bash
mkdir -p ~/.qwen/commands/refactor
touch ~/.qwen/commands/refactor/pure.toml
```

**2. ファイルに内容を追加:**

エディタで `~/.qwen/commands/refactor/pure.toml` を開き、以下の内容を追加してください。ここでは、ベストプラクティスとして任意の `description` を含めています。

```toml

# In: ~/.qwen/commands/refactor/pure.toml

```markdown
# このコマンドは以下のように実行されます: /refactor:pure

description = "モデルに現在のコンテキストを純粋関数にリファクタリングするよう要求します。"

prompt = """
現在のコンテキストで提供されたコードを分析してください。
それを純粋関数にリファクタリングしてください。

あなたのレスポンスには以下を含めてください:
1. リファクタリングされた純粋関数のコードブロック。
2. あなたが行った主要な変更と、なぜそれが純粋性に貢献するのかについての簡単な説明。
"""
```

**3. コマンドを実行:**

以上です！CLIでコマンドを実行できるようになりました。まず、コンテキストにファイルを追加し、それからコマンドを実行してください:

```
> @my-messy-function.js
> /refactor:pure
```

Qwen Codeは、TOMLファイルで定義された複数行のプロンプトを実行します。
```

## 入力プロンプトのショートカット

これらのショートカットは、テキスト操作のために入力プロンプトに直接適用されます。

- **元に戻す (Undo):**
  - **キーボードショートカット:** 入力プロンプトで最後のアクションを元に戻すには、**Ctrl+z** を押してください。

- **やり直し (Redo):**
  - **キーボードショートカット:** 入力プロンプトで最後に元に戻したアクションをやり直すには、**Ctrl+Shift+Z** を押してください。

## At コマンド (`@`)

At コマンドは、ファイルやディレクトリの内容をプロンプトに含めるために使用されます。これらのコマンドには Git を意識したフィルタリング機能が含まれています。

- **`@<ファイルまたはディレクトリへのパス>`**
  - **説明:** 指定されたファイルまたは複数のファイルの内容を現在のプロンプトに挿入します。特定のコードやテキスト、あるいはファイル群について質問する際に便利です。
  - **例:**
    - `@path/to/your/file.txt このテキストを説明してください。`
    - `@src/my_project/ このディレクトリ内のコードを要約してください。`
    - `このファイルは何についてですか？ @README.md`
  - **詳細:**
    - 単一のファイルパスが指定された場合、そのファイルの内容が読み込まれます。
    - ディレクトリパスが指定された場合、そのディレクトリおよびサブディレクトリ内のファイルの内容を読み込もうとします。
    - パスにスペースが含まれる場合は、バックスラッシュでエスケープしてください（例: `@My\ Documents/file.txt`）。
    - 内部的には `read_many_files` ツールを使用しています。内容が取得され、クエリに挿入されてからモデルに送信されます。
    - **Git を意識したフィルタリング:** デフォルトでは、Git で無視されるファイル（`node_modules/`、`dist/`、`.env`、`.git/` など）は除外されます。この動作は `context.fileFiltering` 設定で変更できます。
    - **ファイルタイプ:** このコマンドは主にテキストベースのファイルを対象としています。バイナリファイルや非常に大きなファイルは、パフォーマンスと関連性を保つため、`read_many_files` ツールによってスキップまたは切り捨てられることがあります。ツールはファイルがスキップされたかどうかを示します。
  - **出力:** CLI には `read_many_files` が使用されたことを示すツール呼び出しメッセージと、処理されたパスおよびステータスの詳細が表示されます。

- **`@`（単独の @ シンボル）**
  - **説明:** パスなしで単独の `@` シンボルを入力すると、クエリはそのままモデルに渡されます。プロンプト内で `@` シンボル自体について話す場合に役立ちます。

### `@` コマンドのエラーハンドリング

- `@` の後に指定されたパスが見つからない、または無効な場合、エラーメッセージが表示され、クエリはモデルに送信されないか、ファイル内容なしで送信されることがあります。
- `read_many_files` ツールがエラー（例：権限の問題）に遭遇した場合も、その旨が報告されます。

## Shell モードとパススルー コマンド（`!`）

`!` プレフィックスを使用すると、Qwen Code 内から直接システムのシェルとやり取りできます。

- **`!<shell_command>`**
  - **説明:** Linux/macOS では `bash` を使用し、Windows では `cmd.exe` を使用して、指定された `<shell_command>` を実行します。コマンドからの出力やエラーはすべてターミナルに表示されます。
  - **例:**
    - `!ls -la`（`ls -la` を実行し、Qwen Code に戻る）
    - `!git status`（`git status` を実行し、Qwen Code に戻る）

- **`!`（Shell モードの切り替え）**
  - **説明:** 単独で `!` と入力すると、Shell モードが切り替わります。
    - **Shell モードに入る:**
      - アクティブになると、Shell モードでは別のカラー設定と「Shell モードインジケーター」が使用されます。
      - Shell モード中に入力したテキストは、すべて直接シェル コマンドとして解釈されます。
    - **Shell モードを抜ける:**
      - 抜けると UI は標準の外観に戻り、通常の Qwen Code の動作が再開されます。

- **すべての `!` 使用時の注意:** Shell モードで実行するコマンドは、端末で直接実行する場合と同じ権限と影響を持ちます。

- **環境変数:** `!` 経由または Shell モードでコマンドが実行されると、サブプロセスの環境に `QWEN_CODE=1` 環境変数が設定されます。これにより、スクリプトやツールが CLI 内から実行されているかどうかを検出できます。