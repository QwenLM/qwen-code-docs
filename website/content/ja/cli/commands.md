# CLI Commands

Qwen Code では、セッションの管理、インターフェースのカスタマイズ、およびその動作を制御するための複数の組み込みコマンドがサポートされています。これらのコマンドは、スラッシュ (`/`)、アットマーク (`@`)、または感嘆符 (`!`) を接頭辞として使用します。

## スラッシュコマンド (`/`)

スラッシュコマンドは、CLI 自体に対するメタレベルの制御を提供します。

### 組み込みコマンド

- **`/bug`**
  - **説明:** Qwen Codeに関するissueを提出します。デフォルトでは、GitHubのQwen Codeリポジトリ内にissueが作成されます。`/bug`の後に続く文字列は、提出されるバグのタイトルになります。デフォルトの`/bug`の動作は、`.qwen/settings.json`ファイル内の`bugCommand`設定で変更できます。

- **`/chat`**
  - **説明:** 対話的に会話履歴を保存・再開し、分岐した会話状態を管理したり、以前のセッションから状態を再開できます。
  - **サブコマンド:**
    - **`save`**
      - **説明:** 現在の会話履歴を保存します。会話状態を識別するために`<tag>`を指定する必要があります。
      - **使用方法:** `/chat save <tag>`
      - **チェックポイントの保存場所:** 保存されたチャットチェックポイントのデフォルトの場所は以下の通りです：
        - Linux/macOS: `~/.config/google-generative-ai/checkpoints/`
        - Windows: `C:\Users\<YourUsername>\AppData\Roaming\google-generative-ai\checkpoints\`
        - `/chat list`を実行すると、CLIはこれらのディレクトリのみをスキャンして利用可能なチェックポイントを検索します。
        - **注意:** これらのチェックポイントは、手動で会話状態を保存・再開するためのものです。ファイル変更前に自動的に作成されるチェックポイントについては、[チェックポイントに関するドキュメント](../checkpointing.md)を参照してください。
    - **`resume`**
      - **説明:** 以前に保存した会話を再開します。
      - **使用方法:** `/chat resume <tag>`
    - **`list`**
      - **説明:** 再開可能なチャット状態のタグを一覧表示します。
    - **`delete`**
      - **説明:** 保存された会話チェックポイントを削除します。
      - **使用方法:** `/chat delete <tag>`

- **`/clear`**
  - **説明:** CLI内の表示履歴とスクロールバックを含む、ターミナル画面全体をクリアします。実装によっては、履歴の呼び出し用にセッションデータが保持される場合がありますが、視覚的な表示はクリアされます。
  - **キーボードショートカット:** **Ctrl+L**を押すと、いつでもクリア操作を実行できます。

- **`/compress`**
  - **説明:** チャットの全コンテキストを要約に置き換えます。これにより、将来のタスクで使用されるトークンを節約しつつ、これまでの会話内容の概要を保持できます。

- **`/copy`**
  - **説明:** Qwen Codeが最後に出力した内容をクリップボードにコピーし、共有や再利用を容易にします。

- **`/directory`** (または **`/dir`**)
  - **説明:** 複数ディレクトリ対応のワークスペースディレクトリを管理します。
  - **サブコマンド:**
    - **`add`**:
      - **説明:** ワークスペースにディレクトリを追加します。パスは絶対パスでも、現在の作業ディレクトリからの相対パスでも指定できます。また、ホームディレクトリからの相対パスもサポートされています。
      - **使用方法:** `/directory add <path1>,<path2>`
      - **注意:** 制限付きサンドボックスプロファイルでは無効です。その場合、セッション開始時に`--include-directories`オプションを使用してください。
    - **`show`**:
      - **説明:** `/directory add`および`--include-directories`で追加されたすべてのディレクトリを表示します。
      - **使用方法:** `/directory show`

- **`/directory`** (または **`/dir`**)
  - **説明:** 複数ディレクトリ対応のワークスペースディレクトリを管理します。
  - **サブコマンド:**
    - **`add`**:
      - **説明:** ワークスペースにディレクトリを追加します。パスは絶対パスでも、現在の作業ディレクトリからの相対パスでも指定できます。また、ホームディレクトリからの相対パスもサポートされています。
      - **使用方法:** `/directory add <path1>,<path2>`
      - **注意:** 制限付きサンドボックスプロファイルでは無効です。その場合、セッション開始時に`--include-directories`オプションを使用してください。
    - **`show`**:
      - **説明:** `/directory add`および`--include-directories`で追加されたすべてのディレクトリを表示します。
      - **使用方法:** `/directory show`

- **`/editor`**
  - **説明:** サポートされているエディタを選択するダイアログを開きます。

- **`/extensions`**
  - **説明:** 現在のQwen Codeセッションでアクティブなすべての拡張機能を一覧表示します。詳細は[Qwen Code Extensions](../extension.md)を参照してください。

- **`/help`** (または **`/?`**)
  - **説明:** 利用可能なコマンドとその使用方法を含む、Qwen Codeに関するヘルプ情報を表示します。

- **`/mcp`**
  - **説明:** 設定されたModel Context Protocol (MCP)サーバー、その接続状態、サーバーの詳細、および利用可能なツールを一覧表示します。
  - **サブコマンド:**
    - **`desc`** または **`descriptions`**:
      - **説明:** MCPサーバーとツールの詳細な説明を表示します。
    - **`nodesc`** または **`nodescriptions`**:
      - **説明:** ツールの説明を非表示にし、ツール名のみを表示します。
    - **`schema`**:
      - **説明:** ツールの設定パラメータの完全なJSONスキーマを表示します。
  - **キーボードショートカット:** **Ctrl+T**を押すと、ツールの説明の表示/非表示を切り替えることができます。

- **`/memory`**
  - **説明:** AIの指示コンテキスト（デフォルトでは`QWEN.md`ファイルから読み込まれる階層メモリ；`contextFileName`で設定可能）を管理します。
  - **サブコマンド:**
    - **`add`**:
      - **説明:** 次のテキストをAIのメモリに追加します。使用方法: `/memory add <記憶するテキスト>`
    - **`show`**:
      - **説明:** すべてのコンテキストファイル（例：`QWEN.md`）から読み込まれた現在の階層メモリの完全な内容を表示します。これにより、モデルに提供されている指示コンテキストを確認できます。
    - **`refresh`**:
      - **説明:** 設定された場所（グローバル、プロジェクト/祖先、およびサブディレクトリ）にあるすべてのコンテキストファイル（デフォルト：`QWEN.md`）から階層的な指示メモリを再読み込みします。これにより、モデルに最新のコンテキスト内容が反映されます。
    - **注意:** コンテキストファイルが階層メモリにどのように寄与するかの詳細については、[CLI Configuration documentation](./configuration.md#context-files-hierarchical-instructional-context)を参照してください。

- **`/restore`**
  - **説明:** ツールが実行される直前のプロジェクトファイルの状態に復元します。これは、ツールによって行われたファイル編集を元に戻すのに特に便利です。ツール呼び出しIDなしで実行された場合、復元可能なチェックポイントの一覧が表示されます。
  - **使用方法:** `/restore [tool_call_id]`
  - **注意:** CLIが`--checkpointing`オプションで起動された場合、または[settings](./configuration.md)で設定されている場合にのみ使用可能です。詳細は[Checkpointing documentation](../checkpointing.md)を参照してください。

- **`/settings`**
  - **説明:** Qwen Codeの設定を表示・変更するための設定エディタを開きます。
  - **詳細:** このコマンドは、Qwen Codeの動作や外観を制御する設定を変更するためのユーザーフレンドリーなインターフェースを提供します。`.qwen/settings.json`ファイルを手動で編集するのと同等ですが、エラーを防ぐために検証とガイダンスが提供されます。
  - **使用方法:** 単に`/settings`を実行すると、エディタが開きます。そこから特定の設定を閲覧・検索し、現在の値を確認し、必要に応じて変更できます。一部の設定は即座に反映されますが、他の設定は再起動が必要です。

- **`/stats`**
  - **説明:** 現在のQwen Codeセッションの詳細な統計情報を表示します。これには、トークン使用量、キャッシュされたトークンの節約量（利用可能な場合）、セッションの継続時間などが含まれます。注意：キャッシュされたトークン情報は、APIキー認証時にトークンが使用されている場合にのみ表示され、現在のところOAuth認証では表示されません。

- [**`/theme`**](./themes.md)
  - **説明:** Qwen Codeの視覚的なテーマを変更できるダイアログを開きます。

- **`/auth`**
  - **説明:** 認証方法を変更できるダイアログを開きます。

- **`/about`**
  - **説明:** バージョン情報を表示します。issueを提出する際は、この情報を共有してください。

- [**`/tools`**](../tools/index.md)
  - **説明:** 現在Qwen Code内で利用可能なツールの一覧を表示します。
  - **サブコマンド:**
    - **`desc`** または **`descriptions`**:
      - **説明:** 各ツールの詳細な説明を表示します。これには、モデルに提供された各ツールの名前と完全な説明が含まれます。
    - **`nodesc`** または **`nodescriptions`**:
      - **説明:** ツールの説明を非表示にし、ツール名のみを表示します。

- **`/privacy`**
  - **説明:** プライバシー通知を表示し、ユーザーがサービス改善の目的でデータ収集に同意するかどうかを選択できるようにします。

- **`/quit`** (または **`/exit`**)
  - **説明:** Qwen Codeを終了します。

- **`/vim`**
  - **説明:** vimモードのオン/オフを切り替えます。vimモードが有効になると、入力エリアでNORMALモードとINSERTモードの両方でvimスタイルのナビゲーションと編集コマンドがサポートされます。
  - **機能:**
    - **NORMALモード:** `h`, `j`, `k`, `l`で移動；`w`, `b`, `e`で単語単位のジャンプ；`0`, `$`, `^`で行の先頭/末尾に移動；`G`（または`gg`で最初の行）で特定の行に移動
    - **INSERTモード:** 標準的なテキスト入力で、エスケープキーでNORMALモードに戻る
    - **編集コマンド:** `x`で削除、`c`で変更、`i`, `a`, `o`, `O`で挿入；`dd`, `cc`, `dw`, `cw`などの複雑な操作
    - **カウントサポート:** コマンドの前に数字を付ける（例：`3h`, `5w`, `10G`）
    - **最後のコマンドの繰り返し:** `.`で最後の編集操作を繰り返す
    - **永続設定:** vimモードの設定は`~/.qwen/settings.json`に保存され、セッション間で復元されます
  - **ステータス表示:** 有効時、フッターに`[NORMAL]`または`[INSERT]`が表示されます

- **`/init`**
  - **説明:** 現在のディレクトリを分析し、デフォルトで`QWEN.md`コンテキストファイル（または`contextFileName`で指定されたファイル名）を作成します。空でないファイルが既に存在する場合は、変更は行われません。このコマンドは空のファイルを作成し、モデルにプロジェクト固有の指示を入力するよう促します。

### カスタムコマンド

すぐに始めるには、以下の[例](#example-a-pure-function-refactoring-command)を参照してください。

カスタムコマンドを使用すると、お気に入りやよく使うプロンプトを Qwen Code 内で個人用のショートカットとして保存・再利用できます。1つのプロジェクト専用のコマンドや、すべてのプロジェクトでグローバルに利用可能なコマンドを作成でき、ワークフローを効率化し、一貫性を保つことができます。

#### ファイルの場所と優先順位

Qwen Code は、以下の2つの場所からコマンドを読み込み、特定の順序でロードします：

1.  **ユーザー コマンド (グローバル):** `~/.qwen/commands/` に配置されます。これらのコマンドは、作業中のすべてのプロジェクトで利用可能です。
2.  **プロジェクト コマンド (ローカル):** `<your-project-root>/.qwen/commands/` に配置されます。これらのコマンドは現在のプロジェクト専用であり、バージョン管理に含めてチームと共有できます。

プロジェクトディレクトリ内のコマンドとユーザーディレクトリ内のコマンドで名前が同じ場合、**プロジェクト コマンドが常に使用されます。** これにより、プロジェクト固有のバージョンでグローバル コマンドを上書きできます。

#### 命名と名前空間

コマンドの名前は、そのファイルが存在する `commands` ディレクトリからの相対パスに基づいて決定されます。サブディレクトリを使用することで名前空間付きコマンドを作成でき、パス区切り文字（`/` または `\`）はコロン（`:`）に変換されます。

- `~/.qwen/commands/test.toml` にあるファイルは、コマンド `/test` になります。
- `<project>/.qwen/commands/git/commit.toml` にあるファイルは、名前空間付きコマンド `/git:commit` になります。

#### TOML ファイル形式 (v1)

コマンド定義ファイルは TOML 形式で記述し、拡張子は `.toml` を使用する必要があります。

##### 必須フィールド

- `prompt` (String): コマンドが実行されたときにモデルに送信されるプロンプト。単一行または複数行の文字列を指定できます。

##### オプションフィールド

- `description` (String): コマンドの機能を示す短い一行の説明。このテキストは `/help` メニューでコマンドの横に表示されます。**このフィールドを省略すると、ファイル名から汎用的な説明が自動生成されます。**

#### 引数の処理

カスタムコマンドでは、引数を処理するための2つの強力で使いやすい方法がサポートされています。CLIは、コマンドの`prompt`の内容に基づいて、自動的に適切な方法を選択します。

##### 1. `{{args}}`による簡易的な注入

`prompt`に特別なプレースホルダー`{{args}}`が含まれている場合、CLIはそのプレースホルダーを、ユーザーがコマンド名の後にタイプしたすべてのテキストに置き換えます。これは、大きなpromptテンプレートの特定の場所にユーザー入力を注入する必要がある、シンプルで決定的なコマンドに最適です。

**例 (`git/fix.toml`):**

```toml

# In: ~/.qwen/commands/git/fix.toml

```markdown
# 実行方法: /git:fix "モバイルでボタンがずれている"

description = "指定された GitHub の issue に対する修正を生成します。"
prompt = "ステージされた git の変更を分析し、ここで説明されている issue に対するコード修正を提供してください: {{args}}."
```

モデルには最終的にこのようなプロンプトが送られます: `ステージされた git の変更を分析し、ここで説明されている issue に対するコード修正を提供してください: "モバイルでボタンがずれている"`。

##### 2. デフォルトの引数処理

あなたの `prompt` に特別なプレースホルダー `{{args}}` が含まれて**いない**場合、CLI は引数処理に対してデフォルトの動作を使用します。

コマンドに引数を指定した場合（例: `/mycommand arg1`）、CLI はあなたが入力したコマンド全体をプロンプトの末尾に2つの改行で区切って追加します。これにより、モデルは元の指示とあなたが指定した具体的な引数の両方を見ることができます。

引数を指定**しなかった**場合（例: `/mycommand`）、プロンプトはそのまま何も追加されずにモデルに送信されます。

**例 (`changelog.toml`):**

この例では、モデルの役割を定義し、ユーザーの入力を見つける場所を説明し、期待されるフォーマットと動作を指定することで、堅牢なコマンドを作成する方法を示しています。

```toml

# In: <project>/.qwen/commands/changelog.toml

# 呼び出し方法: /changelog 1.2.0 added "Support for default argument parsing."

description = "プロジェクトの CHANGELOG.md ファイルに新しいエントリを追加します。"
prompt = """

# タスク: Changelog の更新

あなたはこのソフトウェアプロジェクトのエキスパートメンテナーです。ユーザーが changelog に新しいエントリを追加するコマンドを実行しました。

**ユーザーの生のコマンドが以下の指示の後に追加されています。**

あなたのタスクは、入力から `<version>`、`<change_type>`、`<message>` を解析し、`write_file` ツールを使用して `CHANGELOG.md` ファイルを正しく更新することです。

## 期待されるフォーマット
コマンドは以下のフォーマットに従います: `/changelog <version> <type> <message>`
- `<type>` は以下のいずれかでなければなりません: "added", "changed", "fixed", "removed"。

```markdown
## 挙動
1. `CHANGELOG.md` ファイルを読み込む。
2. 指定された `<version>` のセクションを探す。
3. 正しい `<type>` 見出しの下に `<message>` を追加する。
4. バージョンまたはタイプのセクションが存在しない場合は、新たに作成する。
5. "Keep a Changelog" 形式に厳密に従う。

/changelog 1.2.0 added "New feature" を実行すると、モデルに送信される最終的なテキストは、元のプロンプトに続けて2つの改行と入力したコマンドとなる。
```

##### 3. `!{...}` による Shell コマンドの実行

`prompt` 内で直接 Shell コマンドを実行し、その出力を注入することで、コマンドを動的にすることができます。これは、ファイルの内容を読み込んだり、Git のステータスを確認するなど、ローカル環境からのコンテキストを収集するのに最適です。

カスタムコマンドが Shell コマンドの実行を試みると、Qwen Code は処理を進める前に確認ダイアログを表示するようになりました。これは、意図しないコマンドが実行されないようにするためのセキュリティ対策です。

**仕組み:**

1.  **コマンドの挿入:** `prompt` 内で `!{...}` 構文を使用して、コマンドを実行する場所とその出力の挿入位置を指定します。
2.  **実行確認:** コマンド実行時、プロンプトが実行しようとしている Shell コマンドの一覧を表示するダイアログが表示されます。
3.  **許可の選択:** 以下の選択肢から選ぶことができます：
    - **1回だけ許可:** 今回のみコマンドを実行します。
    - **このセッションでは常に許可:** 現在の CLI セッション中は、このコマンドを一時的な許可リストに追加し、再度確認を求められることはありません。
    - **いいえ:** Shell コマンドの実行をキャンセルします。

CLI は引き続きグローバル設定の `excludeTools` および `coreTools` を尊重します。設定で明示的に禁止されているコマンドは、確認ダイアログを表示せずにブロックされます。

**例 (`git/commit.toml`):**

このコマンドは、ステージングされた Git の差分を取得し、それを使用してモデルにコミットメッセージを作成させます。

````toml

# In: <project>/.qwen/commands/git/commit.toml

# Invoked via: /git:commit

description = "ステージされた変更に基づいて Git のコミットメッセージを生成します。"

# prompt では !{...} を使用してコマンドを実行し、その出力を挿入しています。
prompt = """
以下の git diff に基づいて、Conventional Commit メッセージを生成してください:

```diff
!{git diff --staged}
```

"""

````

`/git:commit` を実行すると、CLI はまず `git diff --staged` を実行し、次にそのコマンドの出力で `!{git diff --staged}` を置換して、最終的な完全な prompt をモデルに送信します。

---

#### 例: 「純粋関数」リファクタリングコマンド

コードの一部をリファクタリングするようモデルに指示するグローバルコマンドを作成してみましょう。

**1. ファイルとディレクトリの作成:**

まず、ユーザーのコマンドディレクトリが存在することを確認し、次に整理のための `refactor` サブディレクトリと最終的な TOML ファイルを作成します。

```bash
mkdir -p ~/.qwen/commands/refactor
touch ~/.qwen/commands/refactor/pure.toml
```

**2. ファイルに内容を追加:**

エディタで `~/.qwen/commands/refactor/pure.toml` を開き、以下の内容を追加します。ここでは、ベストプラクティスとして任意の `description` を含めています。

```toml

# In: ~/.qwen/commands/refactor/pure.toml

```markdown
# このコマンドは以下のように実行されます: /refactor:pure

description = "現在のコンテキストにあるコードを、モデルにpure functionへとリファクタリングするよう指示します。"

prompt = """
現在のコンテキストで提供されたコードを分析してください。
それをpure functionにリファクタリングしてください。

あなたのレスポンスには以下を含めてください:
1. リファクタリングされたpure functionのコードブロック。
2. あなたが加えた主要な変更点と、それがなぜpure functionに寄与するのかについての簡単な説明。
"""
```

**3. コマンドを実行する:**

以上です！CLIでコマンドを実行できるようになりました。まず、コンテキストにファイルを追加し、それからコマンドを実行してください:

```
> @my-messy-function.js
> /refactor:pure
```

Qwen Codeは、TOMLファイルで定義された複数行のプロンプトを実行します。
```

## At コマンド (`@`)

At コマンドは、ファイルやディレクトリの内容をプロンプトの一部としてモデルに渡すために使用されます。これらのコマンドには Git を意識したフィルタリング機能が含まれています。

- **`@<path_to_file_or_directory>`**
  - **説明:** 指定したファイルまたは複数のファイルの内容を現在のプロンプトに挿入します。特定のコードやテキスト、ファイル群について質問する際に便利です。
  - **例:**
    - `@path/to/your/file.txt Explain this text.`
    - `@src/my_project/ Summarize the code in this directory.`
    - `What is this file about? @README.md`
  - **詳細:**
    - 単一のファイルパスが指定された場合、そのファイルの内容が読み込まれます。
    - ディレクトリパスが指定された場合、そのディレクトリおよびサブディレクトリ内のファイル内容を読み込もうとします。
    - パスにスペースが含まれる場合はバックスラッシュでエスケープしてください（例: `@My\ Documents/file.txt`）。
    - 内部的には `read_many_files` ツールを使用しています。内容が取得された後、クエリに挿入されてからモデルに送信されます。
    - **Git を意識したフィルタリング:** デフォルトでは、Git で無視されるファイル（`node_modules/`、`dist/`、`.env`、`.git/` など）は除外されます。この動作は `fileFiltering` 設定で変更可能です。
    - **ファイルタイプ:** このコマンドは主にテキストベースのファイルを対象としています。バイナリファイルや非常に大きなファイルは、パフォーマンスと関連性を保つために `read_many_files` ツールによってスキップまたは切り捨てられる可能性があります。ツールはファイルがスキップされた場合にその旨を示します。
  - **出力:** CLI には `read_many_files` が使用されたことを示すツール呼び出しメッセージと、処理されたパスおよびステータスの詳細が表示されます。

- **`@`（単独の @ 記号）**
  - **説明:** パスなしで単独の `@` 記号を入力した場合、クエリはそのままモデルに渡されます。プロンプト内で `@` 記号そのものについて話す場合に便利です。

### `@` コマンドのエラーハンドリング

- `@` の後に指定されたパスが見つからない、または無効な場合、エラーメッセージが表示され、クエリはモデルに送信されないか、ファイル内容なしで送信されることがあります。
- `read_many_files` ツールがエラー（例：権限の問題）に遭遇した場合も、その旨が報告されます。

## Shell モードとパススルー コマンド (`!`)

`!` プレフィックスを使用すると、Qwen Code 内から直接システムのシェルとやり取りできます。

- **`!<shell_command>`**
  - **説明:** Linux/macOS では `bash`、Windows では `cmd.exe` を使用して、指定された `<shell_command>` を実行します。コマンドからの出力やエラーはすべてターミナルに表示されます。
  - **例:**
    - `!ls -la` (`ls -la` を実行して Qwen Code に戻る)
    - `!git status` (`git status` を実行して Qwen Code に戻る)

- **`!` (Shell モードの切り替え)**
  - **説明:** 単独で `!` と入力すると、Shell モードを切り替えます。
    - **Shell モードに入る:**
      - 有効になると、Shell モードでは別のカラー表示と「Shell モード インジケーター」が使用されます。
      - Shell モード中は、入力したテキストが直接シェル コマンドとして解釈されます。
    - **Shell モードを抜ける:**
      - 抜けると、UI は標準の外観に戻り、通常の Qwen Code の動作が再開されます。

- **すべての `!` 使用時の注意:** Shell モードで実行するコマンドは、ターミナルで直接実行する場合と同じ権限と影響を持ちます。

- **環境変数:** `!` 経由または Shell モードでコマンドが実行されると、サブプロセスの環境に `QWEN_CODE=1` 環境変数が設定されます。これにより、スクリプトやツールが CLI 内から実行されているかどうかを検出できます。