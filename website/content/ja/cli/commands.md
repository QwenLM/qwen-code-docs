# CLI コマンド

Qwen Code では、セッションの管理、インターフェースのカスタマイズ、およびその動作を制御するための複数の組み込みコマンドがサポートされています。これらのコマンドは、スラッシュ記号（`/`）、アットマーク（`@`）、または感嘆符（`!`）で始まります。

## スラッシュコマンド（`/`）

スラッシュコマンドは、CLI 自体に対するメタレベルの操作を提供します。

### 組み込みコマンド

- **`/bug`**
  - **説明:** Qwen Codeに関するissueを提出します。デフォルトでは、GitHubのQwen Codeリポジトリ内にissueが作成されます。`/bug`の後に記述した文字列が、提出されるバグのタイトルになります。デフォルトの`/bug`の動作は、`.qwen/settings.json`ファイル内の`bugCommand`設定で変更できます。

- **`/chat`**
  - **説明:** 対話的に会話履歴を保存・再開し、分岐した会話状態を維持したり、以前の状態を別のセッションから再開できます。
  - **サブコマンド:**
    - **`save`**
      - **説明:** 現在の会話履歴を保存します。会話状態を識別するために`<tag>`を指定する必要があります。
      - **使用方法:** `/chat save <tag>`
      - **チェックポイントの保存場所に関する詳細:** 保存されたチャットチェックポイントのデフォルトの場所は以下の通りです：
        - Linux/macOS: `~/.qwen/tmp/<project_hash>/`
        - Windows: `C:\Users\<YourUsername>\.qwen\tmp\<project_hash>\`
        - `/chat list`を実行すると、CLIはこれらの特定のディレクトリのみをスキャンして利用可能なチェックポイントを検索します。
        - **注意:** これらのチェックポイントは、手動で会話状態を保存・再開するためのものです。ファイル変更前に自動的に作成されるチェックポイントについては、[Checkpointing documentation](../checkpointing.md)を参照してください。
    - **`resume`**
      - **説明:** 以前に保存した会話状態を再開します。
      - **使用方法:** `/chat resume <tag>`
    - **`list`**
      - **説明:** 再開可能なチャット状態のタグを一覧表示します。
    - **`delete`**
      - **説明:** 保存された会話チェックポイントを削除します。
      - **使用方法:** `/chat delete <tag>`

- **`/clear`**
  - **説明:** CLI内の表示履歴とスクロールバックを含む、ターミナル画面全体をクリアします。実装によっては履歴の元データが保持される場合がありますが、視覚的な表示はクリアされます。
  - **キーボードショートカット:** いつでも**Ctrl+L**を押すことでクリア操作を実行できます。

- **`/summary`**
  - **説明:** 現在の会話履歴から包括的なプロジェクトサマリーを生成し、`.qwen/PROJECT_SUMMARY.md`に保存します。このサマリーには全体の目標、重要な知識、最近のアクション、現在の計画が含まれており、将来のセッションで作業を再開するのに最適です。
  - **使用方法:** `/summary`
  - **機能:**
    - 全会話履歴を分析して重要なコンテキストを抽出
    - 目標、知識、アクション、計画のセクションを持つ構造化されたMarkdownサマリーを作成
    - プロジェクトルートの`.qwen/PROJECT_SUMMARY.md`に自動保存
    - 生成および保存中に進行状況インジケーターを表示
    - Welcome Back機能と統合してシームレスなセッション再開を実現
  - **注意:** このコマンドを使用するには、最低でも2つのメッセージを含むアクティブな会話が必要です。

- **`/compress`**
  - **説明:** チャットコンテキスト全体をサマリーに置き換えます。これにより、将来のタスクで使用されるトークンを節約しつつ、これまでの出来事の高レベルなサマリーを保持できます。

- **`/copy`**
  - **説明:** Qwen Codeが最後に出力した内容をクリップボードにコピーし、共有や再利用を容易にします。

- **`/directory`** (または **`/dir`**)
  - **説明:** 複数ディレクトリ対応のワークスペースディレクトリを管理します。
  - **サブコマンド:**
    - **`add`**:
      - **説明:** ワークスペースにディレクトリを追加します。パスは絶対パスでも、現在の作業ディレクトリからの相対パスでも指定できます。また、ホームディレクトリからの参照もサポートされています。
      - **使用方法:** `/directory add <path1>,<path2>`
      - **注意:** 制限付きサンドボックスプロファイルでは無効です。その場合、セッション開始時に`--include-directories`を使用してください。
    - **`show`**:
      - **説明:** `/directory add`および`--include-directories`で追加されたすべてのディレクトリを表示します。
      - **使用方法:** `/directory show`

- **`/directory`** (または **`/dir`**)
  - **説明:** 複数ディレクトリ対応のワークスペースディレクトリを管理します。
  - **サブコマンド:**
    - **`add`**:
      - **説明:** ワークスペースにディレクトリを追加します。パスは絶対パスでも、現在の作業ディレクトリからの相対パスでも指定できます。また、ホームディレクトリからの参照もサポートされています。
      - **使用方法:** `/directory add <path1>,<path2>`
      - **注意:** 制限付きサンドボックスプロファイルでは無効です。その場合、セッション開始時に`--include-directories`を使用してください。
    - **`show`**:
      - **説明:** `/directory add`および`--include-directories`で追加されたすべてのディレクトリを表示します。
      - **使用方法:** `/directory show`

- **`/editor`**
  - **説明:** サポートされているエディタを選択するためのダイアログを開きます。

- **`/extensions`**
  - **説明:** 現在のQwen Codeセッションでアクティブなすべての拡張機能を一覧表示します。詳細は[Qwen Code Extensions](../extension.md)を参照してください。

- **`/help`** (または **`/?`**)
  - **説明:** 利用可能なコマンドとその使用方法を含む、Qwen Codeに関するヘルプ情報を表示します。

- **`/mcp`**
  - **説明:** 設定されたModel Context Protocol (MCP)サーバー、その接続状態、サーバー詳細、利用可能なツールを一覧表示します。
  - **サブコマンド:**
    - **`desc`** または **`descriptions`**:
      - **説明:** MCPサーバーとツールの詳細な説明を表示します。
    - **`nodesc`** または **`nodescriptions`**:
      - **説明:** ツールの説明を非表示にし、ツール名のみを表示します。
    - **`schema`**:
      - **説明:** ツールの設定パラメータの完全なJSONスキーマを表示します。
  - **キーボードショートカット:** いつでも**Ctrl+T**を押すことで、ツールの説明の表示/非表示を切り替えられます。

- **`/memory`**
  - **説明:** AIの指示コンテキスト（デフォルトでは`QWEN.md`ファイルから読み込まれる階層メモリ；`contextFileName`で設定可能）を管理します。
  - **サブコマンド:**
    - **`add`**:
      - **説明:** 以下のテキストをAIのメモリに追加します。使用方法: `/memory add <記憶するテキスト>`
    - **`show`**:
      - **説明:** すべてのコンテキストファイル（例：`QWEN.md`）から読み込まれた現在の階層メモリの完全な内容を表示します。これにより、モデルに提供されている指示コンテキストを確認できます。
    - **`refresh`**:
      - **説明:** 設定された場所（グローバル、プロジェクト/祖先、サブディレクトリ）にあるすべてのコンテキストファイル（デフォルト：`QWEN.md`）から階層的な指示メモリを再読み込みします。これにより、モデルに最新のコンテキスト内容が反映されます。
    - **注意:** コンテキストファイルが階層メモリにどのように寄与するかの詳細については、[CLI Configuration documentation](./configuration.md#context-files-hierarchical-instructional-context)を参照してください。

- **`/restore`**
  - **説明:** ツールが実行される直前のプロジェクトファイルの状態に復元します。これは、ツールによって行われたファイル編集を元に戻すのに特に便利です。ツール呼び出しIDなしで実行された場合、復元可能なチェックポイントの一覧が表示されます。
  - **使用方法:** `/restore [tool_call_id]`
  - **注意:** CLIが`--checkpointing`オプションで起動された場合、または[settings](./configuration.md)で設定されている場合にのみ使用可能です。詳細は[Checkpointing documentation](../checkpointing.md)を参照してください。

- **`/settings`**
  - **説明:** Qwen Codeの設定を表示・変更するための設定エディタを開きます。
  - **詳細:** このコマンドは、Qwen Codeの動作や外観を制御する設定を変更するためのユーザーフレンドリーなインターフェースを提供します。これは`.qwen/settings.json`ファイルを手動で編集するのと同等ですが、エラーを防ぐための検証とガイダンスが含まれています。
  - **使用方法:** 単に`/settings`を実行するとエディタが開きます。そこから特定の設定を閲覧・検索し、現在の値を確認し、必要に応じて変更できます。一部の設定は即座に反映されますが、他の設定は再起動が必要です。

- **`/stats`**
  - **説明:** 現在のQwen Codeセッションの詳細な統計情報を表示します。これにはトークン使用量、キャッシュされたトークンによる節約（利用可能な場合）、セッションの継続時間などが含まれます。注意：キャッシュされたトークン情報は、APIキー認証でトークンが使用されている場合にのみ表示され、現在のところOAuth認証では表示されません。

- [**`/theme`**](./themes.md)
  - **説明:** Qwen Codeの視覚的なテーマを変更するためのダイアログを開きます。

- **`/auth`**
  - **説明:** 認証方法を変更するためのダイアログを開きます。

- **`/approval-mode`**
  - **説明:** ツール使用の承認モードを変更します。
  - **使用方法:** `/approval-mode [mode] [--session|--project|--user]`
  - **利用可能なモード:**
    - **`plan`**: 分析のみ；ファイルの変更やコマンドの実行は行いません
    - **`default`**: ファイル編集やシェルコマンドには承認が必要
    - **`auto-edit`**: ファイル編集を自動的に承認
    - **`yolo`**: すべてのツールを自動的に承認
  - **例:**
    - `/approval-mode plan --project` (このプロジェクトでplanモードを永続化)
    - `/approval-mode yolo --user` (このユーザーのYOLOモードをプロジェクト間で永続化)

- **`/about`**
  - **説明:** バージョン情報を表示します。issueを提出する際はこの情報を共有してください。

- **`/agents`**
  - **説明:** 特定のタスクに特化したAIサブエージェントを管理します。サブエージェントは、特定の専門知識とツールアクセスで構成された独立したAIアシスタントです。
  - **サブコマンド:**
    - **`create`**:
      - **説明:** 新しいサブエージェントを作成するためのインタラクティブなウィザードを起動します。ウィザードでは、場所の選択、AIによるプロンプト生成、ツール選択、視覚的なカスタマイズをガイドします。
      - **使用方法:** `/agents create`
    - **`manage`**:
      - **説明:** 既存のサブエージェントを表示・編集・削除するためのインタラクティブな管理ダイアログを開きます。プロジェクトレベルとユーザーレベルのエージェントの両方を表示します。
      - **使用方法:** `/agents manage`
  - **保存場所:**
    - **プロジェクトレベル:** `.qwen/agents/` (チームで共有、優先される)
    - **ユーザーレベル:** `~/.qwen/agents/` (個人用エージェント、プロジェクト間で利用可能)
  - **注意:** サブエージェントの作成と管理の詳細については、[Subagents documentation](../subagents.md)を参照してください。

- [**`/tools`**](../tools/index.md)
  - **説明:** 現在Qwen Code内で利用可能なツールの一覧を表示します。
  - **使用方法:** `/tools [desc]`
  - **サブコマンド:**
    - **`desc`** または **`descriptions`**:
      - **説明:** 各ツールの詳細な説明を表示します。これには、モデルに提供される各ツールの名前と完全な説明が含まれます。
    - **`nodesc`** または **`nodescriptions`**:
      - **説明:** ツールの説明を非表示にし、ツール名のみを表示します。

- **`/privacy`**
  - **説明:** プライバシー通知を表示し、ユーザーがサービス改善の目的でデータ収集に同意するかどうかを選択できるようにします。

- **`/quit-confirm`**
  - **説明:** Qwen Codeを終了する前に確認ダイアログを表示し、現在のセッションをどのように処理するかを選択できるようにします。
  - **使用方法:** `/quit-confirm`
  - **機能:**
    - **即時終了:** 何も保存せずに終了（`/quit`と同等）
    - **サマリー生成後に終了:** 終了前に`/summary`を使用してプロジェクトサマリーを作成
    - **会話を保存して終了:** 現在の会話を自動生成されたタグで保存してから終了
  - **キーボードショートカット:** **Ctrl+C**を2回押すことで終了確認ダイアログを起動
  - **注意:** このコマンドはCtrl+Cを1回押したときに自動的に起動され、誤って終了することを防ぐための安全機構を提供します。

- **`/quit`** (または **`/exit`**)
  - **説明:** 確認ダイアログなしでQwen Codeを即座に終了します。

- **`/vim`**
  - **説明:** vimモードをオンまたはオフに切り替えます。vimモードが有効な場合、入力エリアはNORMALモードとINSERTモードの両方でvimスタイルのナビゲーションと編集コマンドをサポートします。
  - **機能:**
    - **NORMALモード:** `h`, `j`, `k`, `l`で移動；`w`, `b`, `e`で単語単位のジャンプ；`0`, `$`, `^`で行の先頭/末尾に移動；`G`（または`gg`で最初の行）で特定の行に移動
    - **INSERTモード:** 標準的なテキスト入力で、エスケープでNORMALモードに戻る
    - **編集コマンド:** `x`で削除、`c`で変更、`i`, `a`, `o`, `O`で挿入；`dd`, `cc`, `dw`, `cw`などの複雑な操作
    - **カウントサポート:** コマンドの前に数字を付ける（例：`3h`, `5w`, `10G`）
    - **最後のコマンドを繰り返す:** `.`で最後の編集操作を繰り返す
    - **永続的な設定:** Vimモードの設定は`~/.qwen/settings.json`に保存され、セッション

### カスタムコマンド

クイックスタートについては、以下の[例](#example-a-pure-function-refactoring-command)を参照してください。

カスタムコマンドを使用すると、お気に入りや最もよく使うプロンプトをQwen Code内でパーソナルなショートカットとして保存・再利用できます。単一のプロジェクトに特化したコマンドや、すべてのプロジェクトでグローバルに利用可能なコマンドを作成でき、ワークフローを効率化し、一貫性を確保できます。

#### ファイルの場所と優先順位

Qwen Code は以下の2つの場所からコマンドを読み込み、特定の順序でロードします：

1.  **ユーザー コマンド（グローバル）：** `~/.qwen/commands/` に配置されます。これらのコマンドは、作業中のすべてのプロジェクトで利用可能です。
2.  **プロジェクト コマンド（ローカル）：** `<your-project-root>/.qwen/commands/` に配置されます。これらのコマンドは現在のプロジェクト専用であり、バージョン管理に含めてチームと共有できます。

プロジェクトディレクトリ内のコマンドとユーザーディレクトリ内のコマンドで名前が同じ場合、**常にプロジェクト コマンドが使用されます。** これにより、プロジェクト固有のバージョンでグローバル コマンドを上書きできます。

#### コマンド名とネームスペース

コマンドの名前は、そのファイルが存在する `commands` ディレクトリからの相対パスに基づいて決定されます。サブディレクトリを使用することで、ネームスペース付きのコマンドを作成でき、パス区切り文字（`/` または `\`）はコロン（`:`）に変換されます。

- `~/.qwen/commands/test.toml` にあるファイルは、コマンド `/test` になります。
- `<project>/.qwen/commands/git/commit.toml` にあるファイルは、ネームスペース付きコマンド `/git:commit` になります。

#### TOML ファイル形式 (v1)

コマンド定義ファイルは TOML 形式で記述し、拡張子は `.toml` を使用してください。

##### 必須フィールド

- `prompt` (String): コマンド実行時にモデルに送信されるプロンプト。単一行または複数行の文字列を指定できます。

##### オプションフィールド

- `description` (String): コマンドの機能を説明する短い一行の説明文。このテキストは `/help` メニューでコマンドの横に表示されます。**このフィールドを省略した場合、ファイル名から汎用的な説明が自動生成されます。**

#### 引数の処理

カスタムコマンドでは、引数を処理するための2つの強力な方法がサポートされています。CLIは、コマンドの`prompt`の内容に基づいて、自動的に正しい方法を選択します。

##### 1. `{{args}}`によるコンテキスト対応の注入

`prompt`に特殊なプレースホルダー`{{args}}`が含まれている場合、CLIはそのプレースホルダーをユーザーがコマンド名の後にタイプしたテキストに置き換えます。

この注入の動作は、使用場所によって異なります：

**A. 生の注入（シェルコマンド外）**

プロンプトの本文で使用される場合、引数はユーザーがタイプした通りに正確に注入されます。

**例（`git/fix.toml`）：**

```toml

```markdown
# 実行方法: /git:fix "Button is misaligned"

description = "与えられた問題に対する修正を生成します。"
prompt = "ここに記述された問題に対するコード修正を提供してください: {{args}}。"
```

モデルが受け取る内容: `ここに記述された問題に対するコード修正を提供してください: "Button is misaligned"。`

**B. シェルコマンド内での引数の使用 (`!{...}` ブロック内)**

シェルインジェクションブロック (`!{...}`) 内で `{{args}}` を使用する場合、引数は置換前に自動的に **shell-escaped** されます。これにより、シェルコマンドに安全に引数を渡すことができ、結果として生成されるコマンドが構文的に正しく、かつコマンドインジェクション脆弱性を防ぎながらセキュアになります。

**例 (`/grep-code.toml`):**

```toml
prompt = """
パターン `{{args}}` の検索結果を要約してください。

検索結果:
!{grep -r {{args}} .}
"""
```

`/grep-code It's complicated` を実行すると:

1. CLI は `{{args}}` が `!{...}` の外と内の両方で使われていることを検出します。
2. 外側: 最初の `{{args}}` はそのまま `It's complicated` に置換されます。
3. 内側: 2つ目の `{{args}}` はエスケープされたバージョンに置換されます（例：Linuxでは `"It's complicated"`）。
4. 実行されるコマンドは `grep -r "It's complicated" .` になります。
5. CLI はこの正確で安全なコマンドを実行前に確認を求めます。
6. 最終的な prompt が送信されます。
```

##### 2. デフォルトの引数処理

あなたの `prompt` に特別なプレースホルダー `{{args}}` が含まれて**いない**場合、CLI は引数を処理するためのデフォルトの動作を使用します。

コマンドに引数を指定した場合（例：`/mycommand arg1`）、CLI はあなたが入力したコマンド全体をプロンプトの末尾に2つの改行で区切って追加します。これにより、モデルは元の指示とあなたが提供した特定の引数の両方を見ることができます。

引数を指定**しなかった**場合（例：`/mycommand`）、プロンプトはそのまま何も追加されずにモデルに送信されます。

**例（`changelog.toml`）：**

この例では、モデルの役割を定義し、ユーザーの入力を見つける場所を説明し、期待される形式と動作を指定することで、堅牢なコマンドを作成する方法を示しています。

```toml

# In: <project>/.qwen/commands/changelog.toml

```markdown
# 呼び出し方法: /changelog 1.2.0 added "デフォルト引数解析のサポート"

description = "プロジェクトの CHANGELOG.md ファイルに新しいエントリを追加します。"
prompt = """

# タスク: Changelog の更新

あなたはこのソフトウェアプロジェクトのエキスパートメンテナーです。ユーザーが changelog に新しいエントリを追加するコマンドを実行しました。

**ユーザーの生のコマンドが以下の指示の後に追加されています。**

あなたのタスクは、入力から `<version>`、`<change_type>`、`<message>` を解析し、`write_file` ツールを使用して `CHANGELOG.md` ファイルを正しく更新することです。

## 期待されるフォーマット
コマンドは以下のフォーマットに従います: `/changelog <version> <type> <message>`
- `<type>` は以下のいずれかでなければなりません: "added", "changed", "fixed", "removed"。
```

```markdown
## 挙動
1. `CHANGELOG.md` ファイルを読み込む。
2. 指定された `<version>` のセクションを探す。
3. 正しい `<type>` 見出しの下に `<message>` を追加する。
4. バージョンまたはタイプのセクションが存在しない場合は、新たに作成する。
5. "Keep a Changelog" 形式に厳密に従う。

/changelog 1.2.0 added "New feature" を実行すると、モデルに送信される最終的なテキストは、元のプロンプトに続けて2つの改行と入力したコマンドとなる。
```

##### 3. `!{...}` を使用した Shell コマンドの実行

`prompt` 内で直接 Shell コマンドを実行し、その出力を注入することで、コマンドを動的にすることができます。これは、ファイルの内容を読み込んだり、Git のステータスを確認したりといったローカル環境からのコンテキスト収集に最適です。

カスタムコマンドが Shell コマンドの実行を試みると、Qwen Code は処理を進める前に確認ダイアログを表示するようになりました。これは意図しないコマンドが実行されてしまうことを防ぐためのセキュリティ対策です。

**仕組み:**

1.  **コマンドの注入:** `!{...}` 構文を使用します。
2.  **引数の置換:** ブロック内で `{{args}}` が使われている場合、自動的に Shell エスケープされます（上記の [Context-Aware Injection](#1-context-aware-injection-with-args) を参照）。
3.  **堅牢なパース:** パーサーは、JSON ペイロードを含む複雑な Shell コマンドも正しく処理できます。**注意:** `!{...}` 内の内容は、括弧（`{` と `}`）がバランスよく閉じている必要があります。もし、対応が取れていない括弧を含むコマンドを実行したい場合は、外部スクリプトファイルにまとめて、そのスクリプトを `!{...}` ブロック内で呼び出すことを検討してください。
4.  **セキュリティチェックと確認:** CLI は、引数がエスケープ・置換された後の最終コマンドに対してセキュリティチェックを実施します。実行されるコマンドを正確に表示するダイアログが表示されます。
5.  **実行とエラー報告:** コマンドが実行されます。コマンドが失敗した場合、プロンプトに注入される出力にはエラーメッセージ（stderr）と、例えば `[Shell command exited with code 1]` のようなステータス行が含まれます。これにより、モデルはエラー発生時の状況を理解しやすくなります。

**例 (`git/commit.toml`):**

このコマンドは、ステージングされた Git の diff を取得し、それを元にモデルにコミットメッセージを作成させます。

````toml

# In: <project>/.qwen/commands/git/commit.toml

# Invoked via: /git:commit

description = "ステージされた変更に基づいて Git のコミットメッセージを生成します。"

# プロンプトでは !{...} を使用してコマンドを実行し、その出力を挿入しています。
prompt = """
以下の git diff に基づいて Conventional Commit メッセージを生成してください：

```diff
!{git diff --staged}
```

"""

````

`/git:commit` を実行すると、CLI はまず `git diff --staged` を実行し、次に `!{git diff --staged}` をそのコマンドの出力で置換してから、最終的な完全なプロンプトをモデルに送信します。

##### 4. `@{...}` によるファイル内容の注入

`@{...}` 構文を使用して、ファイルの内容やディレクトリのリストを直接プロンプトに埋め込むことができます。これは、特定のファイルを操作するコマンドを作成する際に便利です。

**動作方法:**

- **ファイルの注入**: `@{path/to/file.txt}` は `file.txt` の内容に置き換えられます。
- **マルチモーダル対応**: パスが対応する画像（例: PNG、JPEG）、PDF、音声、動画ファイルを指している場合、適切にエンコードされてマルチモーダル入力として注入されます。その他のバイナリファイルは適切に処理され、スキップされます。
- **ディレクトリリスト**: `@{path/to/dir}` は再帰的に探索され、そのディレクトリおよびすべてのサブディレクトリ内にある各ファイルがプロンプトに挿入されます。`.gitignore` および `.qwenignore` が有効な場合、これらは尊重されます。
- **ワークスペース対応**: コマンドは現在のディレクトリおよびその他のワークスペースディレクトリからパスを検索します。ワークスペース内であれば絶対パスも使用可能です。
- **処理順序**: `@{...}` によるファイル内容の注入は、シェルコマンド（`!{...}`）や引数の置換（`{{args}}`）より**前**に処理されます。
- **パース**: パーサーは `@{...}` 内の内容（パス）が対応する括弧（`{` と `}`）を持っていることを要求します。

**例 (`review.toml`):**

このコマンドは、**固定された**ベストプラクティスファイル（`docs/best-practices.md`）の内容を注入し、ユーザーの引数を使用してレビューのコンテキストを提供します。

```toml

```markdown
# 位置: <project>/.qwen/commands/review.toml

# 呼び出し方法: /review FileCommandLoader.ts

description = "提供されたコンテキストをベストプラクティスガイドを使ってレビューします。"
prompt = """
あなたはエキスパートコードレビュアーです。

あなたのタスクは {{args}} をレビューすることです。

レビューを行う際には、以下のベストプラクティスを使用してください：

@{docs/best-practices.md}
"""
```

`/review FileCommandLoader.ts` を実行すると、`@{docs/best-practices.md}` のプレースホルダーがそのファイルの内容に置き換えられ、`{{args}}` はあなたが提供したテキストに置き換えられます。その後、最終的なプロンプトがモデルに送信されます。

---

#### 例: 「Pure Function」リファクタリングコマンド

コードの一部をリファクタリングするようモデルに指示するグローバルコマンドを作成してみましょう。

**1. ファイルとディレクトリの作成:**

まず、ユーザーのコマンドディレクトリが存在することを確認し、次に整理のための `refactor` サブディレクトリと最終的な TOML ファイルを作成します。

```bash
mkdir -p ~/.qwen/commands/refactor
touch ~/.qwen/commands/refactor/pure.toml
```

**2. ファイルに内容を追加:**

エディタで `~/.qwen/commands/refactor/pure.toml` を開き、以下の内容を追加します。ここでは、ベストプラクティスとして任意の `description` を含めています。

```toml

# In: ~/.qwen/commands/refactor/pure.toml

```markdown
# このコマンドは以下のように実行されます: /refactor:pure

description = "現在のコンテキストにあるコードを、純粋関数にリファクタリングするようモデルに指示します。"

prompt = """
提供された現在のコンテキスト内のコードを分析してください。
それを純粋関数にリファクタリングしてください。

あなたのレスポンスには以下を含めてください:
1. リファクタリングされた純粋関数のコードブロック。
2. 純粋性にどのように寄与するかという観点から、行った主要な変更とその理由の簡単な説明。
"""
```

**3. コマンドを実行:**

以上です！CLIでコマンドを実行できるようになりました。まずコンテキストにファイルを追加し、それからコマンドを呼び出してください:

```
> @my-messy-function.js
> /refactor:pure
```

Qwen Code は、TOMLファイルで定義した複数行のプロンプトを実行します。
```

## At コマンド (`@`)

At コマンドは、ファイルやディレクトリの内容をプロンプトに含めるために使用されます。これらのコマンドには Git を意識したフィルタリング機能が含まれています。

- **`@<ファイルまたはディレクトリへのパス>`**
  - **説明:** 指定されたファイルまたは複数のファイルの内容を現在のプロンプトに挿入します。特定のコードやテキスト、あるいはファイル群について質問する際に便利です。
  - **例:**
    - `@path/to/your/file.txt このテキストを説明してください。`
    - `@src/my_project/ このディレクトリ内のコードを要約してください。`
    - `このファイルは何についてですか？ @README.md`
  - **詳細:**
    - 単一のファイルパスが指定された場合、そのファイルの内容が読み込まれます。
    - ディレクトリパスが指定された場合、そのディレクトリおよびサブディレクトリ内のファイルの内容を読み込もうとします。
    - パスにスペースが含まれる場合は、バックスラッシュでエスケープする必要があります（例: `@My\ Documents/file.txt`）。
    - 内部的には `read_many_files` ツールを使用しています。内容が取得され、クエリに挿入されてからモデルに送信されます。
    - **Git 対応フィルタリング:** デフォルトでは、Git で無視されるファイル（`node_modules/`、`dist/`、`.env`、`.git/` など）は除外されます。この動作は `fileFiltering` 設定で変更できます。
    - **ファイル形式:** このコマンドは主にテキストベースのファイルを対象としています。バイナリファイルや非常に大きなファイルは、パフォーマンスと関連性を保つため、`read_many_files` ツールによってスキップまたは切り捨てられる可能性があります。ツール側でファイルがスキップされたかどうかは表示されます。
  - **出力:** CLI 上では、`read_many_files` が使用されたことを示すツール呼び出しメッセージと、処理されたパスおよびステータスの詳細が表示されます。

- **`@`（単独の @ 記号）**
  - **説明:** パスなしで単独の `@` 記号を入力した場合、クエリはそのままモデルに渡されます。プロンプト内で `@` 記号自体について話したいケースで役立つかもしれません。

### `@` コマンドのエラーハンドリング

- `@` の後に指定されたパスが見つからない、または無効な場合、エラーメッセージが表示され、クエリはモデルに送信されないか、ファイル内容なしで送信されることがあります。
- `read_many_files` ツールがエラー（例：権限の問題）に遭遇した場合も、その旨が報告されます。

## Shell モードとパススルー コマンド（`!`）

`!` プレフィックスを使用すると、Qwen Code 内から直接システムのシェルとやり取りできます。

- **`!<shell_command>`**
  - **説明：** 指定した `<shell_command>` を、Linux/macOS では `bash`、Windows では `cmd.exe` を使用して実行します。コマンドからの出力やエラーはすべてターミナルに表示されます。
  - **例：**
    - `!ls -la` （`ls -la` を実行し、Qwen Code に戻る）
    - `!git status` （`git status` を実行し、Qwen Code に戻る）

- **`!`（Shell モードの切り替え）**
  - **説明：** 単独で `!` と入力すると、Shell モードを切り替えます。
    - **Shell モードに入る：**
      - 有効になると、Shell モードでは色分けが異なり、「Shell モードインジケーター」が表示されます。
      - Shell モード中に入力したテキストは、そのままシェル コマンドとして解釈されます。
    - **Shell モードを抜ける：**
      - 抜けると UI は標準の外観に戻り、通常の Qwen Code の動作に戻ります。

- **すべての `!` 使用時の注意点：** Shell モードで実行するコマンドは、ターミナルで直接実行する場合と同じ権限と影響を持ちます。

- **環境変数：** `!` 経由または Shell モードでコマンドが実行される際、サブプロセスの環境には `QWEN_CODE=1` 環境変数が設定されます。これにより、スクリプトやツールが CLI 内から実行されているかどうかを検出できます。