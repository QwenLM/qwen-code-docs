# CLI Commands

Qwen Code では、セッションの管理、インターフェースのカスタマイズ、およびその動作を制御するための複数の組み込みコマンドがサポートされています。これらのコマンドは、スラッシュ (`/`)、アットマーク (`@`)、または感嘆符 (`!`) を接頭辞として使用します。

## スラッシュコマンド (`/`)

スラッシュコマンドは、CLI 自体に対するメタレベルの制御を提供します。

```markdown
### 組み込みコマンド

- **`/bug`**
  - **説明:** Qwen Codeに関するissueを提出します。デフォルトでは、GitHubのQwen Codeリポジトリ内にissueが作成されます。`/bug`の後に記述した文字列が、提出されるバグのタイトルになります。`.qwen/settings.json`ファイル内の`bugCommand`設定により、デフォルトの`/bug`の動作を変更できます。

- **`/chat`**
  - **説明:** 対話的に会話履歴を保存・再開し、分岐した会話状態を管理したり、以前のセッションから状態を再開できます。
  - **サブコマンド:**
    - **`save`**
      - **説明:** 現在の会話履歴を保存します。会話状態を識別するために`<tag>`を指定する必要があります。
      - **使用方法:** `/chat save <tag>`
      - **チェックポイント保存場所の詳細:** 保存されたチャットチェックポイントのデフォルト保存場所は以下の通りです：
        - Linux/macOS: `~/.config/qwen-code/checkpoints/`
        - Windows: `C:\Users\<YourUsername>\AppData\Roaming\qwen-code\checkpoints\`
        - `/chat list`を実行すると、CLIはこれらのディレクトリのみをスキャンして利用可能なチェックポイントを検索します。
        - **注意:** これらのチェックポイントは、手動で会話状態を保存・再開するためのものです。ファイル変更前に自動作成されるチェックポイントについては、[Checkpointing documentation](../checkpointing.md)を参照してください。
    - **`resume`**
      - **説明:** 以前に保存した会話状態を再開します。
      - **使用方法:** `/chat resume <tag>`
    - **`list`**
      - **説明:** 再開可能なチャット状態のタグ一覧を表示します。
    - **`delete`**
      - **説明:** 保存された会話チェックポイントを削除します。
      - **使用方法:** `/chat delete <tag>`

- **`/clear`**
  - **説明:** CLI内の表示履歴とスクロールバックを含む、ターミナル画面全体をクリアします。実装によっては履歴データ自体は保持される場合がありますが、画面上の表示はクリアされます。
  - **キーボードショートカット:** いつでも**Ctrl+L**を押すことで画面をクリアできます。

- **`/summary`**
  - **説明:** 現在の会話履歴から包括的なプロジェクトサマリーを生成し、`.qwen/PROJECT_SUMMARY.md`に保存します。このサマリーには全体の目標、重要な知識、最近のアクション、現在の計画が含まれており、将来のセッションで作業を再開するのに最適です。
  - **使用方法:** `/summary`
  - **機能:**
    - 全会話履歴を解析して重要なコンテキストを抽出
    - 目標、知識、アクション、計画のセクションを持つ構造化されたMarkdownサマリーを作成
    - プロジェクトルートの`.qwen/PROJECT_SUMMARY.md`に自動保存
    - 生成・保存中に進行状況を表示
    - セッション再開機能と統合してシームレスな再開を実現
  - **注意:** このコマンドを使用するには、最低でも2件のメッセージを含むアクティブな会話が必要です。

- **`/compress`**
  - **説明:** チャットコンテキスト全体をサマリーに置き換えます。これにより、将来のタスクで使用するトークン数を削減しつつ、これまでの内容の高レベルなサマリーを保持できます。

- **`/copy`**
  - **説明:** Qwen Codeが最後に出力した内容をクリップボードにコピーし、共有や再利用を容易にします。

- **`/directory`** (または **`/dir`**)
  - **説明:** 複数ディレクトリ対応のワークスペースディレクトリを管理します。
  - **サブコマンド:**
    - **`add`**:
      - **説明:** ワークスペースにディレクトリを追加します。パスは絶対パスまたは現在の作業ディレクトリからの相対パスを指定できます。また、ホームディレクトリからの参照もサポートされています。
      - **使用方法:** `/directory add <path1>,<path2>`
      - **注意:** 制限付きサンドボックスプロファイルでは無効です。その場合、セッション開始時に`--include-directories`を使用してください。
    - **`show`**:
      - **説明:** `/directory add`および`--include-directories`で追加されたすべてのディレクトリを表示します。
      - **使用方法:** `/directory show`

- **`/directory`** (または **`/dir`**)
  - **説明:** 複数ディレクトリ対応のワークスペースディレクトリを管理します。
  - **サブコマンド:**
    - **`add`**:
      - **説明:** ワークスペースにディレクトリを追加します。パスは絶対パスまたは現在の作業ディレクトリからの相対パスを指定できます。また、ホームディレクトリからの参照もサポートされています。
      - **使用方法:** `/directory add <path1>,<path2>`
      - **注意:** 制限付きサンドボックスプロファイルでは無効です。その場合、セッション開始時に`--include-directories`を使用してください。
    - **`show`**:
      - **説明:** `/directory add`および`--include-directories`で追加されたすべてのディレクトリを表示します。
      - **使用方法:** `/directory show`

- **`/editor`**
  - **説明:** サポートされているエディタを選択するためのダイアログを開きます。

- **`/extensions`**
  - **説明:** 現在のQwen Codeセッションでアクティブなすべての拡張機能を一覧表示します。詳細は[Qwen Code Extensions](../extension.md)を参照してください。

- **`/help`** (または **`/?`**)
  - **説明:** Qwen Codeで利用可能なコマンドとその使用方法を含むヘルプ情報を表示します。

- **`/mcp`**
  - **説明:** 設定されたModel Context Protocol (MCP)サーバー、接続状況、サーバー詳細、利用可能なツールを一覧表示します。
  - **サブコマンド:**
    - **`desc`** または **`descriptions`**:
      - **説明:** MCPサーバーとツールの詳細な説明を表示します。
    - **`nodesc`** または **`nodescriptions`**:
      - **説明:** ツールの説明を非表示にし、ツール名のみを表示します。
    - **`schema`**:
      - **説明:** ツールの設定パラメータの完全なJSONスキーマを表示します。
  - **キーボードショートカット:** いつでも**Ctrl+T**を押すことで、ツールの説明表示/非表示を切り替えられます。

- **`/memory`**
  - **説明:** AIの指示コンテキスト（デフォルトでは`QWEN.md`ファイルから読み込まれる階層メモリ；`contextFileName`で設定可能）を管理します。
  - **サブコマンド:**
    - **`add`**:
      - **説明:** 次のテキストをAIのメモリに追加します。使用方法: `/memory add <記憶するテキスト>`
    - **`show`**:
      - **説明:** すべてのコンテキストファイル（例：`QWEN.md`）から読み込まれた現在の階層メモリの完全な内容を表示します。これにより、モデルに提供されている指示コンテキストを確認できます。
    - **`refresh`**:
      - **説明:** 設定された場所（グローバル、プロジェクト/祖先、サブディレクトリ）にあるすべてのコンテキストファイル（デフォルト：`QWEN.md`）から階層指示メモリを再読み込みします。これにより、モデルに最新のコンテキスト内容が反映されます。
    - **注意:** コンテキストファイルが階層メモリにどのように寄与するかの詳細については、[CLI Configuration documentation](./configuration.md#context-files-hierarchical-instructional-context)を参照してください。

- **`/restore`**
  - **説明:** ツールが実行される直前のプロジェクトファイルの状態に復元します。これは、ツールによって行われたファイル編集を元に戻すのに特に便利です。ツール呼び出しIDなしで実行した場合、復元可能なチェックポイントの一覧が表示されます。
  - **使用方法:** `/restore [tool_call_id]`
  - **注意:** CLIが`--checkpointing`オプションで起動された場合、または[settings](./configuration.md)で設定されている場合にのみ使用可能です。詳細は[Checkpointing documentation](../checkpointing.md)を参照してください。

- **`/settings`**
  - **説明:** Qwen Codeの設定を表示・変更するための設定エディタを開きます。
  - **詳細:** このコマンドは、Qwen Codeの動作と外観を制御する設定を変更するためのユーザーフレンドリーなインターフェースを提供します。`.qwen/settings.json`ファイルを手動で編集するのと同等ですが、エラーを防ぐための検証とガイダンスが含まれています。
  - **使用方法:** 単に`/settings`を実行するとエディタが開きます。そこから特定の設定を閲覧・検索し、現在の値を確認し、必要に応じて変更できます。一部の設定は即座に反映されますが、他の設定は再起動が必要です。

- **`/stats`**
  - **説明:** 現在のQwen Codeセッションの詳細な統計情報を表示します。これにはトークン使用量、キャッシュされたトークンの節約量（利用可能な場合）、セッション時間などが含まれます。注意：キャッシュされたトークン情報は、APIキー認証時にトークンが使用されている場合にのみ表示され、現在のところOAuth認証では表示されません。

- [**`/theme`**](./themes.md)
  - **説明:** Qwen Codeの視覚テーマを変更するためのダイアログを開きます。

- **`/auth`**
  - **説明:** 認証方法を変更するためのダイアログを開きます。

- **`/about`**
  - **説明:** バージョン情報を表示します。issueを提出する際はこの情報を共有してください。

- **`/agents`**
  - **説明:** 特定のタスクに特化したAIサブエージェントを管理します。サブエージェントは特定の専門知識とツールアクセスで構成された独立したAIアシスタントです。
  - **サブコマンド:**
    - **`create`**:
      - **説明:** 新しいサブエージェントを作成するためのインタラクティブウィザードを起動します。ウィザードでは場所選択、AIによるプロンプト生成、ツール選択、視覚的カスタマイズをガイドします。
      - **使用方法:** `/agents create`
    - **`manage`**:
      - **説明:** 既存のサブエージェントを表示・編集・削除するためのインタラクティブな管理ダイアログを開きます。プロジェクトレベルとユーザーレベルのエージェントの両方を表示します。
      - **使用方法:** `/agents manage`
  - **保存場所:**
    - **プロジェクトレベル:** `.qwen/agents/`（チームで共有、優先度高）
    - **ユーザーレベル:** `~/.qwen/agents/`（個人用エージェント、プロジェクト間で利用可能）
  - **注意:** サブエージェントの作成・管理の詳細については、[Subagents documentation](../subagents.md)を参照してください。

- [**`/tools`**](../tools/index.md)
  - **説明:** Qwen Code内で現在利用可能なツールの一覧を表示します。
  - **サブコマンド:**
    - **`desc`** または **`descriptions`**:
      - **説明:** 各ツールの詳細な説明を表示します。これには、モデルに提供された各ツールの名前と完全な説明が含まれます。
    - **`nodesc`** または **`nodescriptions`**:
      - **説明:** ツールの説明を非表示にし、ツール名のみを表示します。

- **`/privacy`**
  - **説明:** プライバシー通知を表示し、ユーザーがサービス改善のためのデータ収集に同意するかどうかを選択できるようにします。

- **`/quit-confirm`**
  - **説明:** Qwen Codeを終了する前に確認ダイアログを表示し、現在のセッションをどのように処理するかを選択できるようにします。
  - **使用方法:** `/quit-confirm`
  - **機能:**
    - **即時終了:** 何も保存せずに終了（`/quit`と同等）
    - **サマリー生成して終了:** 終了前に`/summary`を使用してプロジェクトサマリーを作成
    - **会話を保存して終了:** 自動生成されたタグで現在の会話を保存してから終了
  - **キーボードショートカット:** **Ctrl+C**を2回押すことで終了確認ダイアログを起動
  - **注意:** Ctrl+Cを1回押したときに自動的にこのコマンドが起動され、誤って終了することを防ぐ安全機構が提供されます。

- **`/quit`** (または **`/exit`**)
  - **説明:** 確認ダイアログなしでQwen Codeを即座に終了します。

- **`/vim`**
  - **説明:** vimモードのオン/オフを切り替えます。vimモードが有効になると、入力エリアでNORMALモードとINSERTモードの両方でvimスタイルのナビゲーションと編集コマンドがサポートされます。
  - **機能:**
    - **NORMALモード:** `h`, `j`, `k`, `l`で移動；`w`, `b`, `e`で単語単位移動；`0`, `$`, `^`で行頭/行末/非空白文字の行頭に移動；`G`（または`gg`で最初の行）で特定行に移動
    - **INSERTモード:** 標準的なテキスト入力で、エスケープでNORMALモードに戻る
    - **編集コマンド:** `x`で削除、`c`で変更、`i`, `a`, `o`, `O`で挿入；`dd`, `cc`, `dw`, `cw`などの複雑な操作
    - **カウントサポート:** コマンドの前に数字を付ける（例：`3h`, `5w`, `10G`）
    - **最後のコマンド繰り返し:** `.`で最後の編集操作を繰り返す
    - **永続設定:** Vimモードの設定は`~/.qwen/settings.json`に保存され、セッション間で復元される
  - **ステータス表示:** 有効時はフッターに`[NORMAL]`または`[INSERT]`を表示

- **`/init`**
  - **説明:** 現在のディレクトリを解析し、デフォルトでは`QWEN.md`コンテキストファイル（または`contextFileName`で指定されたファイル名）を作成します。空でないファイルが既に存在する場合は変更されません。このコマンドは空のファイルを作成し、モデルにプロジェクト固有の指示で埋めるようプロンプトを表示します。
```

### カスタムコマンド

すぐに始めるには、以下の[例](#example-a-pure-function-refactoring-command)を参照してください。

カスタムコマンドを使用すると、お気に入りやよく使うプロンプトを Qwen Code 内で個人用のショートカットとして保存・再利用できます。1つのプロジェクト専用のコマンドや、すべてのプロジェクトでグローバルに利用可能なコマンドを作成でき、ワークフローを効率化し、一貫性を保つことができます。

#### ファイルの場所と優先順位

Qwen Code は、以下の2つの場所からコマンドを読み込み、特定の順序でロードします：

1.  **ユーザー コマンド (グローバル):** `~/.qwen/commands/` に配置されます。これらのコマンドは、作業中のすべてのプロジェクトで利用可能です。
2.  **プロジェクト コマンド (ローカル):** `<your-project-root>/.qwen/commands/` に配置されます。これらのコマンドは現在のプロジェクト専用であり、チームと共有するためにバージョン管理に含めることができます。

プロジェクトディレクトリ内のコマンドとユーザーディレクトリ内のコマンドで名前が同じ場合、**プロジェクト コマンドが常に使用されます。** これにより、プロジェクト固有のバージョンでグローバル コマンドを上書きできます。

#### コマンド名と名前空間

コマンド名は、そのファイルが存在する `commands` ディレクトリからの相対パスに基づいて決定されます。サブディレクトリを使用することで名前空間付きコマンドを作成でき、パス区切り文字（`/` または `\`）はコロン（`:`）に変換されます。

- `~/.qwen/commands/test.toml` にあるファイルは、コマンド `/test` になります。
- `<project>/.qwen/commands/git/commit.toml` にあるファイルは、名前空間付きコマンド `/git:commit` になります。

#### TOML ファイル形式 (v1)

コマンド定義ファイルは TOML 形式で記述し、拡張子は `.toml` を使用してください。

##### 必須フィールド

- `prompt` (String): コマンド実行時にモデルに送信されるプロンプト。単一行または複数行の文字列を指定できます。

##### オプションフィールド

- `description` (String): コマンドの機能を説明する短い一行の説明文。このテキストは `/help` メニューでコマンドの横に表示されます。**このフィールドを省略した場合、ファイル名から汎用的な説明が自動生成されます。**

#### 引数の処理

カスタムコマンドでは、引数を処理するための2つの強力な方法がサポートされています。CLIは、コマンドの`prompt`の内容に基づいて、自動的に正しい方法を選択します。

##### 1. `{{args}}`によるコンテキスト対応の注入

`prompt`に特殊なプレースホルダー`{{args}}`が含まれている場合、CLIはそのプレースホルダーをユーザーがコマンド名の後にタイプしたテキストに置き換えます。

この注入の動作は、使用場所によって異なります：

**A. 生の注入（Shellコマンド外）**

プロンプトの本文で使用される場合、引数はユーザーがタイプした通りに正確に注入されます。

**例（`git/fix.toml`）：**

```toml

```markdown
# 実行方法: /git:fix "Button is misaligned"

description = "与えられた問題に対する修正を生成します。"
prompt = "ここに記述された問題に対するコード修正を提供してください: {{args}}."
```

モデルが受け取る内容: `ここに記述された問題に対するコード修正を提供してください: "Button is misaligned".`

**B. Shell コマンド内での引数の使用 (`!{...}` ブロック内)**

Shell インジェクションブロック (`!{...}`) 内で `{{args}}` を使用する場合、引数は置換前に自動的に **shell-escape** されます。これにより、Shell コマンドに安全に引数を渡すことができ、結果として生成されるコマンドが構文的に正しく、セキュアであることを保証し、コマンドインジェクションの脆弱性を防ぎます。

**例 (`/grep-code.toml`):**

```toml
prompt = """
パターン `{{args}}` の検索結果を要約してください。

検索結果:
!{grep -r {{args}} .}
"""
```

`/grep-code It's complicated` を実行する場合:

1. CLI は `{{args}}` が `!{...}` の外と内の両方で使用されていることを検出します。
2. 外側: 最初の `{{args}}` はそのまま `It's complicated` に置換されます。
3. 内側: 2番目の `{{args}}` はエスケープされたバージョンに置換されます（例：Linux では `"It's complicated"`）。
4. 実行されるコマンドは `grep -r "It's complicated" .` になります。
5. CLI は実行前にこの正確で安全なコマンドを確認するプロンプトを表示します。
6. 最終的な prompt が送信されます。
```

##### 2. デフォルトの引数処理

あなたの `prompt` に特別なプレースホルダー `{{args}}` が含まれて**いない**場合、CLI は引数処理に対してデフォルトの動作を使用します。

コマンドに引数を指定した場合（例: `/mycommand arg1`）、CLI はあなたが入力したコマンド全体をプロンプトの末尾に2つの改行で区切って追加します。これにより、モデルは元の指示とあなたが指定した具体的な引数の両方を見ることができます。

引数を指定**しなかった**場合（例: `/mycommand`）、プロンプトはそのまま何も追加されずにモデルに送信されます。

**例 (`changelog.toml`):**

この例では、モデルの役割を定義し、ユーザーの入力がどこにあるかを説明し、期待されるフォーマットと動作を指定することで、堅牢なコマンドを作成する方法を示しています。

```toml

# In: <project>/.qwen/commands/changelog.toml

# 実行方法: /changelog 1.2.0 added "Support for default argument parsing."

description = "プロジェクトの CHANGELOG.md ファイルに新しいエントリを追加します。"
prompt = """

# タスク: Changelog の更新

あなたはこのソフトウェアプロジェクトの経験豊富なメンテナーです。ユーザーが changelog に新しいエントリを追加するコマンドを実行しました。

**ユーザーの生のコマンドが以下の指示の後に追加されています。**

あなたのタスクは、入力から `<version>`、`<change_type>`、`<message>` を解析し、`write_file` ツールを使用して `CHANGELOG.md` ファイルを正しく更新することです。

## 期待されるフォーマット
コマンドは以下のフォーマットに従います: `/changelog <version> <type> <message>`
- `<type>` は以下のいずれかでなければなりません: "added", "changed", "fixed", "removed"。

```markdown
## 挙動
1. `CHANGELOG.md` ファイルを読み込む。
2. 指定された `<version>` のセクションを探す。
3. 正しい `<type>` 見出しの下に `<message>` を追加する。
4. バージョンまたはタイプのセクションが存在しない場合は、新しく作成する。
5. "Keep a Changelog" 形式に厳密に従う。

/changelog 1.2.0 added "New feature" を実行すると、モデルに送信される最終的なテキストは、元のプロンプトに続けて2つの改行と入力したコマンドになります。
```

##### 3. `!{...}` を使用した Shell コマンドの実行

`prompt` 内で直接 Shell コマンドを実行し、その出力を注入することで、コマンドを動的にすることができます。これは、ファイルの内容を読み込んだり、Git のステータスを確認したりといったローカル環境からのコンテキスト収集に最適です。

カスタムコマンドが Shell コマンドの実行を試みると、Qwen Code は処理を進める前に確認ダイアログを表示するようになりました。これは意図しないコマンドが実行されないようにするためのセキュリティ対策です。

**仕組み:**

1.  **コマンドの注入:** `!{...}` 構文を使用します。
2.  **引数の置換:** ブロック内で `{{args}}` が存在する場合、自動的に Shell エスケープされます（上記の [Context-Aware Injection](#1-context-aware-injection-with-args) を参照）。
3.  **堅牢なパース:** パーサーは、JSON ペイロードを含む複雑な Shell コマンドも正しく処理できます。
4.  **セキュリティチェックと確認:** CLI は、引数がエスケープ・置換された後の最終コマンドに対してセキュリティチェックを実施します。実行されるコマンドを正確に表示するダイアログが表示されます。
5.  **実行とエラー報告:** コマンドが実行されます。コマンドが失敗した場合、プロンプトに注入される出力にはエラーメッセージ（stderr）と、例えば `[Shell command exited with code 1]` のようなステータス行が含まれます。これにより、モデルはエラーのコンテキストを理解できます。

**例 (`git/commit.toml`):**

このコマンドは、ステージングされた Git の diff を取得し、それを使用してモデルにコミットメッセージを作成させます。

````toml

# In: <project>/.qwen/commands/git/commit.toml

# Invoked via: /git:commit

description = "ステージされた変更に基づいて Git commit メッセージを生成します。"

# prompt では !{...} を使用してコマンドを実行し、その出力を挿入します。
prompt = """
以下の git diff に基づいて、Conventional Commit メッセージを生成してください:

```diff
!{git diff --staged}
```

"""

```

/git:commit を実行すると、CLI はまず `git diff --staged` を実行し、次に `!{git diff --staged}` をそのコマンドの出力に置き換えて、最終的な完全な prompt をモデルに送信します。

#### 例: 「純粋関数」リファクタリングコマンド

コードの一部をリファクタリングするようモデルに指示するグローバルコマンドを作成してみましょう。

**1. ファイルとディレクトリの作成:**

まず、ユーザーのコマンドディレクトリが存在することを確認し、次に整理のための `refactor` サブディレクトリと最終的な TOML ファイルを作成します。

```bash
mkdir -p ~/.qwen/commands/refactor
touch ~/.qwen/commands/refactor/pure.toml
```

**2. ファイルに内容を追加:**

エディタで `~/.qwen/commands/refactor/pure.toml` を開き、以下の内容を追加します。ここでは、ベストプラクティスとして任意の `description` を含めています。

```toml

# In: ~/.qwen/commands/refactor/pure.toml

```markdown
# このコマンドは以下のように実行されます: /refactor:pure

description = "現在のコンテキストにあるコードを、純粋関数（pure function）にリファクタリングするようモデルに指示します。"

prompt = """
現在のコンテキストで提供されているコードを分析してください。
それを純粋関数にリファクタリングしてください。

あなたのレスポンスには以下を含めてください:
1. リファクタリングされた純粋関数のコードブロック。
2. あなたが加えた主要な変更点と、それが純粋性にどう貢献するかの簡単な説明。
"""
```

**3. コマンドを実行する:**

以上です！CLIでコマンドを実行できるようになりました。まずコンテキストにファイルを追加し、それからコマンドを実行してください:

```
> @my-messy-function.js
> /refactor:pure
```

Qwen Codeは、TOMLファイルで定義された複数行のプロンプトを実行します。
```

## At コマンド (`@`)

At コマンドは、ファイルやディレクトリの内容をプロンプトの一部としてモデルに渡すために使用されます。これらのコマンドには Git を意識したフィルタリング機能が含まれています。

- **`@<path_to_file_or_directory>`**
  - **説明:** 指定したファイルまたは複数のファイルの内容を現在のプロンプトに挿入します。特定のコードやテキスト、ファイル群について質問する際に便利です。
  - **例:**
    - `@path/to/your/file.txt Explain this text.`
    - `@src/my_project/ Summarize the code in this directory.`
    - `What is this file about? @README.md`
  - **詳細:**
    - 単一のファイルパスが指定された場合、そのファイルの内容が読み込まれます。
    - ディレクトリパスが指定された場合、そのディレクトリおよびサブディレクトリ内のファイル内容を読み込もうとします。
    - パスにスペースが含まれる場合は、バックスラッシュでエスケープしてください（例: `@My\ Documents/file.txt`）。
    - 内部的には `read_many_files` ツールを使用しています。内容が取得された後、クエリに挿入されてからモデルに送信されます。
    - **Git を意識したフィルタリング:** デフォルトでは、Git で無視されるファイル（`node_modules/`、`dist/`、`.env`、`.git/` など）は除外されます。この動作は `fileFiltering` 設定で変更可能です。
    - **ファイルタイプ:** このコマンドは主にテキストベースのファイルを対象としています。バイナリファイルや非常に大きなファイルは、パフォーマンスと関連性を保つために、`read_many_files` ツールによってスキップまたは切り捨てられることがあります。ツールはファイルがスキップされた場合にその旨を示します。
  - **出力:** CLI には `read_many_files` が使用されたことを示すツール呼び出しメッセージと、処理されたパスおよびステータスの詳細が表示されます。

- **`@`（単独の @ 記号）**
  - **説明:** パスなしで単独の `@` 記号を入力した場合、クエリはそのままモデルに渡されます。プロンプト内で `@` 記号そのものについて話す場合に便利です。

### `@` コマンドのエラーハンドリング

- `@` の後に指定されたパスが見つからない、または無効な場合、エラーメッセージが表示され、クエリはモデルに送信されないか、ファイル内容なしで送信されることがあります。
- `read_many_files` ツールがエラー（例：権限の問題）に遭遇した場合も、その旨が報告されます。

## Shell モードとパススルー コマンド (`!`)

`!` プレフィックスを使用すると、Qwen Code 内から直接システムのシェルとやり取りできます。

- **`!<shell_command>`**
  - **説明:** Linux/macOS では `bash`、Windows では `cmd.exe` を使用して、指定された `<shell_command>` を実行します。コマンドの出力やエラーはすべてターミナルに表示されます。
  - **例:**
    - `!ls -la` (`ls -la` を実行し、Qwen Code に戻る)
    - `!git status` (`git status` を実行し、Qwen Code に戻る)

- **`!` (Shell モードの切り替え)**
  - **説明:** `!` のみを入力すると、Shell モードが切り替わります。
    - **Shell モードに入る:**
      - 有効になると、Shell モードでは別のカラー表示と「Shell モードインジケーター」が使用されます。
      - Shell モード中は、入力したテキストが直接シェルコマンドとして解釈されます。
    - **Shell モードを抜ける:**
      - 抜けると、UI は標準の外観に戻り、通常の Qwen Code の動作が再開されます。

- **すべての `!` 使用時の注意:** Shell モードで実行するコマンドは、ターミナルで直接実行する場合と同じ権限と影響を持ちます。

- **環境変数:** `!` 経由または Shell モードでコマンドが実行される際、サブプロセスの環境には `QWEN_CODE=1` という環境変数が設定されます。これにより、スクリプトやツールが CLI 内から実行されているかどうかを検出できます。