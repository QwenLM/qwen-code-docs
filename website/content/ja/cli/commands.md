# CLI Commands

Qwen Code では、セッションの管理、インターフェースのカスタマイズ、およびその動作を制御するための複数の組み込みコマンドがサポートされています。これらのコマンドは、スラッシュ (`/`)、アットマーク (`@`)、または感嘆符 (`!`) を接頭辞として使用します。

## スラッシュコマンド (`/`)

スラッシュコマンドは、CLI 自体に対するメタレベルの制御を提供します。

```markdown
### 組み込みコマンド

- **`/bug`**
  - **説明:** Qwen Codeに関するissueを提出します。デフォルトでは、GitHubのQwen Codeリポジトリ内にissueが作成されます。`/bug`の後に記述した文字列は、そのバグレポートのタイトルになります。このデフォルトの動作は、`.qwen/settings.json`ファイル内の`advanced.bugCommand`設定で変更できます。

- **`/chat`**
  - **説明:** 対話的に会話履歴を保存・再開し、分岐した会話状態を維持したり、以前のセッションから再開したりできます。
  - **サブコマンド:**
    - **`save`**
      - **説明:** 現在の会話履歴を保存します。会話状態を識別するために`<tag>`を指定する必要があります。
      - **使用方法:** `/chat save <tag>`
      - **チェックポイント保存場所の詳細:** チャットチェックポイントのデフォルト保存場所は以下の通りです：
        - Linux/macOS: `~/.qwen/tmp/<project_hash>/`
        - Windows: `C:\Users\<YourUsername>\.qwen\tmp\<project_hash>\`
        - `/chat list`を実行すると、CLIはこれらのディレクトリのみをスキャンして利用可能なチェックポイントを探します。
        - **注意:** これらのチェックポイントは、手動での会話状態の保存と再開用です。ファイル変更前に自動生成されるチェックポイントについては、[Checkpointing documentation](../checkpointing.md)をご参照ください。
    - **`resume`**
      - **説明:** 以前に保存された会話を再開します。
      - **使用方法:** `/chat resume <tag>`
    - **`list`**
      - **説明:** 再開可能なチャット状態のタグ一覧を表示します。
    - **`delete`**
      - **説明:** 保存された会話チェックポイントを削除します。
      - **使用方法:** `/chat delete <tag>`
    - **`share`**
      - **説明:** 現在の会話を指定されたMarkdownまたはJSONファイルに出力します。
      - **使用方法:** `/chat share file.md` または `/chat share file.json`。ファイル名が指定されない場合、CLIが自動的に生成します。

- **`/clear`**
  - **説明:** ターミナル画面をクリアし、CLI上での表示履歴およびスクロールバックを含めて消去します。実装によっては、履歴データ自体は保持される場合がありますが、画面上の表示はクリアされます。
  - **キーボードショートカット:** いつでも**Ctrl+L**キーを押すことでクリア操作を行えます。

- **`/summary`**
  - **説明:** 現在の会話履歴から包括的なプロジェクトサマリーを生成し、`.qwen/PROJECT_SUMMARY.md`に保存します。このサマリーには全体の目標、重要な知識、最近のアクション、現在の計画が含まれており、次回以降の作業再開に最適です。
  - **使用方法:** `/summary`
  - **機能:**
    - 全ての会話履歴を分析して重要なコンテキストを抽出
    - 目標、知識、アクション、計画のセクションを持つ構造化されたMarkdownサマリーを作成
    - 自動的にプロジェクトルートの`.qwen/PROJECT_SUMMARY.md`に保存
    - 生成および保存中に進行状況インジケーターを表示
    - Welcome Back機能と連携してシームレスなセッション再開を実現
  - **注意:** このコマンドを使用するには、最低でも2件以上のメッセージを含む有効な会話が必要です。

- **`/compress`**
  - **説明:** チャットコンテキスト全体をサマリーに置き換えます。これにより、将来のタスクで使用されるトークン数を節約しつつ、これまでの内容の概要を保持できます。

- **`/copy`**
  - **説明:** Qwen Codeが最後に出力した内容をクリップボードにコピーし、共有や再利用を容易にします。

- **`/directory`**（または**`/dir`**）
  - **説明:** 複数ディレクトリ対応のワークスペースディレクトリを管理します。
  - **サブコマンド:**
    - **`add`**:
      - **説明:** ワークスペースにディレクトリを追加します。パスは絶対パスまたは現在の作業ディレクトリからの相対パスを指定できます。また、ホームディレクトリからの相対指定も可能です。
      - **使用方法:** `/directory add <path1>,<path2>`
      - **注意:** 制限付きサンドボックスプロファイルでは無効です。その場合は、セッション開始時に`--include-directories`オプションを使用してください。
    - **`show`**:
      - **説明:** `/directory add`および`--include-directories`で追加されたすべてのディレクトリを表示します。
      - **使用方法:** `/directory show`

- **`/editor`**
  - **説明:** サポートされているエディタを選択するためのダイアログを開きます。

- **`/extensions`**
  - **説明:** 現在のQwen Codeセッションで有効になっている拡張機能の一覧を表示します。詳しくは[Qwen Code Extensions](../extension.md)をご参照ください。

- **`/help`**（または**`/?`**）
  - **説明:** 利用可能なコマンドとその使用方法を含む、Qwen Codeに関するヘルプ情報を表示します。

- **`/mcp`**
  - **説明:** 設定済みのModel Context Protocol (MCP)サーバー、接続状況、サーバー詳細、利用可能なツールを一覧表示します。
  - **サブコマンド:**
    - **`desc`** または **`descriptions`**:
      - **説明:** MCPサーバーおよびツールの詳細な説明を表示します。
    - **`nodesc`** または **`nodescriptions`**:
      - **説明:** ツールの説明を非表示にして、ツール名のみを表示します。
    - **`schema`**:
      - **説明:** ツールの設定パラメータに関する完全なJSONスキーマを表示します。
  - **キーボードショートカット:** いつでも**Ctrl+T**キーを押すことで、ツール説明の表示/非表示を切り替えられます。

- **`/memory`**
  - **説明:** AIの指示コンテキスト（デフォルトでは`QWEN.md`ファイルから読み込まれる階層的メモリ；`contextFileName`で設定可能）を管理します。
  - **サブコマンド:**
    - **`add`**:
      - **説明:** 指定したテキストをAIのメモリに追加します。使用方法：`/memory add <記憶させたいテキスト>`
    - **`show`**:
      - **説明:** すべてのコンテキストファイル（例：`QWEN.md`）から読み込まれた現在の階層的メモリの内容を表示します。モデルに提供されている指示コンテキストを確認できます。
    - **`refresh`**:
      - **説明:** 設定された場所（グローバル、プロジェクト/祖先、サブディレクトリ）にあるすべてのコンテキストファイル（デフォルト：`QWEN.md`）から階層的指示メモリを再読み込みします。これにより、モデルに最新のコンテキスト内容が反映されます。
    - **注意:** コンテキストファイルが階層的メモリにどのように寄与するかの詳細については、[CLI Configuration documentation](./configuration.md#context-files-hierarchical-instructional-context)をご参照ください。

- **`/restore`**
  - **説明:** ツールが実行される直前のプロジェクトファイルの状態に戻します。特にツールによるファイル編集を元に戻す際に便利です。ツール呼び出しIDなしで実行した場合、復元可能なチェックポイントの一覧が表示されます。
  - **使用方法:** `/restore [tool_call_id]`
  - **注意:** CLIが`--checkpointing`オプションで起動された場合、または[settings](./configuration.md)で設定されている場合にのみ使用可能です。詳細は[Checkpointing documentation](../checkpointing.md)をご参照ください。

- **`/settings`**
  - **説明:** Qwen Codeの設定を表示・変更するための設定エディタを開きます。
  - **詳細:** このコマンドは、Qwen Codeの動作や外観を制御する設定を変更するためのユーザーフレンドリーなインターフェースを提供します。`.qwen/settings.json`ファイルを手動で編集するのと同等ですが、エラー防止のためにバリデーションとガイダンスが組み込まれています。
  - **使用方法:** 単純に`/settings`を実行するとエディタが開きます。そこから特定の設定を閲覧・検索し、現在の値を確認し、必要に応じて変更できます。一部の設定は即時適用されますが、他の設定は再起動が必要です。

- **`/stats`**
  - **説明:** 現在のQwen Codeセッションの詳細な統計情報を表示します。これにはトークン使用量、キャッシュされたトークンの節約量（利用可能な場合）、セッション時間などが含まれます。注意：キャッシュされたトークン情報は、APIキー認証時には表示されますが、OAuth認証時は表示されません。

- [**`/theme`**](./themes.md)
  - **説明:** Qwen Codeの視覚テーマを変更できるダイアログを開きます。

- **`/auth`**
  - **説明:** 認証方法を変更できるダイアログを開きます。

- **`/approval-mode`**
  - **説明:** ツール使用時の承認モードを変更します。
  - **使用方法:** `/approval-mode [mode] [--session|--project|--user]`
  - **利用可能なモード:**
    - **`plan`**: 分析のみ；ファイル変更やコマンド実行は行いません
    - **`default`**: ファイル編集やシェルコマンドには承認が必要
    - **`auto-edit`**: ファイル編集を自動承認
    - **`yolo`**: すべてのツールを自動承認
  - **例:**
    - `/approval-mode plan --project`（このプロジェクトでplanモードを永続化）
    - `/approval-mode yolo --user`（このユーザーに対してYOLOモードをプロジェクト間で永続化）

- **`/about`**
  - **説明:** バージョン情報を表示します。issueを提出する際はこの情報を共有してください。

- **`/agents`**
  - **説明:** 特定のタスクに特化したAIサブエージェントを管理します。サブエージェントは特定の専門知識とツールアクセス権を持つ独立したAIアシスタントです。
  - **サブコマンド:**
    - **`create`**:
      - **説明:** 新しいサブエージェントを作成するためのインタラクティブウィザードを起動します。ウィザードでは、場所選択、AIによるプロンプト生成、ツール選択、ビジュアルカスタマイズのガイドが提供されます。
      - **使用方法:** `/agents create`
    - **`manage`**:
      - **説明:** 既存のサブエージェントを表示・編集・削除するためのインタラクティブな管理ダイアログを開きます。プロジェクトレベルとユーザーレベルのエージェントの両方を表示します。
      - **使用方法:** `/agents manage`
  - **保存場所:**
    - **プロジェクトレベル:** `.qwen/agents/`（チームで共有、優先度高）
    - **ユーザーレベル:** `~/.qwen/agents/`（個人用エージェント、プロジェクト間で利用可能）
  - **注意:** サブエージェントの作成・管理に関する詳細は、[Subagents documentation](../subagents.md)をご参照ください。

- [**`/tools`**](../tools/index.md)
  - **説明:** 現在Qwen Code内で利用可能なツールの一覧を表示します。
  - **使用方法:** `/tools [desc]`
  - **サブコマンド:**
    - **`desc`** または **`descriptions`**:
      - **説明:** 各ツールの詳細な説明を表示します。各ツール名とモデルに提供される完全な説明が含まれます。
    - **`nodesc`** または **`nodescriptions`**:
      - **説明:** ツールの説明を非表示にして、ツール名のみを表示します。

- **`/quit-confirm`**
  - **説明:** Qwen Codeを終了する前に確認ダイアログを表示し、現在のセッションをどう扱うか選択できるようにします。
  - **使用方法:** `/quit-confirm`
  - **機能:**
    - **すぐに終了:** 何も保存せずに終了（`/quit`と同等）
    - **サマリー生成後終了:** 終了前に`/summary`を使用してプロジェクトサマリーを作成
    - **会話を保存して終了:** 自動生成されたタグで現在の会話を保存してから終了
  - **キーボードショートカット:** **Ctrl+C**を2回押すことで終了確認ダイアログを起動
  - **注意:** Ctrl+Cを一度押すと自動的にこのコマンドが起動され、誤って終了してしまうことを防ぐ安全機構として機能します。

- **`/quit`**（または**`/exit`**）
  - **説明:** 確認ダイアログなしでQwen Codeを即座に終了します。

- **`/vim`**
  - **説明:** vimモードのオン/オフを切り替えます。vimモードが有効になると、入力エリアでNORMALモードとINSERTモードの両方でvimスタイルのナビゲーションと編集コマンドがサポートされます。
  - **機能:**
    - **NORMALモード:** `h`, `j`, `k`, `l`で移動；`w`, `b`, `e`で単語単位移動；`0`, `$`, `^`で行頭/行末/最初の非空白文字へ移動；`G`（または`gg`で先頭行）で指定行へ移動
    - **INSERTモード:** 標準的なテキスト入力で、EscキーでNORMALモードに戻る
    - **編集コマンド:** `x`で削除、`c`で変更、`i`, `a`, `o`, `O`で挿入；`dd`, `cc`, `dw`, `cw`などの複合操作
    - **カウント対応:** コマンドの前に数字を付ける（例：`3h`, `5w`, `10G`）
    - **最後のコマンド繰り返し:** `.`で最後の編集操作を繰り返す
    - **永続設定:** vimモードの設定は`~/.qwen/settings.json`に保存され、セッション間で復元されます
  - **ステータス表示:** 有効時はフッターに`[NORMAL]`または`[INSERT]`を表示

- **`/init`**
  - **説明:** 現在のディレクトリを分析し、デフォルトでは`QWEN.md`コンテキストファイル（または`contextFileName`で指定されたファイル名）を作成します。空でないファイルが既に存在する場合は変更しません。このコマンドは空のファイルを作成し、モデルにプロジェクト固有の指示で埋めるよう促します。
```

### カスタムコマンド

クイックスタートについては、以下の[例](#example-a-pure-function-refactoring-command)を参照してください。

カスタムコマンドを使用すると、お気に入りや最もよく使うプロンプトを Qwen Code 内で個人用のショートカットとして保存・再利用できます。単一のプロジェクトに特化したコマンドや、すべてのプロジェクトでグローバルに利用可能なコマンドを作成でき、ワークフローを効率化し、一貫性を保つことができます。

#### ファイルの場所と優先順位

Qwen Code は以下の2つの場所からコマンドを読み込み、特定の順序でロードします：

1.  **ユーザー コマンド（グローバル）：** `~/.qwen/commands/` に配置されます。これらのコマンドは、作業中のすべてのプロジェクトで利用可能です。
2.  **プロジェクト コマンド（ローカル）：** `<your-project-root>/.qwen/commands/` に配置されます。これらのコマンドは現在のプロジェクト専用であり、バージョン管理に含めてチームと共有できます。

プロジェクトディレクトリ内のコマンドとユーザーディレクトリ内のコマンドで名前が同じ場合、**常にプロジェクト コマンドが使用されます。** これにより、プロジェクト固有のバージョンでグローバル コマンドを上書きできます。

#### コマンド名と名前空間

コマンド名は、そのファイルが存在する `commands` ディレクトリからの相対パスに基づいて決定されます。サブディレクトリを使用することで名前空間付きコマンドを作成でき、パス区切り文字（`/` または `\`）はコロン（`:`）に変換されます。

- `~/.qwen/commands/test.toml` にあるファイルは、コマンド `/test` になります。
- `<project>/.qwen/commands/git/commit.toml` にあるファイルは、名前空間付きコマンド `/git:commit` になります。

#### TOML ファイル形式 (v1)

コマンド定義ファイルは TOML 形式で記述し、拡張子は `.toml` を使用してください。

##### 必須フィールド

- `prompt` (String): コマンド実行時にモデルに送信されるプロンプト。単一行または複数行の文字列が可能です。

##### オプションフィールド

- `description` (String): コマンドの機能を示す短い一行の説明文。このテキストは `/help` メニューでコマンドの横に表示されます。**このフィールドを省略した場合、ファイル名から汎用的な説明が自動生成されます。**

#### 引数の処理

カスタムコマンドでは、引数を処理するための強力な方法が2つサポートされています。CLIは、コマンドの`prompt`の内容に基づいて、自動的に適切な方法を選択します。

##### 1. `{{args}}`によるコンテキスト対応の注入

`prompt`に特殊なプレースホルダー`{{args}}`が含まれている場合、CLIはそのプレースホルダーをユーザーがコマンド名の後にタイプしたテキストに置き換えます。

この注入の動作は、使用場所によって異なります：

**A. 生の注入（Shellコマンド外）**

プロンプトの本文で使用される場合、引数はユーザーがタイプした通りに正確に注入されます。

**例（`git/fix.toml`）：**

```toml

```markdown
# 実行方法: /git:fix "Button is misaligned"

description = "与えられた問題に対する修正を生成します。"
prompt = "ここに記述された問題に対するコード修正を提供してください: {{args}}."
```

モデルが受け取る内容: `ここに記述された問題に対するコード修正を提供してください: "Button is misaligned".`

**B. Shell コマンドでの引数の使用方法 (`!{...}` ブロック内)**

`{{args}}` を shell インジェクションブロック (`!{...}`) 内で使用する場合、引数は置換前に自動的に **shell-escape** されます。これにより、shell コマンドに安全に引数を渡すことができ、結果として生成されるコマンドが構文的に正しく、かつセキュアであることを保証します。また、コマンドインジェクションの脆弱性を防ぐことができます。

**例 (`/grep-code.toml`):**

```toml
prompt = """
パターン `{{args}}` に対する調査結果を要約してください。

検索結果:
!{grep -r {{args}} .}
"""
```

`/grep-code It's complicated` を実行する場合:

1. CLI は `{{args}}` が `!{...}` の外と内とで使用されていることを検出します。
2. 外側: 最初の `{{args}}` はそのまま `It's complicated` に置換されます。
3. 内側: 2つ目の `{{args}}` はエスケープされたバージョンに置換されます（例：Linux では `"It's complicated"`）。
4. 実行されるコマンドは `grep -r "It's complicated" .` になります。
5. CLI は実行前にこの正確で安全なコマンドを確認するプロンプトを表示します。
6. 最終的な prompt が送信されます。
```

##### 2. デフォルトの引数処理

あなたの `prompt` に特別なプレースホルダー `{{args}}` が含まれて**いない**場合、CLI は引数を処理するためのデフォルトの動作を使用します。

コマンドに引数を指定した場合（例：`/mycommand arg1`）、CLI はあなたが入力した完全なコマンドをプロンプトの末尾に2つの改行で区切って追加します。これにより、モデルは元の指示とあなたが提供した特定の引数の両方を見ることができます。

引数を指定**しなかった**場合（例：`/mycommand`）、プロンプトはそのまま何も追加されずにモデルに送信されます。

**例 (`changelog.toml`):**

この例では、モデルの役割を定義し、ユーザーの入力を見つける場所を説明し、期待される形式と動作を指定することで、堅牢なコマンドを作成する方法を示しています。

```toml

# In: <project>/.qwen/commands/changelog.toml

```markdown
# 呼び出し方法: /changelog 1.2.0 added "デフォルト引数解析のサポート"

description = "プロジェクトの CHANGELOG.md ファイルに新しいエントリを追加します。"
prompt = """

# タスク: Changelog の更新

あなたはこのソフトウェアプロジェクトのエキスパートメンテナーです。ユーザーが changelog に新しいエントリを追加するコマンドを実行しました。

**ユーザーの生のコマンドが以下の指示の後に添付されています。**

あなたのタスクは、入力から `<version>`、`<change_type>`、`<message>` を解析し、`write_file` ツールを使用して `CHANGELOG.md` ファイルを正しく更新することです。

## 期待されるフォーマット
コマンドは次のフォーマットに従います: `/changelog <version> <type> <message>`
- `<type>` は次のいずれかでなければなりません: "added", "changed", "fixed", "removed"。
```

```markdown
## 挙動
1. `CHANGELOG.md` ファイルを読み込む。
2. 指定された `<version>` のセクションを探す。
3. 正しい `<type>` 見出しの下に `<message>` を追加する。
4. バージョンまたはタイプのセクションが存在しない場合は、新たに作成する。
5. "Keep a Changelog" 形式に厳密に従う。

/changelog 1.2.0 added "New feature" を実行すると、モデルに送信される最終的なテキストは、元のプロンプトに続けて2つの改行と入力したコマンドとなる。
```

##### 3. `!{...}` を使用したシェルコマンドの実行

`prompt` 内で直接シェルコマンドを実行し、その出力を注入することで、コマンドを動的にすることができます。これは、ファイルの内容を読み込んだり、Git のステータスを確認したりといったローカル環境からのコンテキスト収集に最適です。

カスタムコマンドがシェルコマンドの実行を試みると、Qwen Code は処理を進める前に確認ダイアログを表示するようになりました。これは意図しないコマンドが実行されないようにするためのセキュリティ対策です。

**仕組み:**

1.  **コマンドの注入:** `!{...}` 構文を使用します。
2.  **引数の置換:** ブロック内で `{{args}}` が存在する場合、自動的にシェルエスケープされます（上記の [Context-Aware Injection](#1-context-aware-injection-with-args) 参照）。
3.  **堅牢なパース:** パーサーは、JSON ペイロードなどの中括弧がネストされた複雑なシェルコマンドも正しく処理できます。**注意:** `!{...}` 内のコンテンツは中括弧（`{` と `}`）がバランスよく閉じている必要があります。もし不均衡な中括弧を含むコマンドを実行したい場合は、外部スクリプトファイルにラップして `!{...}` ブロック内でそのスクリプトを呼び出すことを検討してください。
4.  **セキュリティチェックと確認:** CLI は最終的な解決済みコマンド（引数がエスケープ・置換された後のもの）に対してセキュリティチェックを実施します。実行予定の正確なコマンドがダイアログに表示されます。
5.  **実行とエラー報告:** コマンドが実行されます。コマンドが失敗した場合、プロンプトに注入される出力にはエラーメッセージ（stderr）とその後に続くステータス行（例：`[Shell command exited with code 1]`）が含まれます。これによりモデルは失敗のコンテキストを理解できます。

**例 (`git/commit.toml`):**

このコマンドはステージングされた git diff を取得し、それを使用してモデルにコミットメッセージを作成させます。

````toml

# In: <project>/.qwen/commands/git/commit.toml

# Invoked via: /git:commit

description = "ステージされた変更に基づいて Git commit メッセージを生成します。"

# prompt では !{...} を使用してコマンドを実行し、その出力を挿入します。
prompt = """
以下の git diff に基づいて Conventional Commit メッセージを生成してください:

```diff
!{git diff --staged}
```

"""

````

`/git:commit` を実行すると、CLI はまず `git diff --staged` を実行し、次に `!{git diff --staged}` をそのコマンドの出力で置換して、最終的な完全な prompt をモデルに送信します。

##### 4. `@{...}` によるファイル内容の注入

`@{...}` 構文を使用して、ファイルの内容やディレクトリの一覧を直接プロンプトに埋め込むことができます。これは特定のファイルを操作するコマンドを作成する際に便利です。

**動作方法:**

- **ファイルの注入**: `@{path/to/file.txt}` は `file.txt` の内容に置き換えられます。
- **マルチモーダル対応**: パスがサポートされている画像（例：PNG、JPEG）、PDF、音声、動画ファイルを指している場合、それらは適切にエンコードされ、マルチモーダル入力として注入されます。その他のバイナリファイルは適切に処理され、スキップされます。
- **ディレクトリ一覧**: `@{path/to/dir}` は再帰的に探索され、ディレクトリ内およびすべてのサブディレクトリにある各ファイルがプロンプトに挿入されます。`.gitignore` と `.qwenignore` が有効な場合はこれらも尊重されます。
- **ワークスペース対応**: コマンドは現在のディレクトリおよびその他のワークスペースディレクトリ内でパスを検索します。ワークスペース内の絶対パスも使用可能です。
- **処理順序**: `@{...}` によるファイル内容の注入は、シェルコマンド（`!{...}`）や引数の置換（`{{args}}`）より**前**に処理されます。
- **パース処理**: パーサーは `@{...}` 内の内容（パス）において、波括弧（`{` と `}`）がバランスよく閉じていることを要求します。

**例（`review.toml`）:**

このコマンドでは、**固定された**ベストプラクティスファイル（`docs/best-practices.md`）の内容を注入し、ユーザーの引数を使ってレビューのコンテキストを提供しています。

```toml

```markdown
# In: <project>/.qwen/commands/review.toml

# Invoked via: /review FileCommandLoader.ts

description = "ベストプラクティスガイドを使って提供されたコンテキストをレビューします。"
prompt = """
あなたはエキスパートコードレビュアーです。

あなたのタスクは {{args}} をレビューすることです。

レビューを提供する際には、以下のベストプラクティスを使用してください：

@{docs/best-practices.md}
"""
```

`/review FileCommandLoader.ts` を実行すると、`@{docs/best-practices.md}` プレースホルダーがそのファイルの内容に置き換えられ、`{{args}}` はあなたが提供したテキストに置き換えられた上で、最終的なプロンプトがモデルに送信されます。

---

#### 例: 「純粋関数」リファクタリングコマンド

コードの一部をリファクタリングするようモデルに指示するグローバルコマンドを作成してみましょう。

**1. ファイルとディレクトリの作成:**

まず、ユーザーのコマンドディレクトリが存在することを確認し、次に整理のための `refactor` サブディレクトリと最終的な TOML ファイルを作成します。

```bash
mkdir -p ~/.qwen/commands/refactor
touch ~/.qwen/commands/refactor/pure.toml
```

**2. ファイルに内容を追加:**

エディタで `~/.qwen/commands/refactor/pure.toml` を開き、以下の内容を追加します。ここでは、ベストプラクティスとして任意の `description` を含めています。

```toml

# In: ~/.qwen/commands/refactor/pure.toml

```markdown
# このコマンドは以下のように実行されます: /refactor:pure

description = "現在のコンテキストにあるコードを、純粋関数へとリファクタリングするようモデルに指示します。"

prompt = """
現在のコンテキストで提供されているコードを分析してください。
それを純粋関数へとリファクタリングしてください。

あなたのレスポンスには以下を含めてください:
1. リファクタリングされた純粋関数のコードブロック。
2. あなたが加えた主要な変更点と、それがなぜ純粋性に寄与するのかについての簡単な説明。
"""
```

**3. コマンドを実行する:**

以上です！CLIでコマンドを実行できるようになりました。まずコンテキストにファイルを追加し、それからコマンドを呼び出してください:

```
> @my-messy-function.js
> /refactor:pure
```

Qwen Codeは、TOMLファイルで定義された複数行のプロンプトを実行します。
```

## 入力プロンプトのショートカット

これらのショートカットは、テキスト操作のために入力プロンプトに直接適用されます。

- **元に戻す (Undo):**
  - **キーボードショートカット:** 入力プロンプトで最後のアクションを元に戻すには、**Ctrl+z** を押してください。

- **やり直し (Redo):**
  - **キーボードショートカット:** 入力プロンプトで最後に元に戻したアクションをやり直すには、**Ctrl+Shift+Z** を押してください。

## At コマンド (`@`)

At コマンドは、ファイルやディレクトリの内容をプロンプトに含めるために使用されます。これらのコマンドには Git を意識したフィルタリング機能が含まれています。

- **`@<ファイルまたはディレクトリのパス>`**
  - **説明:** 指定したファイルまたは複数のファイルの内容を現在のプロンプトに挿入します。特定のコードやテキスト、ファイル群について質問する際に便利です。
  - **例:**
    - `@path/to/your/file.txt このテキストを説明してください。`
    - `@src/my_project/ このディレクトリ内のコードを要約してください。`
    - `このファイルは何についてですか？ @README.md`
  - **詳細:**
    - 単一のファイルパスが指定された場合、そのファイルの内容が読み込まれます。
    - ディレクトリパスが指定された場合、そのディレクトリおよびサブディレクトリ内のファイル内容を読み込もうとします。
    - パスにスペースが含まれる場合は、バックスラッシュでエスケープしてください（例: `@My\ Documents/file.txt`）。
    - 内部的には `read_many_files` ツールを使用しています。内容が取得された後、クエリに挿入されてからモデルに送信されます。
    - **Git を意識したフィルタリング:** デフォルトでは、Git で無視されるファイル（`node_modules/`、`dist/`、`.env`、`.git/` など）は除外されます。この動作は `context.fileFiltering` 設定で変更できます。
    - **ファイルタイプ:** このコマンドはテキストベースのファイルを対象としています。バイナリファイルや非常に大きなファイルは、パフォーマンスと関連性を保つために、`read_many_files` ツールによってスキップまたは切り捨てられることがあります。ツールはファイルがスキップされたかどうかを示します。
  - **出力:** CLI には `read_many_files` が使用されたことを示すツール呼び出しメッセージと、処理されたパスおよびステータスの詳細が表示されます。

- **`@`（単独の @ 記号）**
  - **説明:** パスなしで単独の `@` 記号を入力した場合、クエリはそのままモデルに渡されます。プロンプト内で `@` 記号について話す場合に便利です。

### `@` コマンドのエラーハンドリング

- `@` の後に指定されたパスが見つからない、または無効な場合、エラーメッセージが表示され、クエリはモデルに送信されないか、ファイル内容なしで送信されることがあります。
- `read_many_files` ツールがエラー（例：権限の問題）に遭遇した場合も、その旨が報告されます。

## シェルモードとパススルー コマンド（`!`）

`!` プレフィックスを使用すると、Qwen Code 内から直接システムのシェルとやり取りできます。

- **`!<shell_command>`**
  - **説明：** Linux/macOS では `bash` を使用し、Windows では `cmd.exe` を使用して、指定された `<shell_command>` を実行します。コマンドからの出力やエラーはすべてターミナルに表示されます。
  - **例：**
    - `!ls -la` （`ls -la` を実行し、Qwen Code に戻る）
    - `!git status` （`git status` を実行し、Qwen Code に戻る）

- **`!`（シェルモードの切り替え）**
  - **説明：** 単独で `!` と入力すると、シェルモードを切り替えます。
    - **シェルモードに入る：**
      - アクティブな場合、シェルモードでは別のカラー設定と「Shell Mode Indicator」が使用されます。
      - シェルモード中に入力したテキストは、そのままシェルコマンドとして解釈されます。
    - **シェルモードを抜ける：**
      - 抜けると UI は標準の外観に戻り、通常の Qwen Code の動作に戻ります。

- **すべての `!` 使用時の注意点：** シェルモードで実行するコマンドは、端末で直接実行した場合と同じ権限と影響を持ちます。

- **環境変数：** `!` 経由またはシェルモードでコマンドが実行される際、サブプロセスの環境には `QWEN_CODE=1` という環境変数が設定されます。これにより、スクリプトやツールが CLI 内から実行されているかどうかを検出できます。